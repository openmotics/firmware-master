'************************************************************************
'Copyright (c) 2020 - OpenMotics <info@openmotics.com>

'This file is part of OpenMotics.

'OpenMotics is free software: you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation, either version 3 of the License, or
'(at your option) any later version.

'OpenMotics is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.

'You should have received a copy of the GNU General Public License
'along with OpenMotics.  If not, see <http://www.gnu.org/licenses/>.
'************************************************************************
                                                                                                                       
'Firmware to be used with the OpenMotics Gateway Module and programmed on the Microchip PIC18F67J11

'Written in Pic Basic Pro 2.6 however it should be compatible with Pic Basic Pro 3.0 but this is not yet tested
'Interrupt system of Darrel Taylor is used see http://darreltaylor.com/DT_INTS-18/home.html
                           
'---------------------------------------------------------------------------------------------------------------
'For more information, schematics etc see 
'   http://wiki.openmotics.com
'For details regarding the implemented Master RS232 CLI instructions see       
'   http://wiki.openmotics.com/index.php/CLI_Reference_Guide 
'For details regarding the implemented Master RS232 API instructions see
'   http://wiki.openmotics.com/index.php/API_Reference_Guide
'For details regarding the used RS485 communication protocol see
'   http://wiki.openmotics.com/index.php/Master_RS485_Cummunication_Protocol                                                 
'For details regarding the used memory layout of the eeprom see
'   http://wiki.openmotics.com/index.php/Memory_Model
'For more information regarding the different implemented action types and basic actions see
'   http://wiki.openmotics.com/index.php/Action_Types
'For more information regarding the implemented error codes see
'   http://wiki.openmotics.com/index.php/Error_Codes
'For the release notes since V3.140.104 see
'   http://wiki.openmotics.com/index.php/Master_Release_Notes
'---------------------------------------------------------------------------------------------------------------

'-------INCLUDES-------------
INCLUDE "DT_INTS-18.bas"                    ' Base Interrupt System
INCLUDE "ReEnterPBP-18.bas"                 ' Include if using PBP interrupts

'-------DEFINES--------------
DEFINE      OSC 40                          'Oscillator 40Mhz
define      NO_CLRWDT 1

'-------CONSTANTS------------
VERSION             con 3
FIRMWARE            con 143                                    
BUILT               con 132

HARDWARE            con 4
BUFFER_RS232        con 120                         ' Number of bytes received from serial buffer
NR_OF_CMD           con 161                         ' nr of commands (command line instructions)
RS9600              con 84
RS19200             con 32
PAUSE_VALUE         con 5                           'pause between putting RS485 in send mode and effectively sending data
BUFFER_RS485        con 21                          'Number of bytes receices from RS485 bus
QUEUE_MAX           con 95
SCHED_QUEUE_MAX     con 57
TIMER_QUEUE         con 50
'MAX_THERMOSTATS     con 32                          'put at 24 because RAM of DS1307, maximum 32 !!!
PULSECOUNTERS       con 24
MAX_INPUTS          con 240
MAX_OUTPUTS         CON 240
MAX_SENSORS         CON 32
MAX_MODULES         con 60
MAX_INPUT_MODULES   con 30
MAX_OUTPUT_MODULES  con 30
MAX_RS_MODULES      con 30
'MAX_PUMP_GROUPS     con 8
MAX_DELAY_ACTIONS   con 240
MAX_ERRORS          con 62
MAX_DIGIT           con 9
MAX_E               con 20
MAX_BROAD_QUEUE     con 20                          'depth of the broadcast queue
YES                 con 1
NO                  con 0
MAX_CAN_CONTROLS    con 4

START               con 0
STEP1               con 1
STEP2               con 2
STEP3               con 3
STEP4               con 4
STEP5               con 5

ERASE_SENSORS       con 0
ERASE_INPUTS        con 1


'------MUST AT STARTUP---------
WDTCON.0=1  'Watchdog timer enable
RconAtStartup var byte
RconAtStartup=RCON
RCON.bit0=1 'Brown out reset clear
RCON.bit1=1 'Power On reset clear
RCON.bit4=1 'Reset clear
OSCCON.0=0                                  'external oscillator
OSCCON.1=0
OSCTUNE.6=1                                 'PLL enabled
INTCON=%00000000 

'--------HARDWARE---------------
RS485_DIR   var     PORTC.0                 'Mode for RS485 chip (send or receive)
Button2     var     PORTB.1
PowerSlaves var     PORTD.3                 'Relay to drive power on the RS485 Bus
DPIN2       var     PORTD.5                 'i2c pins - SDA
CPIN2       var     PORTD.6                 'i2c pins - SCL
led_red     var     PORTC.3
Low         PowerSlaves                     'Switch ON PowerSlaves
high        led_red
TRISG = %11111111
TRISF = %11111111
TRISE = %10111111
TRISD = %11111111
TRISC = %11111110
TRISB = %11111111
TRISA = %11111111

'---------UART------------------
BAUDCON1 = %01001000
BAUDCON2 = %01001000
SPBRGH1 = 0                                 '115200 baud
SPBRG1 = 86
SPBRGH2 = 0                                 '115200 baud
SPBRG2 = 86
RCSTA1 = %10010000
RCSTA2 = %10010000
TXSTA1 = %00100110
TXSTA2 = %00100110
RCSTA2.4=0                                  'disable serial 2 receiver
RCSTA1.4=0                                  'disable serial 1 receiver

'--------I2C--------------------
SSP2ADD=124                                 'i2c at 80kHz
SSP2STAT=%10000000
SSP2CON1=%00101000

'--------VARIABLES--------------
press_state                 var byte
All_stores_locked           var byte
All_stores_overule_locked   var bit
UptimeDays          var word
startup             var bit
NrOutputsOn         var byte
RecSer1             var bit
PointerSer1         var byte
RecSer1Temp1        var byte
RecSer1Temp2        var byte
InterpreteSer1      var bit
RecSer2             var bit
InstrOk             var bit
PointerSer2         var byte
MaxChar             var byte
RecSer2Temp1        var byte          
RecSer2Temp2        var byte
RecSer2Temp3        var byte
TimeOutSer1         var bit
OdCode              var byte                'Output Debug Code
OdOutputNr          var byte                'Output Debug Output Nr
InputDebug          var bit
ApiExit             var bit
InputFilter         var byte
UpDwn               var bit
UpDir               var bit
GroupDimValue       var byte
GroupNr             var byte
GroupOn             var bit
OutputNrWrites      var byte
OutputModuleNr      var byte
indicate            var byte
IndicateInput       var bit
IndicateTemperature var bit
IndividualTempOn    var bit
poll                var bit
pollNr              var byte
pollNrOut           var byte
pollNrOutRS         var byte     
command             var byte                ' Storage for command
i                   var byte                ' Storage for loop counter
i_bit               VAR BIT
i_bit2              VAR BIT
ic                  var byte
temp                var word                ' Storage for temperature
EchoOnBit           var bit
test                var byte
cmd                 var byte
instruction         var byte
k                   var byte
CharPointer         var Byte
DigitCount          var byte
length              var byte
s                   var byte
vi                  var byte
t_word              var word
t_word2             var word
DebugMode           var bit
AutResponse         var bit
AutResponseOL       var bit
AutResponseIL       var bit
AutResponseSO       var bit
AllOff              var bit
DuplicateID         var bit
ok                  var bit                 'if =1 -> "OK" message on console in CLI mode
LastDimmer          var byte                'last light switched on with "ON" instruction
RecCounter          var byte                '# of received character
char                var byte
j                   var byte
i2ccont             var byte                'chip address
i2caddr             var byte                'address within the chip to select data
i2cdata             var byte                'data to read or write
i2cMode             var byte
i2cAck              var bit
i2cInt              var bit
i2creadbit          var bit
i2cClock            var bit
i2cError            var word
i2cError2           var word
i2cTimeScan         var byte
ResetI2c            var bit
tp                  var byte
err                 var bit
mode                var byte                'mode="L"-> live mode, mode="I"-> Initialization mode
mode_com            var bit                 'mode_com=1 -> advanced mode, =0 Simple mode (command line)
broad1              var byte
broad2              var byte
broadID             var byte
broadData           var byte
x                   var byte
y                   var byte
z                   var byte
a                   var byte
b                   var byte
c                   var byte
d                   var byte
e                   var byte
t                   var byte
ti                  var byte
q                   var byte
u                   var byte               'loop counter used in all_lights_off funtion
v                   var byte
w                   var byte
f                   var byte
g                   var byte
r                   var byte
m                   var byte       
n                   var byte
cid                 var byte
CIDused             var bit
write_yes           var bit
write_yes_RS        var bit
press               var bit
input_pressed       var byte
eep_addr            var word                'memory address in eeprom
Fcommand            var byte
e_word              var word                'temp variable
z1                  var byte
CurrentInput        var byte                'This byte will hold the current switch being pressed
IfInstr             var byte
controller_in       var byte                'number of input controllers
controller_out      var byte                'number of output controllers
controller_out_RS   var byte                'number of Roller/Shutter controllers when Large installation is enabled
LargeInstallation   var bit                 'When Large Installation is enabled, Roller/Shutter modules will be placed in the Roller/Shutter list
TempCor             var bit
TemperatureCount    var byte
CheckTemp           var bit
TempCom             var byte
textstart           var byte
textlength          var byte
text                var bit
p                   var byte
f0                  var byte
f1                  var byte
AddToQueue          var bit
cmi                 var byte                'Loop counter to calculate Module_ID         
timer               var word                'Timer set value
error_code          var byte                'used in the subroutine "send_error"
ErrorTmp            var byte
ErrorMax            var word
dim_minimum         var byte
dim_step            var byte
dim_cycle           var byte
dimmer_mem          var Byte 
queue_pointer       var byte                'number of actions in the queue
queue_end           var byte
queue_module_nr     var byte
queue_input_nr      var byte
queue_counter       var byte
decision_old        var bit
decision_new        var bit
Sched_queue_counter var byte
Sched_bit           var bit
timer_queue_pointer var byte                    'Number of timer actions in the queue
timer_queue_last    var bit
WaitTimeInput       var byte
WaitTimeOutput      var byte
PollTimeInput       var byte
PollTimeOutput      var byte
PollTimeMain        var byte
RS485busy           var bit
RS485message        var byte
hours               var byte
minutes             var byte
seconds             var byte
seconds_old         var byte
days                var byte
date                var byte
month               var byte
year                var byte
NumberOfChar        var byte
PowerSafe           var bit
Spaces              var bit 
'ThermostatUpdate    var bit
'ThermostatMode      var byte
'ThermostatOn        var bit
'hier_thermostat
'ThermostatEnabled   var bit
'ThermostatCooling   var bit
'pid                 var byte  
'actual              var byte
'ErrorPid            var word
'Psign               var bit
'Isign               var bit
'Dsign               var bit
'Xword               var word
'Xbyte               var byte
'Kp                  var byte
'Ki                  var byte
'Kd                  var byte
'Drive               var word
'DriveOutput         var byte
'IntThresh           var byte
'Dr                  var byte
'PidMode             var bit
'pump                var bit
'pump_delay          var byte
Temp_Mod_Installed  var bit
'Temp_Threshold      var byte
Outside_sensor      var byte
'Tt                  var byte                                 'Thermostat timing
level               var byte                              'which floor level that needs to be switched off
jf                  var byte                                 'variables for All_lights_off function
xf                  var byte
yf                  var byte
zf                  var byte
af                  var byte
bf                  var byte
cf                  var byte
CRC                 var word
CRC2                var word
ForceCRC            var bit                            'if 1, message from input modules without CRC will be ignored and dropped
c1                  var byte
x1                  var byte
y1                  var byte
ToggleFollowON      var bit
ToggleFollowActive  var bit
ToggleFollowData    var bit
TimerQueueEn        var bit
DelayedTime         var byte
ActionButtonRelease var bit
'PumpCheckNow        var bit
'PumpCheckCounter    var byte
CheckTimerQueue     var bit
'PidCalcNow          var bit
'PidCalcCheck        var bit
'PidCalcCounter      var byte   
StoreMove           var bit
'SetAuto             var bit
CleanTimerQueue     var bit
EepPage0            var bit
OledEeprom          var word
OledEepromBit       var bit
Oleddata            var byte
OleddataAddr        var word
OledDataOk          var bit
SyncDebug           var bit
SyncEnable          var bit
'ThermostatCounter   var byte
'ThermostatUpLimitTemp   var byte
'ThermostatDownLimitTemp var byte
'TemperatureCounter  var byte
OledActionType      var byte
OledActionNumber    var Byte
OledActionType2     var byte
OledActionNumber2   var Byte
OledInstr0          var byte
OledInstr1          var byte
UpdateCanLeds       var bit
RecBytesSer1        var byte
CatchAll            var bit
CatchAllByte        var byte
ScanTime            var bit
ScanTimeCounter     var byte
BootLoaderMode      var bit
PollCheck           var byte

'BroadFromQueue      var bit
'BroadPointer        var byte
'BroadCounter        var byte
broad_end_pointer   var byte
broad_start_pointer var byte
broad_queue_size    var byte
broad_state_machine var byte
broad_wait_time     var byte

rs485_timeout       var byte
rs485_timeout_max   var byte
ToggleTypeUsed      var bit
'EepromSetptWrite    var bit
'ThermostatNr        var byte
TimerRSenabled      var bit                          'Enable/disable an automatic stop value in the delay queue when a roller shutter is been moved up/down
TimerRSenabled=1
ValBitNr            var byte
BA_parameter_used   var bit
BA_parameter        var word
BA_action           var byte
BA_type             var byte
BA_action_queue     var byte
BA_type_queue       var byte
can_control_number  var byte
erase_type          var bit
dimmer_value_eeprom_write       var   bit
dimmer_value_eeprom_write_now   var   bit
state_machine_eeprom_write      var   byte
Nr_rs485_power_resets           var   byte
AllInputsAlwaysEnabled          var   bit
dimmer_nr           var byte
dimmer_module_nr    var byte
ErrorCount_Can      var word
ErrorCount_Can_Max  var word
shutter_nr          var byte
InputResult         var byte

'------------ARRAYS------------------------
A_ldr               var byte[MAX_SENSORS]            'light intensity measured on input module
A_humidity          var byte[MAX_SENSORS]
A_Temperature       var byte[MAX_SENSORS]            'A_Temperature on input module or A_Temperature Module
'A_Setpt             var byte[MAX_THERMOSTATS]                 'A_Temperature setpoint
'A_Integral          var byte[MAX_THERMOSTATS]
'A_Last              var byte[MAX_THERMOSTATS]
'A_Thermostat        var byte[MAX_THERMOSTATS]
'A_Thermostat2       var byte[MAX_THERMOSTATS]
'A_ThermostatSensor  var byte[MAX_THERMOSTATS]
'A_ThermostatAuto    var bit[MAX_THERMOSTATS]
'A_Airco             var bit[MAX_THERMOSTATS]          'Enable/disable Airco when using RTD-10
A_InputEnable       var bit[MAX_INPUTS]
A_PressTime         var byte[MAX_INPUTS]            'length of time (number of cycles) a button has been pressed
A_SwitchType        var bit[MAX_INPUTS]
A_TimerCd           var word[MAX_OUTPUTS]   'Timer Count Down
A_TimerSet          var bit[MAX_OUTPUTS]
A_OutUpdate         var bit[MAX_OUTPUTS]
A_SelOutput         var byte[MAX_OUTPUTS]   'link between input and selected output (<240 -> toggle selected output, >239 -> perform group action list)
A_DimmerValue       var byte[MAX_OUTPUTS]   'dimmer value (240 x 6bits value)
A_DimDirection      var bit[MAX_OUTPUTS]    'Dimmer direction (1 bit per light), 1 dimming up, 0 dimming down
A_PulseCounter      var word[PULSECOUNTERS]
A_PulseInput        var byte[PULSECOUNTERS]
'A_PumpOn            var bit[MAX_PUMP_GROUPS]
'A_RescueCounter     var byte[MAX_PUMP_GROUPS]   
A_InputDelayAction  var bit[MAX_DELAY_ACTIONS]
A_Ttiming           var byte[4]
A_ValBit            var BIT[256]
A_SchedHour         var byte[Sched_queue_max]
A_SchedMinute       var byte[Sched_queue_max]
A_SchedDay          var Byte[Sched_queue_max]
A_SchedType         var byte[Sched_queue_max]
A_SchedAction       var byte[Sched_queue_max]   'Timer queue for decision that measure the time of an input before taking an action
A_TimerAction       var byte[timer_queue]       'Action (that will be copied in the action queue when true)
A_TimerType         var byte[timer_queue]       'Action type (decision or simple action or group action)
A_TimerInput        var byte[timer_queue]       'Input (that remains active) that is measured
A_TimerSeconds      var byte[timer_queue]       'Seconds that an input must remains pressed before the action is activated (copied in the action queue)
A_ModID0            var byte[MAX_MODULES]
A_ModID1            var byte[MAX_MODULES]
A_ModID2            var byte[MAX_MODULES]
A_ModID3            var byte[MAX_MODULES]         
A_ErrorID           var byte[4]
A_ErrorBit          var BIT[MAX_ERRORS]
A_ErrorCount        var word[MAX_ERRORS]
A_QueueType         var byte[QUEUE_MAX]     'type of intelligent action (simple action, group action, simple decision or group decision)
A_QueueAction       var byte[QUEUE_MAX]     'action number
A_Action            var byte[8]
A_Input             var byte[MAX_INPUT_MODULES]            'Input that has been read from the different input controllers
A_InputInvert       var byte[MAX_INPUT_MODULES]
A_InputOld          var byte[MAX_INPUT_MODULES]            'A_Last input that has been read from the different input controllers
A_Output            var byte[MAX_OUTPUT_MODULES]           'Output that has written to the output controllers
A_OutputRS          var byte[MAX_RS_MODULES]
A_VirtualSensor     var bit[MAX_SENSORS]
'A_PermanentManual   var bit[MAX_THERMOSTATS*2]
A_TempOffset        var byte[MAX_SENSORS]
A_WriteYesMod       var byte[MAX_OUTPUT_MODULES]
A_WriteYesModRS     var bit[MAX_RS_MODULES]
A_RS485string       var byte[BUFFER_RS485]
A_RecChar           var byte[BUFFER_RS232]  'Received command line characters
A_SerString         VAR Byte[BUFFER_RS232]
A_FreeVar           var byte[32]
A_TestChar          var bit[nr_of_cmd]
A_Digit             var byte[5]             ' max 5 digits
A_DigitTotal        var word[MAX_DIGIT]
A_e                 var byte[MAX_E]
A_broad1            var byte[MAX_BROAD_QUEUE]
A_broad2            var byte[MAX_BROAD_QUEUE]
A_broadId           var byte[MAX_BROAD_QUEUE]
A_broadData         var byte[MAX_BROAD_QUEUE]
A_cc_inputs         var byte[MAX_CAN_CONTROLS]
A_cc_sensors        var byte[MAX_CAN_CONTROLS]
A_cc_outputs        var byte[MAX_CAN_CONTROLS]

'------------INTERRUPTS--------------------

;----[High Priority Interrupts]-----------------------------------------------
ASM
INT_LIST  macro      ; IntSource,      Label,     Type, ResetFlag?
        INT_Handler     RX1_INT,     _Receive1,    PBP,  no 
        INT_Handler     RX2_INT,     _Receive2,    PBP,  no 
        INT_Handler     TMR0_INT,    _Timer0,      PBP,  yes
        INT_Handler     TMR2_INT,    _Timer2,      PBP,  yes        
        INT_Handler     TMR3_INT,    _Timer3,      PBP,  yes     
        INT_Handler     SSP2_INT,    _SSP2,        PBP,  no                      
    endm
    INT_CREATE                              ; Creates the High Priority interrupt processor
ENDASM

T0CON = %00000000                           ; Timer 0 setting, prescaler 2, 16 bits, overflow after +/- 6,5 ms
T2CON = %00000011                           ; T2 = 8-bit, no prescaler and 16 postscaler (interrupt every 0,4ms)
T3CON = %00101000                           ; T3 = 16-bit, 1:4 prescaler, interrupt every 26ms
 
@    INT_ENABLE  RX1_INT                    ; Enable USART Receive interrupts
@    INT_ENABLE  RX2_INT                    ; Enable USART Receive interrupts
@    INT_ENABLE  TMR0_INT                   ; enable Timer 0 interrupts
@    INT_ENABLE  TMR2_INT                   ; enable Timer 2 interrupts
@    INT_ENABLE  TMR3_INT                   ; enable Timer 3 interrupts for i2c timeout
@    INT_ENABLE  SSP2_INT                   ; enable SPI 2 interrupt (i2c)

RCSTA1.4=1                                  'enable serial 1 receiver
RCSTA2.4=1                                  'enable serial 2 receiver
PIE2.1=1                                    'Timer 3 interrupt enable
PIR2.1=0                                    'Clear timer3 interrupt flag
T3CON.0=0                                   'stop timer3
PIE1.1=1                                    'timer 2 interrupt enabled
T2CON.2=1                                   'timer2 started                
                            
'-------------INIT VARIABLES--------------
BA_parameter_used=NO
All_stores_locked=NO
All_stores_overule_locked=NO
'A_PumpOn[0]=0
'A_PumpOn[1]=0
'A_PumpOn[2]=0
'A_PumpOn[3]=0
'A_PumpOn[4]=0
'A_PumpOn[5]=0
'A_PumpOn[6]=0
'A_PumpOn[7]=0
'A_RescueCounter[0]=0
'A_RescueCounter[1]=0
'A_RescueCounter[2]=0
'A_RescueCounter[3]=0
'A_RescueCounter[4]=0
'A_RescueCounter[5]=0
'A_RescueCounter[6]=0
'A_RescueCounter[7]=0
startup=YES                                   'processor is in startup mode
NrOutputsOn=0
RecSer1=0
PointerSer1=0
InterpreteSer1=0
RecSer2=0
PointerSer2=0
MaxChar=18
TimeOutSer1=0
InputDebug=0
ApiExit=0
OutputNrWrites=3
OutputModuleNr=0
indicate=255
poll=1
pollNr=0
pollNrOut=0
pollNrOutRS=0        
i2cMode=0
i2cInt=0
i2cClock=0
i2cError=0
i2cError2=0
i2cTimeScan=0
ResetI2c=0
CIDused=0
CurrentInput=255
IfInstr=255
TempCom=0
PollTimeInput=0
PollTimeOutput=0
RS485busy=NO
'PidMode=0                                   'Pid Debug off
TimerQueueEn=0
DelayedTime=0
ActionButtonRelease=0
'PumpCheckNow=0
'PumpCheckCounter=0
'PidCalcNow=0
'PidCalcCheck=0
'PidCalcCounter=0    
'SetAuto=0
CleanTimerQueue=1             'always check for double BA's in the timer queue qnd remove doubles, see also BA 79
EepPage0=0
OledEeprom=0
OledEepromBit=0
OledDataOk=0
SyncDebug=0
SyncEnable=1
'ThermostatCounter=0
'TemperatureCounter=0
UpdateCanLeds=0
RecBytesSer1=14
CatchAll=0
CatchAllByte=6
BootLoaderMode=0                            'Normal mode
PollCheck=0
i2cdata=255
ToggleFollowON=0
ToggleFollowActive=0
OledInstr0=255
OledInstr1=255
OledActionType=255
OledActionNumber=255
'BroadPointer=0
'BroadCounter=0
broad_end_pointer=0
broad_start_pointer=0
broad_queue_size=0
broad_state_machine=START
can_control_number=0
dimmer_value_eeprom_write=NO
dimmer_value_eeprom_write_now=NO
state_machine_eeprom_write=0
Nr_rs485_power_resets=0
CLEARWDT
pause 80
mode_com=0                                  'simple communication mode
ok=1
input_pressed=255
write_yes = 0
i2cdata = 255           
i2caddr = 255
x = 0
y = 0
z = 0
temp.byte0 = 0
temp.byte1 = 128                            'We don't know yet if the sensor is connected or working
timer_queue_pointer = 0                     'nothing in the queue
mode="L"                                    'Live mode
gosub reset_error

'hserout2 ["Fase 1",13,10]

for i=0 to MAX_DELAY_ACTIONS-1
  A_InputDelayAction[i]=0
next i

for i=0 to MAX_OUTPUTS-1
  A_TimerCd[i]=0
  A_TimerSet[i]=0
  A_OutUpdate[i]=0
  eep_addr.byte1=232                      'page 232
  eep_addr.byte0=i
  gosub read_eeprom 
  if i2cdata<64 then
    A_DimmerValue[i]=i2cdata
  else
    A_DimmerValue[i]=63
  endif  
next i

for i=0 to MAX_INPUTS-1
  A_InputEnable[i]=1
  A_PressTime[i]=0
  A_SwitchType[i]=1
next i

for i=0 to QUEUE_MAX-1
  A_QueueType[i]=255
  A_QueueAction[i]=255
next i

timer_queue_pointer = 0                     'nothing in the queue
for i=0 to (timer_queue-1)                  'put timerqueue correctly
  A_TimerAction[i]=255
  A_TimerType[i]=255
  A_TimerInput[i]=255
  A_TimerSeconds[i]=255
next i
queue_pointer=0
queue_end=0                         'nothing in the queue

for i=0 to (Sched_queue_max-1)
  A_SchedHour[i]=255
  A_SchedMinute[i]=255
  A_SchedDay[i]=255
  A_SchedType[i]=255
  A_SchedAction[i]=255
next i
for i=0 to 29
  e_word.byte0=255
  e_word.byte1=255
  A_ErrorCount[i]=0
  A_ErrorCount[i+30]=0
  A_InputInvert[i]=255
next i
for i=0 to (MAX_SENSORS-1)
  A_ldr[i]=255
  A_Temperature[i]=255
  A_humidity[i]=255
  A_FreeVar[i]=0  
next i
'for i=0 to (MAX_THERMOSTATS-1)
'  A_Thermostat[i]=255
'  A_Airco[i]=0
'next i
for i=0 to (PULSECOUNTERS-1)
  A_PulseCounter[i]=0
next i
Sched_queue_counter=0                       'scheduled queue is empty
level=255
OledInstalled var bit
OledInstalled=0
rs485_timeout_max=4

CLEARWDT
'delete
pause 1000
CLEARWDT
pause 1000
CLEARWDT

'--------------SET THERMOSTATS-------------
'Gosub Check_Thermostat_values               'Check if night A_Temperature values are correctly programmed
'CLEARWDT
Gosub eeprom_activate                       'Copy eeprom values into RAM
CLEARWDT

'-----------LARGE INSTALLATION MODE--------
gosub Check_LIM                             'Check if Large installation mode can be enabled

'-----------CLOCK--------------------------
Gosub find_clock                            'Find DS1307 and check if Output(x) is available in RAM DS1307
mode="L"                                    'Bus in Live mode
broad1="L"
broad2="L"
BroadID=0
gosub send_broad_immediatly
pause 10
gosub send_broad_immediatly
for i=1 to controller_out                   'write output to all modules
  if i<MAX_OUTPUT_MODULES+1 then A_WriteYesMod[i-1]=OutputNrWrites
next i
write_yes=1
if controller_out_RS>0 then
  for i=1 to controller_out_RS                'write output to all modules
    if i<MAX_RS_MODULES+1 then A_WriteYesModRS[i-1]=1
  next i
  write_yes_RS=1
else
  write_yes_RS=0
endif 
CLEARWDT   
pause 20
gosub rs485_output
ok=0
gosub normal_Powerstate                     'Put all leds in normal power state
pause 50
gosub startup_activate                      'copy actions in startup page to the A_Action queue
ok=1               
PIE3.7=1                                    'enable interrupt
CLEARWDT
for i=1 to controller_out                   'Put timervalues of all outputs
  for t=0 to 7
    y=((i-1)*8)+t
    timer=y
    gosub Timer_value_read                'Retreive timer value
    if y<MAX_OUTPUTS then A_TimerCd[y]=timer  
  next t
next i 

'delete         Problem with Clock RAM must be solved first
'gosub all_outputs_off 
gosub all_outputs_off_rs

'gosub thermostat_timing                     'set all thermostats in the right mode conform to the programmed timings
'gosub Thermostat_Multi_tenant               'Set all the correct Setpt when in Multi-tenancy mode
'CLEARWDT
'gosub correct_setpt
'gosub Set_CoolingHeating
'hier_thermo
'gosub read_setpt_eeprom  

CLEARWDT
'Gosub eeprom_activate                       'Copy eeprom values into RAM

gosub check_RCON    'check the startup bits to know if for example a watchdog reset has happened
gosub read_date
'delete
'hserout2 ["Startup Done",13,10]
startup=NO                                   'startup is finished
  

'------------------------------------------------------------------------------
' Start Main Routine
'------------------------------------------------------------------------------
 
MainLoop:
  CLEARWDT
  if pollcheck>2 then pollcheck=0
  gosub communication_error                 'Resolve communication errors, rs232 and i2c
  CLEARWDT
  gosub reset_i2c
  CLEARWDT
  gosub rs232_interprete
  CLEARWDT
  gosub rs485_interprete
  CLEARWDT
  gosub Update_Can_leds
  CLEARWDT
  gosub dimmer_value_write    
  if mode="L" and bootloadermode=0 then     'normal operation
    high led_red
    gosub check_button                      'check buttons
    CLEARWDT   
    gosub read_clock                        'check time and timer
    CLEARWDT
    'gosub Pid_Calc                          'Check if Thermostat PID calculation needs to be done
    'CLEARWDT
    'gosub Pump_Check                        'Check If Pumps needs to be checked
    'CLEARWDT
    gosub rs485_poll                        'poll input modules
    CLEARWDT
    gosub RS485_output                      'write outputs
    CLEARWDT
    gosub RS485_outputRS                    'Write Roller/Shutter in Large installation
    CLEARWDT
    gosub RS485_fault                       'check if errors occured
    CLEARWDT
    gosub check_queue
    CLEARWDT
    gosub check_timer_queue
    clearWDT
    gosub check_system_health
  endif
  clearwdt
  gosub check_broad_queue
goto MainLoop


'----------------------------------------------------------------------------
' Interrupt routines
'----------------------------------------------------------------------------

Receive1:                                       'RS485
    recser1temp1=recser1temp2                   'Keep previous character also
    recser1temp2=RCREG1
    if recser1=1 then                           'Receiving? 
        'if PointerSer1<BUFFER_RS485 then A_RS485string[PointerSer1]=recser1temp2
        A_RS485string[PointerSer1]=recser1temp2 
        pointerser1=pointerser1+1        
        if PointerSer1>=(BUFFER_RS485-1) then
            RecSer1=0                           'stop receiving ser1 and buffering/interpreting
            InterpreteSer1=1
            RCSTA1.4=0                          'disable receiving serial 1
        else
            if recser1temp1=13 and recser1temp2=10 then
                RecSer1=0                           'stop receiving ser1 and buffering/interpreting
                InterpreteSer1=1 
                RCSTA1.4=0                          'disable receiving serial 1
                T0CON.7=0                           'timer 0 disabled
            else
                if Rs485message="O" then
                    if PointerSer1>RecBytesSer1 then    'Output message (Dimmer, output or Store module)
                        RecSer1=0                       'stop receiving ser1 and buffering/interpreting
                        InterpreteSer1=1
                        RCSTA1.4=0                      'disable receiving serial 1
                        T0CON.7=0                       'timer 0 disabled
                    endif
                endif        
            endif
        endif           
    else 
        if recser1temp1="R" and recser1temp2="C" then
            Pointerser1=0
            recser1=1                           'start receiving ser1
            interpreteser1=0
        endif
        if recser1temp1="G" and recser1temp2="M" then
            Pointerser1=0
            recser1=1                           'start receiving ser1
            interpreteser1=0
        endif
    endif    
@ INT_RETURN

Receive2:                                   'RS232
  recser2temp1=recser2temp2                 'Keep previous character also
  recser2temp2=recser2temp3
  recser2temp3=RCREG2
  if Mode_com=0 then                        'CLI Mode
    if PointerSer2<BUFFER_RS232 then A_SerString[PointerSer2]=recser2temp3
    if (recser2temp3=13) or (PointerSer2>(BUFFER_RS232-2)) then    
      RecSer2=0                             'stop receiving ser2 and buffering/interpreting
      RCSTA2.4=0                            'disable receiving serial 2
    else
      if RecSer2Temp3=8 or RecSer2Temp3=27 or RecSer2Temp3=127 then
        if PointerSer2>0 then pointerser2=pointerser2-1
      else
        pointerser2=pointerser2+1 
      endif  
    endif
    if EchoOnBit=1 then
      TXREG2=recser2temp3
    endif
  else                                      'API Mode
    if RecSer2=1 then                       'in Buffering mode
      if PointerSer2>(MaxChar-2) then       'stop when MaxChar characters are received   
        RecSer2=0                           'stop receiving ser2 and buffering/interpreting
        RCSTA2.4=0                          'disable receiving serial 2
      else
        if PointerSer2<BUFFER_RS232 then A_SerString[PointerSer2]=recser2temp3
        pointerser2=pointerser2+1
      endif  
    else                                    'Not in buffering mode
      if recser2temp1="S" and recser2temp2="T" and recser2temp3="R" then 'start message 
        RecSer2=1                           'Start receiveing
      endif    
    endif  
  endif
@ INT_RETURN

SSP2:
  PIE3.7=0                                  'disable interrupt
  if i2cmode>0 then i2cMode=i2cMode+1
  i2cInt=1

  PIR3.7=0                                  'clear interrupt flag
  PIE3.7=1                                  'enable interrupt   
@ INT_RETURN

Timer0: 
  'This timer is enabled and will wait max 100 ms for the remote modules to answer
  if rs485_timeout>0 then
    rs485_timeout=rs485_timeout-1
  endif   
  if Interpreteser1=0 and rs485_timeout=0 then
    T0CON.7=0                               'timer 0 disabled
    TimeOutSer1=1
    RCSTA1.4=0                              'disable receiving serial 1
  endif      
@ INT_RETURN

Timer2:                                     'interrupt every 0.4096ms for communication
  T2CON.2=0                                 'timer 2 disabled
  TMR2=0                                    'reset value 
  if pollTimeInput>0 then pollTimeInput=pollTimeInput-1
  if pollTimeOutput>0 then pollTimeOutput=pollTimeOutput-1
  if broad_wait_time>0 then broad_wait_time=broad_wait_time-1
  if ScanTimeCounter=0 then 
    ScanTime=1                              'Only check clock every 104ms
    CheckTimerQueue=1                       'Only check timer queue every 104ms
  endif  
  ScanTimeCounter=ScanTimeCounter+1
  PIR1.1=0                                  'interrupt flag cleared
  T2CON.2=1                                 'timer 2 enabled
@ INT_RETURN

Timer3:                                     'Timer used for i2c
  PIR2.1=0                                  'clear timer3 interrupt flag
  T3CON.0=0                                 'stop timer3 
  SSP2CON2.2=1                              'sent i2c stop
  i2cmode=0                                 'stop
  err=1                                     'error
  if i2cError2<65535 then i2cError2=i2cError2+1  
@ INT_RETURN

'------------------------------------------------------------------------------
'Subroutines
'------------------------------------------------------------------------------ 

Check_can_health:
    if ErrorCount_Can>20 then
        eep_addr.byte1=0                        'page 0
        eep_addr.byte0=95                       'MSB max CAN Errors during period of 10 minutes before reset
        gosub read_eeprom
        e_word.byte1=i2cdata
        eep_addr.byte1=0                        'page 0
        eep_addr.byte0=96                       'LSB max CAN Errors during period of 10 minutes before reset
        gosub read_eeprom
        e_word.byte0=i2cdata
        if e_word==65535 then e_word=150        'Default value is 150 (150 errors during a period of 10 minutes)    
        if ErrorCount_Can>e_word then
            eep_addr.byte1=0                    'page 0
            eep_addr.byte0=97                   'Max number of resets during a period of 24 hours
            gosub read_eeprom
            if i2cdata==255 then i2cdata=1      'If eeprom value is not yet programmed, take default value of 1 (max number of resets per 24 hours)
            if Nr_rs485_power_resets<i2cdata then
                Nr_rs485_power_resets=Nr_rs485_power_resets+1
                eep_addr.byte1=0                'page 0
                eep_addr.byte0=98               'Total number of power resets
                gosub read_eeprom            
                if i2cdata==255 then i2cdata=0
                i2cdata=i2cdata+1
                if i2cdata<=254 then gosub write_eeprom
                BA_type_queue=72                'Power reset 12/24V out
                BA_action_queue=0         
                gosub Increase_queue_pointer
                'hserout2 ["Reset power=",dec Nr_rs485_power_resets,13,10]
                BA_action=72
                gosub send_EV                   'send event                
            endif                                       
        endif
    endif
    ErrorCount_Can=0    
return

dimmer_value_write:
    if dimmer_value_eeprom_write_now==YES then
        if state_machine_eeprom_write==0 then       'Set variables state machine
            dimmer_nr=0
            dimmer_module_nr=0
            state_machine_eeprom_write=state_machine_eeprom_write+1
        elseif state_machine_eeprom_write==1 then   'Select module nr
            if dimmer_module_nr>controller_out then
                state_machine_eeprom_write=3        'Exit
            else 
                if A_ModID0[30+dimmer_module_nr]=="D" or A_ModID0[30+dimmer_module_nr]=="d" then
                    state_machine_eeprom_write=state_machine_eeprom_write+1
                else
                    dimmer_module_nr=dimmer_module_nr+1
                endif
            endif          
        elseif state_machine_eeprom_write==2 then   'read/write eeprom value
            eep_addr.byte1=232                      'page 232
            eep_addr.byte0=(dimmer_module_nr*8)+dimmer_nr
            gosub read_eeprom                               'byte
            if i2cdata!=A_DimmerValue[eep_addr.byte0] then
                i2cdata=A_DimmerValue[eep_addr.byte0]
                gosub write_eeprom
                'hserout2 ["Write dimmer output nr=",dec eep_addr.byte0," value=",dec A_DimmerValue[eep_addr.byte0],13,10]
            endif
            dimmer_nr=dimmer_nr+1
            if dimmer_nr>7 then
                dimmer_nr=0 
                state_machine_eeprom_write=1
                dimmer_module_nr=dimmer_module_nr+1
            endif    
        elseif state_machine_eeprom_write==3 then   'End state machine
            dimmer_value_eeprom_write_now=NO
            state_machine_eeprom_write=0
        else
            dimmer_value_eeprom_write_now=NO
            state_machine_eeprom_write=0      
        endif
    endif
return

'hier_thermo
'read_setpt_eeprom:
'  for a=0 to (MAX_THERMOSTATS-1)                'Read Thermostats
'    eep_addr.byte1=199
'    eep_addr.byte0=a+64
'    gosub read_eeprom
'    if i2cdata<170 and i2cdata>44 then 
'      A_Setpt[a]=i2cdata
'      'hserout2 ["Temp eeprom read(",dec a,")=",dec i2cdata,13,10]  
'    endif      
'  next a    
'return

check_system_health:
  if controller_in>=MAX_INPUT_MODULES or controller_out>=MAX_OUTPUT_MODULES or controller_out_rs>=MAX_RS_MODULES then
    gosub eeprom_activate
    cid=0
    gosub send_AE
  endif
  if timer_queue_pointer>=TIMER_queue then timer_queue_pointer=0
  if queue_end>=queue_max then queue_end=0
return

check_RCON:
  eep_addr.byte0=37                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom                         'Read days counter
  x=i2cdata
  eep_addr.byte0=38                         'address
  gosub read_eeprom
  y=i2cdata   
  if x=255 and y=255 then                   'First time that Uptime is being used so set the right parameters
    UptimeDays=0
    eep_addr.byte0=37
    i2cdata=0
    gosub write_eeprom
    eep_addr.byte0=38
    i2cdata=0
    gosub write_eeprom    
  else
    UptimeDays=(x*256)+y
  endif  
  eep_addr.byte0=36                         'address
  gosub read_eeprom   
  if i2cdata=255 then
    i2cdata=0
  else
    i2cdata=i2cdata+8      
  endif
  t=i2cdata
  gosub write_eeprom
  eep_addr.byte1=255                        'page
  eep_addr.byte0=t                          'address
  i2cdata=Hours
  gosub write_eeprom 
  eep_addr.byte0=t+1                        'address
  i2cdata=Minutes
  gosub write_eeprom 
  eep_addr.byte0=t+2                        'address
  i2cdata=Seconds
  gosub write_eeprom  
  eep_addr.byte0=t+3                        'address
  i2cdata=days
  gosub write_eeprom
  eep_addr.byte0=t+4                        'address
  i2cdata=RconAtStartup
  gosub write_eeprom
  eep_addr.byte0=t+5                        'address
  i2cdata=0
  gosub write_eeprom
  eep_addr.byte0=t+6                        'address
  i2cdata=UptimeDays/256
  gosub write_eeprom
  eep_addr.byte0=t+7                        'address
  i2cdata=UptimeDays//256
  gosub write_eeprom                 
return

Communication_Error:
  if RCSTA1.2=1 then                        'framing error
    x1=RCREG1
  endif
  if RCSTA2.2=1 then                        'framing error
    x1=RCREG2
  endif    
  If RCSTA1.1=1 then                        'overrun error bit
    RCSTA1.4=0                              'disable reception
    RCSTA1.1=0                              'Clear overrun
    RCSTA1.4=1                              'enable again receiving if error occured    
  endif 
  If RCSTA2.1=1 then                        'overrun error bit
    RCSTA2.4=0                              'disable reception
    RCSTA2.1=0                              'Clear overrun
    RCSTA2.4=1                              'enable again receiving if error occured    
  endif    
return

Reset_i2c:
  if ResetI2c=1 and i2cMode=0 then
    ResetI2c=0 
    PIE3.7=0                                'disable interrupt  
    SSP2CON1.5=0                            'disable i2c    
    output DPIN2                            'SDA
    output CPIN2                            'SCL
    high DPIN2
    high CPIN2
    pauseus 10
    for i=0 to 8
      pauseus 10
      low DPIN2
      pauseus 10
      low CPIN2
      pauseus 10
      high DPIN2
      pauseus 10
      high CPIN2    
    next i
    input DPIN2
    input CPIN2 
    SSP2ADD=124                             'i2c at 80kHz
    SSP2STAT=%10000000
    SSP2CON1=%00101000
    PIR3.7=0                                'clear interrupt flag  
    PIE3.7=1                                'enable interrupt
    i2cmode=0  
    i2cInt=0
  endif  
return

'pump_check:
'  if PumpCheckNow=1 and ThermostatEnabled=1 then
'    if PumpCheckCounter<8 then
'      eep_addr.byte1=144+(59*thermostatCooling)                    'page 144 or 203
'      eep_addr.byte0=PumpCheckCounter  
'      gosub read_eeprom
'      'delete
'      'if debugmode=1 then
'      '  hserout2 ["PumpChkCnt=",dec pumpcheckcounter," output=",dec i2cdata," (",dec eep_addr.byte1,"/",dec eep_addr.byte0,") ",bin8 thermostatMode,13,10]
'      'endif
'      a=i2cdata                             'Pump output 
'      if a<240 then                         'Output exists
'        pump=0
'        for j=0 to 31                       'check list of outputs
'          eep_addr.byte1=143+(59*thermostatCooling)                'page 143 or 202
'          eep_addr.byte0=(PumpCheckCounter*32)+j
'          gosub read_eeprom
'          ;delete
'          'if debugmode=1 then
'          '  hserout2 ["Pump Outp chk: ",dec j," ",dec i2cdata," (",dec eep_addr.byte1,"/",dec eep_addr.byte0,") "]
'          'endif  
'          if i2cdata<240 then
'            x=i2cdata//8
'            y=i2cdata/8
'            z=A_Output[y]>>x
'            pump=pump|z.bit0
'            'delete
'            'if debugmode=1 then
'            '  hserout2 [dec x," ",dec y," ",bin8 A_Output[y]," ",dec z," ",dec z.bit0," ",dec pump,13,10]
'            'endif    
'          else
'            j=31                            'exit 
'          endif      
'        next j
'        x=a//8
'        y=a/8
'        z=%00000001
'        z=z<<x      
'        if pump=1 then                      'output on 
'          if A_PumpOn[PumpCheckCounter]=0 and PumpCheckCounter<MAX_PUMP_GROUPS then
'            A_PumpOn[PumpCheckCounter]=1                  'Pump output is switched on or will be switched on with a delay
'            if pump_delay>0 and pump_delay<249 then     'output delay is active
'              A_Action[4]=161
'              A_Action[5]=a
'              A_Action[3]=pump_delay
'              A_Action[6]=240
'              gosub add_timer_queue2
'              'delete
'              'if debugmode=1 then
'              '  hserout2 ["Pump on ",dec a," delay ",dec pump_delay,13,10]
'              'endif 
'            else                                        'no output delay
'              'A_QueueType[queue_end]=161             'output on
'              'A_QueueAction[queue_end]=a
'              BA_type_queue=161
'              BA_action_queue=a              
'              gosub Increase_queue_pointer
'              'delete
'              'if debugmode=1 then
'              '  hserout2 ["Pump on ",dec a,13,10]
'              'endif 
'            endif
'            OdCode=0                                    'output debug code
'            OdOutputNr=a
'            gosub Output_debug
'          else
'            gosub pump_rescue
'          endif       
'        else
'          'delete
'          'if debugmode=1 then
'          '  hserout2 ["Pump off ",dec a,13,10]
'          'endif 
'          if PumpCheckCounter<MAX_PUMP_GROUPS then  'output off
'            A_RescueCounter[PumpCheckCounter]=0
'            A_PumpOn[PumpCheckCounter]=0                    'Pump output is switched off
'          endif  
'          'A_QueueType[queue_end]=160                 'output off
'          'A_QueueAction[queue_end]=a
'          BA_type_queue=160
'          BA_action_queue=a           
'          gosub Increase_queue_pointer
'          OdCode=1                                      'output debug code
'          OdOutputNr=a
'          A_Action[4]=161
'          A_Action[5]=a
'          gosub Remove_timer_queue
'          gosub Output_debug             
'        endif
'      endif
'      PumpCheckCounter=PumpCheckCounter+1
'    else
'      PumpCheckCounter=0
'      PumpCheckNow=0                                    'Check is done
'    endif   
'  endif
'return

'pump_rescue:
'  u=A_Output[y]>>x
'  'delete
'  'if debugmode=1 then
'  '  hserout2 ["--Rescue ",dec a," ",dec y," ",dec x," ",bin8 A_Output[y]," ",dec u.bit0," RC=",dec A_RescueCounter[PumpCheckCounter]," ",dec pump_delay," ",dec PumpCheckCounter,13,10]
'  'endif   
'  if u.bit0=0 then        'Pump output is not ON
'    if PumpCheckCounter<MAX_PUMP_GROUPS then A_RescueCounter[PumpCheckCounter]=A_RescueCounter[PumpCheckCounter]+1
'    'delete
'    'if debugmode=1 then
'    '  hserout2 [" -- RC=",dec A_RescueCounter[PumpCheckCounter]," ",dec PumpCheckCounter,13,10]
'    'endif     
'    if pump_delay=0 then  'pump_delay=0 so output should be on
'      'A_QueueType[queue_end]=161             'output on
'      'A_QueueAction[queue_end]=a
'      BA_type_queue=161
'      BA_action_queue=a         
'      gosub Increase_queue_pointer
'      'if debugmode=1 then
'      '  hserout2 [" - Rescue Pump on ",dec a,13,10]
'      'endif     
'    else
'      if A_RescueCounter[PumpCheckCounter]>5 then
'        'A_QueueType[queue_end]=161             'output on
'        'A_QueueAction[queue_end]=a
'        BA_type_queue=161
'        BA_action_queue=a           
'        gosub Increase_queue_pointer
'        'if debugmode=1 then
'        '  hserout2 [" - Rescue Time Pump on ",dec a,13,10]
'        'endif              
'      endif
'    endif
'  endif  
'return

'Write_ThermostatMode:
'  i2cdata=ThermostatMode
'  eep_addr.byte0=14                         'address
'  eep_addr.byte1=0                          'page
'  gosub write_eeprom
'  gosub Thermostat_multi_tenant  
'return

'Thermostat_Multi_tenant:
'  If thermostatMode.bit6=1 then               'Thermostat Multi-tenancy is enabled
'    for a=0 to (MAX_THERMOSTATS-1)
'      eep_addr.byte1=199                      'page
'      eep_addr.byte0=a+32                     'Read multi-tenant configuration byte
'      gosub read_eeprom
'      if i2cdata.bit3=1 then                  'Auto mode  
'        if a<MAX_THERMOSTATS then A_ThermostatAuto[a]=1
'        q=a
'        gosub thermostat_timing_sub           'Load the correct Setpt for automatic mode
'      else                                    'Manual mode
'        if a<MAX_THERMOSTATS then A_ThermostatAuto[a]=0
'        b=(4*i2cdata.bit2)+(2*i2cdata.bit1)+i2cdata.bit0
'        gosub read_setpt                     'Load the correct Setpt for manual mode
'      endif   
'    next a
'  else                                       'Multi-tenancy mode is not enabled
'    for a=0 to (MAX_THERMOSTATS-1)
'      A_ThermostatAuto[a]=ThermostatMode.bit3
'    next a 
'  endif
'return


'PID_read:
'  eep_addr.byte0=pid*4                      'address
'  eep_addr.byte1=141+(59*thermostatCooling)                        'page 141 or 200
'  gosub read_eeprom 
'  Kp=i2cdata 
'  eep_addr.byte0=(pid*4)+1                  'address
'  gosub read_eeprom 
'  Ki=i2cdata 
'  eep_addr.byte0=(pid*4)+2                  'address
'  gosub read_eeprom 
'  Kd=i2cdata   
'  eep_addr.byte0=(pid*4)+3                  'address
'  gosub read_eeprom 
'  IntThresh=i2cdata
'return

'For more information about PID, see http://wiki.openmotics.com/index.php/PID
'PID_calc:
'  if PidCalcNow=1 then
'    if PidCalcCounter<MAX_THERMOSTATS then 
'      if ThermostatOn=1 and ThermostatEnabled=1 then         'Thermostat function is ON  
'        if A_Thermostat[PidCalcCounter]<241 and A_ThermostatSensor[pidCalcCounter]<MAX_SENSORS then  'Thermostat is linked to output and Temperature sensor
'          low led_red
'          drive=0
'          pid=PidCalcCounter
'          gosub PID_read
'          if PidMode=1 then
'            gosub read_CH
'            hserout2 [c,": ",dec days," ",dec2 hours,":",dec2 minutes," PID:",dec2 pidCalcCounter," "]
'          endif      
'          x=A_ThermostatSensor[pidCalcCounter]
'          actual=A_Temperature[x]
'          if actual>40 and actual<175 then  'sensor is giving valid temperatures
'          '--------P calculation---------------------------------        
'            if ThermostatCooling=0 then   'Heating
'              ErrorPid=A_Setpt[pidCalcCounter]-Actual
'            else                            'Cooling
'              ErrorPid=Actual-A_Setpt[pidCalcCounter]
'            endif  
'            Psign=ErrorPid.15               'remember sign
'            Xword=(abs ErrorPid)*Kp
'            if Psign=1 then                 'error is negative
'              drive=drive-Xword
'              gosub PrintModeMin        
'            else
'              drive=drive+Xword
'              gosub PrintModePlus
'            endif 
'          '--------I calculation---------------------------------
'            if (abs ErrorPid) < IntThresh then
'              if pidcalccounter<MAX_THERMOSTATS then A_Integral[pidCalcCounter]=A_Integral[pidCalcCounter]+ErrorPid
'            else
'              if pidcalccounter<MAX_THERMOSTATS then A_Integral[pidCalcCounter]=0  
'            endif
'            Xbyte=A_Integral[pidCalcCounter]
'            Isign=Xbyte.7
'            If Xbyte>63 and xbyte<235 then
'              if Isign=1 then
'                if pidcalccounter<MAX_THERMOSTATS then A_Integral[pidCalcCounter]=235'-20
'              else
'                if pidcalccounter<MAX_THERMOSTATS then A_Integral[pidCalcCounter]=63 '63
'              endif
'              Xbyte=A_Integral[pidCalcCounter]        
'            endif      
'            Xword=(abs (A_Integral[pidCalcCounter]))*Ki
'            if Isign=1 then
'              drive=drive-Xword
'              gosub PrintModeMin
'            else
'              drive=drive+Xword
'              gosub PrintModePlus
'            endif
'           '--------D calculation---------------------------------
'            if ThermostatCooling=0 then   'Heating
'              Dr=A_Last[pidCalcCounter]-Actual
'            else                            'Cooling
'              Dr=Actual-A_Last[pidCalcCounter]
'            endif
'            Dsign=Dr.7                      'remember sign
'            Xword=(abs Dr)*Kd
'            if Dsign=1 then                 'negative
'              drive=drive-Xword
'              gosub PrintModeMin
'            else
'              drive=drive+Xword
'              gosub PrintModePlus
'            endif
'            if pidcalccounter<MAX_THERMOSTATS then A_Last[pidCalcCounter]=actual  
'           '--------Correction values-----------------------------
'            if drive.15 then drive=0
'            drive=drive/2  
'            if PidMode=1 then
'              hserout2 [dec drive]
'            endif
'            if drive>126 then drive=126
'            if drive>63 then                '2 outputs must be driven
'              DriveOutput=63
'              a=A_Thermostat[pidCalcCounter]
'              gosub SetThermostatOutput
'              DriveOutput=Drive-63
'              a=A_Thermostat2[pidCalcCounter]
'              gosub SetThermostatOutput        
'            else
'              DriveOutput=drive.byte0
'              a=A_Thermostat[pidCalcCounter]
'              gosub SetThermostatOutput
'              DriveOutput=0
'              a=A_Thermostat2[pidCalcCounter]
'              gosub SetThermostatOutput         
'            endif
'          else                             'Switch off Outputs 
'            DriveOutput=0
'            a=A_Thermostat[pidCalcCounter]
'            gosub SetThermostatOutput
'            DriveOutput=0
'            a=A_Thermostat2[pidCalcCounter]
'            gosub SetThermostatOutput             
'          endif
'          if PidMode=1 then
'            gosub display_LF_CR
'          endif                  
'        else                                'Time Based Switching
'          q=pidCalcCounter
'          gosub Set_TBS_Output
'        endif
'      elseif ThermostatEnabled=1 then       'Thermostats are OFF        
'        if A_ThermostatSensor[pidCalcCounter]<MAX_SENSORS then   'Don't switch off for TBS
'          a=A_Thermostat[pidCalcCounter]
'          DriveOutput=0
'          gosub SetThermostatOutput
'          a=A_Thermostat2[pidCalcCounter]
'          DriveOutput=0
'          gosub SetThermostatOutput
'        else                                          'Time Based Switching
'          q=pidCalcCounter
'          gosub Set_TBS_Output        
'        endif           
'      endif
'      PidCalcCounter=PidCalcCounter+1
'      PidCalcNow=0
'    else
'      PidCalcCheck=0
'      PidCalcNow=0
'      PidCalcCounter=0
'    endif 
'  endif     
'return

'SetThermostatOutput:
'  'delete: In PidCalcCounter zit de Thermostat nr
'  if a<MAX_OUTPUTS then
'    A_TimerCd[a]=0
'    A_DimmerValue[a]=DriveOutput
'    A_OutUpdate[a]=1
'    x=a//8
'    y=a/8
'    z=%00000001
'    z=z<<x
'    if DriveOutput>0 then                   'switch on output
'      if y<MAX_OUTPUT_MODULES then A_Output[y]=A_Output[y]|z
'      OdCode=2
'      OdOutputNr=a      
'      gosub Output_debug 
'      tp=q
'      q=a
'      gosub Dimmer_Group_follow
'      q=tp           
'    else                                    'switch off output
'      z=~z
'      if y<MAX_OUTPUT_MODULES then A_Output[y]=A_Output[y]&z
'      OdCode=3
'      OdOutputNr=a
'      gosub Output_debug
'      tp=q
'      q=a
'      gosub Dimmer_Group_follow
'      q=tp                  
'    endif
'    write_yes=1
'    if y<MAX_OUTPUT_MODULES then A_WriteYesMod[y]=OutputNrWrites
'  elseif a=240 then                         'RTD-10 A_Temperature setting
'    gosub RTD10
'  endif    
'return

'RTD10:                                      'PidCalcCounter is used for Thermostat Nr
'  if A_Airco[PidCalcCounter]=1 then         'Airco must be ON
'    u=1                                     'Output ON
'    gosub Set_OnOff_output
'    v=214                                   'Ventilation speed
'    gosub Set_MVP                           'Mode, ventilation speed, poke angle
'    v=215                                   'Mode
'    gosub Set_MVP                           'Mode, ventilation speed, poke angle 
'    v=216                                   'Poke Angle
'    gosub Set_MVP                           'Mode, ventilation speed, poke angle
'    gosub Set_Setpoint                      'Calculate and set Setpoint
'  else                                      'Airco must be OFF
'    u=0                                     'Output OFF
'    gosub Set_OnOff_output                  
'  endif
'return

'Set_Setpoint:
'  eep_addr.byte0=PidCalcCounter+200           'address
'  eep_addr.byte1=213+(4*thermostatCooling)    'page 213 or 217
'  gosub read_eeprom                           'Output to be used
'  if i2cdata<240 then                         'valid output
'    A_DigitTotal[0]=i2cdata                     'output
'    if A_Setpt[pidCalcCounter]<96 then          'below 16 degree
'      x=96
'    elseif A_Setpt[pidCalcCounter]>112 then     'Above 24 degree
'      x=112
'    else                                      'in range
'      x=A_Setpt[pidCalcCounter]
'    endif      
'    x=x-96
'    eep_addr.byte0=24+x                       'address
'    eep_addr.byte1=213+(4*thermostatCooling)'page 213 or 217
'    gosub read_eeprom                         'Output to be used 
'    digitcount=2
'    A_DigitTotal[1]=i2cdata
'    gosub output_on
'  endif  
'return

'Set_MVP:                                    'Set Mode, ventilation speed, poke angle
'  eep_addr.byte0=PidCalcCounter             'address
'  eep_addr.byte1=v+(4*thermostatCooling)  'page v or v+4
'  gosub read_eeprom
'  if i2cdata<240 then
'    A_DigitTotal[0]=i2cdata                   'output    
'    eep_addr.byte0=PidCalcCounter+64        'address
'    eep_addr.byte1=v+(4*thermostatCooling) 'page 215 or 219, 216 or 220, ...
'    gosub read_eeprom    
'    if i2cdata>0 and i2cdata<63 then        'output ON
'      digitcount=2
'      A_DigitTotal[1]=i2cdata
'      gosub output_on         
'    else                                    'output OFF
'      digitcount=1
'      gosub output_off          
'    endif
'  endif
'return

'Set_OnOff_output:
'  eep_addr.byte0=PidCalcCounter+100         'address
'  eep_addr.byte1=215+(4*thermostatCooling)'page 215 or 219
'  gosub read_eeprom
'  if i2cdata<240 then
'    A_DigitTotal[0]=i2cdata
'    if u=1 then         'Switch output ON
'      digitcount=2
'      A_DigitTotal[1]=63
'      gosub output_on     
'    else                'Switch output OFF
'      digitcount=1
'      gosub output_off           
'    endif
'  endif       
'Return

'PrintModePlus:
'  if PidMode=1 then
'    hserout2 ["+",dec3 Xword," "]    
'  endif
'return

'PrintModeMin:
'  if PidMode=1 then 
'    hserout2 ["-",dec3 Xword," "]    
'  endif
'return

'WE:
'  eep_addr.byte1 = 2
'  gosub write_eeprom
'return

reset_error:
  for ic=0 to MAX_ERRORS-1
    A_ErrorBit[ic]=0                          'inputs nor outputs have an error
    A_ErrorCount[ic]=0
  next ic
  ErrorTmp=60
return
  
'------------------------------------------------------------------------------
' RS485
' For RS485 communication protocol, see http://wiki.openmotics.com/index.php/Master_RS485_Cummunication_Protocol
'------------------------------------------------------------------------------

Rs485_interprete:
    if interpreteSer1=1 then 
        RS485busy=YES
        InterpreteSer1=0
        gosub check_FV_instruction      'check if "FV" is received
        'delete
        'hserout2 ["Instr type:",RS485Message," ",A_RS485string[0],".",dec A_RS485string[1],".",dec A_RS485string[2],".",dec A_RS485string[3]," ",A_RS485string[4],13,10]
        if RS485Message="I" then                'Response Input (input, temp etc) modules
            i=pollNr
            if A_RS485string[0]="I" then            'Input
                gosub Communicate_input
            else                                  'Temp & oled
                if A_RS485string[0]="T" then          'A_Temperature (ADC value)
                    gosub check_response_temp_module  'Input module
                elseif A_RS485string[0]="C" then      'CAN Control
                    gosub Communicate_CAN
                endif  
            endif
            pollTimeInput=WaitTimeInput
        elseif RS485Message="O" then                'Response Output modules
            if A_RS485string[0]="D" or A_RS485string[0]="R" or A_RS485string[0]="O" then
                i=pollNrOut
                if A_RS485string[4]="K" and A_RS485string[0]=A_ModID0[29+i] and A_RS485string[1]=A_ModID1[29+i] and A_RS485string[2]=A_ModID2[29+i] and A_RS485string[3]=A_ModID3[29+i] then   'Received OK from output Module
                    i2caddr = 8+i
                    if A_RS485string[0]="R" then 
                        if (i-1)<MAX_OUTPUT_MODULES then A_Output[i-1]=A_RS485string[5]         'Retricted output module (curtains) will refuse to switch on output0 and 1 for example so the output module must give back the new state of the outputs
                    endif
                    i2cdata = A_Output[i-1]                'put A_Output(i) in clock ram
                    gosub write_i2c_2
                    pollTimeOutput=WaitTimeOutput
                    ic=pollNrOut
                    gosub sent_output
                    i=pollNrOut
                    gosub timer_value                 'set all timer values correctly  
                else
                    i=pollNrOut
                    A_ErrorID[0]= A_ModID0[29+i]        'Device is not responding with OK or wrong module is responding
                    A_ErrorID[1]= A_ModID1[29+i]
                    A_ErrorID[2]= A_ModID2[29+i]
                    A_ErrorID[3]= A_ModID3[29+i]
                    ErrorTmp=29+i
                    error_code = 9
                    Gosub Add_ErrorCount
                    gosub send_error   
                endif        
            endif           
        elseif RS485Message="R" then                'Roller/shutter in Large Installation Mode
            if A_RS485string[0]="R" then
                i=pollNrOutRS
                gosub Get_ID  
                if A_RS485string[4]="K" and A_RS485string[0]=A_Digit[0] and A_RS485string[1]=A_Digit[1] and A_RS485string[2]=A_Digit[2] and A_RS485string[3]=A_Digit[3] then   'Received OK from output Module
                    if (i-1)<MAX_RS_MODULES then A_OutputRS[i-1]=A_RS485string[5]         'Retricted output module (curtains) will refuse to switch on output0 and 1 for example so the output module must give back the new state of the outputs
                    pollTimeOutput=WaitTimeOutput
                    ic=pollNrOutRS
                    if mode_com=1 and AutResponseSO=1 then  'only in API mode and when Auto Response Output List bit is set
                        cid=0
                        gosub SO_linux2                    'Send SO instruction to Master controller
                    endif 
                    if pollNrOutRS<MAX_RS_MODULES+1 then A_WriteYesModRS[pollNrOutRS-1]=0 
                else
                    i=pollNrOutRS
                    A_ErrorID[0]= A_ModID0[29+i]        'Device is not responding with OK or wrong module is responding
                    A_ErrorID[1]= A_ModID1[29+i]
                    A_ErrorID[2]= A_ModID2[29+i]
                    A_ErrorID[3]= A_ModID3[29+i]
                    error_code = 28
                    gosub send_error   
                endif        
            endif              
        elseif RS485Message="F" then                'Response Firmware instruction
            gosub Send_F_instruction
            '  hserout2 ["Firmware instruction sent",13,10]   
        elseif RS485Message="t" then                'Response 16 ports Temp module (old version) 
            if A_RS485string[0]="T" and A_RS485string[1]="0" and A_RS485string[2]="0" and A_RS485string[3]="0" then
                for ic=0 to 15
                    a=ic+14
                    gosub Set_Temperature
                    gosub Temperature_Offset
                next ic  
            endif      
        elseif RS485Message="B" then                'Broadcast message received
            if mode="I" then
                gosub Check_correct_can_module
                gosub Communicate_CAN
                gosub rs485_receive_init
            endif  
        endif
        pointerser1=0
        RS485busy=NO
    endif  
return

'hier debug can
Check_correct_can_module:
    for t=1 to controller_in
        if A_RS485string[1]==A_ModID1[t-1] and A_RS485string[2]==A_ModID2[t-1] and A_RS485string[3]==A_ModID3[t-1] then
            i=t
            'hserout2 ["Found ",dec i-1,13,10]
            t=controller_in
        endif
    next t
return

Send_F_instruction:
  A_e[0]=A_RS485string[4]
  A_e[1]=A_RS485string[5]
  A_e[2]=cid
  A_e[3]=A_RS485string[0]
  A_e[4]=A_RS485string[1]
  A_e[5]=A_RS485string[2]
  A_e[6]=A_RS485string[3]
  A_e[7]=A_RS485string[6]
  A_e[8]=A_RS485string[7]
  A_e[9]=A_RS485string[8]
  A_e[10]=A_RS485string[9]
  A_e[11]=A_RS485string[10]
  A_e[12]=A_RS485string[11]
  A_e[13]=A_RS485string[12]
  A_e[14]=A_RS485string[13]
  A_e[15]=A_RS485string[14]                        
  gosub send_API
return


Sent_output:
  if mode_com=1 and A_ModID0[29+ic]="r" then
    cid=0
    gosub SO_linux2                     'Send RO instruction to Master controller
  endif
  if mode_com=1 and AutResponse=1 and A_ModID0[29+ic]<>"r" then    'only in API mode and when Auto Response Output "RO" bit is set
    cid=0
    gosub RO_linux2                       'Send RO instruction to Master controller   
  endif            
  if mode_com=1 and AutResponseOL=1 then  'only in API mode and when Auto Response Output "OL" List bit is set
    cid=0
    gosub send_OL
  endif
  if A_WriteYesMod[ic-1]>0 and ic<MAX_OUTPUT_MODULES+1 then A_WriteYesMod[ic-1]=A_WriteYesMod[ic-1]-1  
return

RS485_Fault:
  if TimeOutSer1=1 then                     'Time A_Output error in module response
    TimeOutSer1=0
    RS485busy=NO
    If CatchAll=1 then                      'Please also interprete not fully received messages
      if pointerser1>CatchAllByte then
        Interpreteser1=1                    'Check if the message can be interpreted undough not enough characters came in
      else 
        gosub RS485_Fault_Sub
      endif
    else
      gosub RS485_Fault_Sub
    endif                    
  endif 
return

RS485_Fault_Sub:
  pointerser1=0
  T0CON.7=0                                 'timer 0 disabled
  if Rs485message="I" then                  'Last message was input
    i=pollNr
    A_ErrorID[0]= A_ModID0[i-1]               'Input device is not responding
    A_ErrorID[1]= A_ModID1[i-1]
    A_ErrorID[2]= A_ModID2[i-1]
    A_ErrorID[3]= A_ModID3[i-1]
    ErrorTmp=i-1
    error_code = 7
    cid=0
    Gosub Add_ErrorCount
    gosub send_error           
  endif
  if Rs485message="O" then                  'Last message was an output
    i=pollNrOut
    A_ErrorID[0]= A_ModID0[29+i]              'Device is not responding
    A_ErrorID[1]= A_ModID1[29+i]
    A_ErrorID[2]= A_ModID2[29+i]
    A_ErrorID[3]= A_ModID3[29+i]
    ErrorTmp=29+i
    error_code = 8
    Gosub Add_ErrorCount
    gosub send_error              
  endif    
  'if Rs485message="F" then                  'Last message was a Firmware message
  '            
  'endif
Return

prepare_rs485_receive:
  'pauseus 100
  if Rs485message="F" then
    T0CON = %00000111
  else
    T0CON = %00000100
  endif   
  low RS485_DIR                             'Receive mode
  RS485busy=YES 
  RCSTA1.4=1                                'enable receiving serial 1
  TMR0L=0                                   'reset value
  TMR0H=0
  T0CON.7=1                                 'timer 0 enabled
  TimeOutSer1=0
  rs485_timeout=rs485_timeout_max           'RS485 timeout (rs485_timeout*6,5ms)
Return

Read_eeprom_data:
  if syncEnable=1 then
    if OledEepromBit=0 then
      OledEeprom.byte0 = OledEeprom.byte0 + 1
    else
      OledEepromBit=0
      OledEeprom.byte0 = 0
      if EepPage0=1 and OledEeprom.byte1=0 then
        EepPage0=0       
        OledEeprom.byte1 = 33       'First do the output pages so the CAN control leds works almost immeadiatly          
      else
        OledEeprom.byte1 = OledEeprom.byte1 + 1
      endif
    endif
    'endif
    eep_addr.byte1 = OledEeprom.byte1 'page
    eep_addr.byte0 = OledEeprom.byte0 'byte
    OledDataAddr.byte1 = OledEeprom.byte1 'page
    OledDataAddr.byte0 = OledEeprom.byte0 'byte     
    Gosub read_eeprom
    oleddata=i2cdata
    OledDataOk=1                      'Data is OK
    if mode_com=0 and syncdebug=1 then
      hserout2 ["Sync P",dec3 OledDataAddr.byte1,"/",dec3 OledDataAddr.byte0,"=",dec oleddata,13,10]
    endif
    if OledEeprom.byte0 = 255 then 
      OledEepromBit=1
    endif
  else
    OledDataOk=0
  endif      
return  

'For more information regarding the implemented RS485 protocol see http://wiki.openmotics.com/index.php/Master_RS485_Cummunication_Protocol
RS485_poll:
  'if BootLoaderMode=0 then
    if PollCheck=0 then
      if controller_in=0 then PollCheck=1
      if RS485busy=NO and controller_in>0 then  'Bus is not busy
        if pollTimeInput=0 then             'No need to wait for next input module instruction?
          pollTimeInput=WaitTimeInput
          pollNr=pollNr+1
          if pollNr>controller_in then 
            pollNr=1
            can_control_number=0
            TemperatureCount=0              'If Temperature module are spread between input modules
            CheckTemp=1                     'make sure the Temperature number is from 0 to 31
            gosub Read_eeprom_data          'Read new byte from eeprom and sent it to the input modules (CAN) and Oled module
            PollCheck=1                     'Check IF No Outputs needs communication
          endif    
          RS485Message="I"
          i=pollNr
          if A_ErrorBit[i-1]=0 then             'Number of module errors are not yet achieved
            if A_ModID0[i-1]="I" then          'Input Module
              Gosub sent_input    
            elseif A_ModID0[i-1]="T" then      'Temperature module, measure ADC
              z=2
              gosub calc_indicate
              if CheckTemp=1 then
                TempCom=TempCom+1
                CheckTemp=0                                              
              endif
              'delete
              'if y<>255 then hserout2 ["Sent message ",A_ModID0[i-1],dec i-1," y=",dec y,13,10] 
              if TempCom>2 then TempCom=0
              if TempCom=0 then u="A"
              If TempCom=1 then u="T"
              if TempCom=2 then u="H"
              A_e[0]=A_ModID0[i-1]
              A_e[1]=A_ModID1[i-1]
              A_e[2]=A_ModID2[i-1]
              A_e[3]=A_ModID3[i-1]
              A_e[4]=u
              A_e[5]=y
              A_e[6]=0
              A_e[7]=0
              A_e[8]=0
              gosub send_rs485_short
              gosub prepare_rs485_receive
            elseif A_ModID0[i-1]="C" then      'CAN Module 
              can_control_number=can_control_number+1
              gosub sent_input                                  
            endif
          endif  
        endif 
      endif 
    endif
  'endif      
return

sent_input:
  z=1                             'Calculate Indicate for Input   
  gosub Calc_indicate
  A_e[0]=A_ModID0[i-1]
  A_e[1]=A_ModID1[i-1]
  A_e[2]=A_ModID2[i-1]
  A_e[3]=A_ModID3[i-1]
  A_e[4]="I"
  A_e[5]=y
  A_e[6]="F"
  A_e[7]=InputFilter
  if OledDataOk=1 then
    A_e[8]="E"
    A_e[9]=OledDataAddr.byte1           'page
    A_e[10]=OledDataAddr.byte0          'byte
    A_e[11]=OledData
  endif
  if A_ModID0[i-1]="I" then
    A_e[12]="O"
    A_e[13]=OutputModuleNr
    A_e[14]=A_Output[OutputModuleNr]
    OutputModuleNr=OutputModuleNr+1
    if OutputModuleNr>controller_out then OutputModuleNr=0
  endif    
  gosub send_rs485_long
  gosub prepare_rs485_receive
return                       

RS485_output:
  'if BootLoaderMode=0 then
  if PollCheck=1 then
    if controller_out=0 then PollCheck=2
    if write_yes>0 and controller_out>0 then  
      if RS485busy=NO then   'Bus is not busy 
        if pollTimeOutput=0 then            'No need to wait for next output module instruction?
          pollNrOut=pollNrOut+1
          if pollNrOut>controller_out then 
            pollNrOut=1
            PollCheck=2                     'First check outputRS modules
          endif  
          i=pollNrOut       
          if A_ModID0[29+i]="O" or A_ModID0[29+i]="D" or A_ModID0[29+i]="R" then          
            if A_ErrorBit[29+i]=0 then             'Number of module errors are not yet achieved    
              if A_WriteYesMod[i-1]>0 then     
                RS485Message="O"
                pollTimeOutput=WaitTimeOutput      
                z=0                             'Calculate Indicate for Output
                gosub Calc_indicate
                CRC2=A_Output[i-1]+y+A_DimmerValue[(i-1)*8]+A_DimmerValue[((i-1)*8)+1]+A_DimmerValue[((i-1)*8)+2]+A_DimmerValue[((i-1)*8)+3]
                CRC2=CRC2+A_DimmerValue[((i-1)*8)+4]+A_DimmerValue[((i-1)*8)+5]+A_DimmerValue[((i-1)*8)+6]+A_DimmerValue[((i-1)*8)+7]
                A_e[0]=A_ModID0[29+i]
                A_e[1]=A_ModID1[29+i]
                A_e[2]=A_ModID2[29+i]
                A_e[3]=A_ModID3[29+i]
                A_e[4]=A_Output[i-1]
                A_e[5]=y
                A_e[6]=A_DimmerValue[(i-1)*8]
                A_e[7]=A_DimmerValue[((i-1)*8)+1]
                A_e[8]=A_DimmerValue[((i-1)*8)+2]
                A_e[9]=A_DimmerValue[((i-1)*8)+3]
                A_e[10]=A_DimmerValue[((i-1)*8)+4]
                A_e[11]=A_DimmerValue[((i-1)*8)+5]
                A_e[12]=A_DimmerValue[((i-1)*8)+6]
                A_e[13]=A_DimmerValue[((i-1)*8)+7]
                A_e[14]="C"
                A_e[15]=CRC2.byte1
                A_e[16]=CRC2.byte0
                gosub send_rs485_long
                gosub prepare_rs485_receive
                'gosub check_write_yes
                'hserout2 [" ",dec i]
              endif  
            endif
          else
            if A_WriteYesMod[i-1]>0 then        
              gosub send_virtual_output
            endif  
          endif   
        endif
        'hserout2 [" ",dec i,13,10]
        gosub check_write_yes   
      endif
    else           'No Outputs to Check
      PollCheck=2  'Check OutputRS
    endif
  endif    
return

check_write_yes:
  i_bit=0
  for t=1 to controller_out             'check if any output still needs to be addressed
    if A_WriteYesMod[t-1]>0 then i_bit=1
  next t
  write_yes=i_bit
  if write_yes=0 then PollCheck=2  
return


send_virtual_output:
  if A_ModID0[29+i]="o" or A_ModID0[29+i]="d" or A_ModID0[29+i]="r" then
    ic=i
    gosub sent_output
    i2caddr = 8+i
    i2cdata = A_Output[i-1]                'put A_Output(i) in clock ram
    gosub write_i2c_2
    'gosub check_write_yes
    RS485Message="O"
    pollTimeOutput=WaitTimeOutput      
    CRC2=A_Output[i-1]+y+A_DimmerValue[(i-1)*8]+A_DimmerValue[((i-1)*8)+1]+A_DimmerValue[((i-1)*8)+2]+A_DimmerValue[((i-1)*8)+3]
    CRC2=CRC2+A_DimmerValue[((i-1)*8)+4]+A_DimmerValue[((i-1)*8)+5]+A_DimmerValue[((i-1)*8)+6]+A_DimmerValue[((i-1)*8)+7]
    A_e[0]=A_ModID0[29+i]
    A_e[1]=A_ModID1[29+i]
    A_e[2]=A_ModID2[29+i]
    A_e[3]=A_ModID3[29+i]
    A_e[4]=A_Output[i-1]
    A_e[5]=y
    A_e[6]=A_DimmerValue[(i-1)*8]
    A_e[7]=A_DimmerValue[((i-1)*8)+1]
    A_e[8]=A_DimmerValue[((i-1)*8)+2]
    A_e[9]=A_DimmerValue[((i-1)*8)+3]
    A_e[10]=A_DimmerValue[((i-1)*8)+4]
    A_e[11]=A_DimmerValue[((i-1)*8)+5]
    A_e[12]=A_DimmerValue[((i-1)*8)+6]
    A_e[13]=A_DimmerValue[((i-1)*8)+7]
    A_e[14]="C"
    A_e[15]=CRC2.byte1
    A_e[16]=CRC2.byte0
    gosub send_rs485_long
    'gosub prepare_rs485_receive   -> No feedback expected, this message is only to be sent A_Output for the CAN Control modules
    'gosub check_write_yes
    gosub check_group
    pause 5
  endif
return

Check_group:
  for m=0 to 7
    n=((i-1)*8)+m
    if A_OutUpdate[n]=1 then
      if n<MAX_OUTPUTS then A_OutUpdate[n]=0
      eep_addr.byte1=112                    'page 112
      eep_addr.byte0=n                      'Output Nr
      gosub read_eeprom
      'hserout2 ["Update Output ",dec n,"->",dec i2cdata," dim_value=",dec A_DimmerValue[n],13,10]
      if i2cdata<32 then                    'Valid group
        broad1="G"                          'Group message broadcast
        broad2=i2cdata                      'Group Number
        GroupNr=i2cdata
        x=A_Output[i-1]>>m
        if x.bit0=1 then                    'Output is ON
          broadData=4*A_DimmerValue[n]       'Dim Value
          GroupDimValue=4*A_DimmerValue[n]
          GroupOn=1
          'hserout2 [" Output ON ",dec A_DimmerValue[n],13,10]
        else                                'Output if OFF
          broadData=0                       'Dim Value
          GroupDimValue=0
          GroupOn=0
          'hserout2 [" Output OFF",13,10]
        endif        
        broadId="C"                         'CAN modules only
        gosub Add_Broad_queue 
        gosub Set_Dali_outputs
      endif  
    endif
  next m    
return

Get_ID:                           'i
  for x=0 to 3
    eep_addr.byte1 = 32+i         'page
    eep_addr.byte0 = 173+x
    gosub read_eeprom
    A_Digit[x]=i2cdata
  next x
Return

RS485_outputRS:
  'if BootLoaderMode=0 then
  if PollCheck=2 then
    if controller_out_RS=0 then PollCheck=0
    if write_yes_RS=1 then
      if RS485busy=NO then   'Bus is not busy 
        if pollTimeOutput=0 then            'No need to wait for next output module instruction?
          pollNrOutRS=pollNrOutRS+1
          if pollNrOutRS>controller_out_RS then pollNrOutRS=1
          i=pollNrOutRS
          gosub Get_ID      'Get the ID of the Roller/shutter in Large installation mode
          if A_Digit[0]="R" then    
            if A_WriteYesModRS[i-1]=1 then      
              RS485Message="R"
              pollTimeOutput=WaitTimeOutput      
              z=0                             'Calculate Indicate for Output
              gosub Calc_indicate
              CRC2=A_OutputRS[i-1]+y                        
              A_e[0]=A_Digit[0]
              A_e[1]=A_Digit[1]
              A_e[2]=A_Digit[2]
              A_e[3]=A_Digit[3]
              A_e[4]=A_OutputRS[i-1]
              A_e[5]=y
              A_e[6]=0
              A_e[7]=0
              A_e[8]=0
              A_e[9]=0
              A_e[10]=0
              A_e[11]=0
              A_e[12]=0
              A_e[13]=0
              A_e[14]="C"
              A_e[15]=CRC2.byte1
              A_e[16]=CRC2.byte0
              gosub send_rs485_long
              gosub prepare_rs485_receive
              if i<MAX_RS_MODULES+1 then A_WriteYesModRS[i-1]=0      'Disable   
            endif
          else
            ic=i
            cid=0
            gosub SO_Linux2
            if i<MAX_RS_MODULES+1 then A_WriteYesModRS[i-1]=0
          endif  
        endif 
      endif
      i_bit=0
      for i=1 to controller_out_RS             'check if any output still needs to be addressed
        i_bit=i_bit|A_WriteYesModRS[i-1]
      next i
      write_yes_RS=i_bit  
      if write_yes_RS=0 then PollCheck=0
    else                                       'No Outputs to check
      PollCheck=0                              'Check inputs
    endif
  endif  
return

'Communicate_Oled:
'  if A_RS485string[0]=A_ModID0[i-1] and A_RS485string[1]=A_ModID1[i-1] and A_RS485string[2]=A_ModID2[i-1] and A_RS485string[3]=A_ModID3[i-1] then
'    if A_RS485string[6]<>255 and Pointerser1>7 then  'Action type is valid 
'      A_QueueType[queue_end]=A_RS485string[6]
'      A_QueueAction[queue_end]=A_RS485string[7]
'      gosub Increase_queue_pointer
'      OledInstr0=A_RS485string[8]
'      OledInstr1=A_RS485string[9]  
'    endif  
'  else
'    A_ErrorID[0]= A_ModID0[i-1]               'Input device is not responding
'    A_ErrorID[1]= A_ModID1[i-1]
'    A_ErrorID[2]= A_ModID2[i-1]
'    A_ErrorID[3]= A_ModID3[i-1]
'    ErrorTmp=i-1
'    error_code = 7
'    cid=0
'    Gosub Add_ErrorCount
'    gosub send_error  
'  endif
'return


'hier debug can
Communicate_CAN:
    'hserout2 ["A:Communicate CAN C ",dec A_RS485string[1],".",dec A_RS485string[2],".",dec A_RS485string[3]," ",dec A_RS485string[4]," ",dec A_RS485string[5]," ",dec A_RS485string[6]," (",dec i-1,": ",dec A_ModID1[i-1]," ",dec A_ModID2[i-1]," ",dec A_ModID3[i-1],")",13,10]
    if A_RS485string[1]==A_ModID1[i-1] and A_RS485string[2]==A_ModID2[i-1] and A_RS485string[3]==A_ModID3[i-1] then     'Correct device responded
        if ErrorCount_Can>0 then ErrorCount_Can=ErrorCount_Can-1
        if A_RS485string[5]=="d" then   'detailed information about nr of inputs and nr of outputs
            if mode_com==0 and debugmode==1 then    'Only check when in CLI mode and debug mode is ON
                if can_control_number>0 AND (can_control_number-1)<MAX_CAN_CONTROLS then    
                    if A_RS485string[6]!=A_cc_inputs[can_control_number-1] or A_RS485string[7]!=A_cc_sensors[can_control_number-1] or A_RS485string[8]!=A_cc_outputs[can_control_number-1] then
                        A_cc_inputs[can_control_number-1]=A_RS485string[6]
                        A_cc_sensors[can_control_number-1]=A_RS485string[7]
                        A_cc_outputs[can_control_number-1]=A_RS485string[8]
                        hserout2 ["CAN Control info (",dec can_control_number-1,"): Inputs: ",dec A_cc_inputs[can_control_number-1]," Sensors: ",dec A_cc_sensors[can_control_number-1]," Outputs: ",dec A_cc_outputs[can_control_number-1],13,10]
                    ENDIF
                endif
            endif  
        else
            gosub Erase_message
        endif            
    else                                                                                                                'wrong device responded
        if mode=="L" then Gosub Error_10
    endif             
return

Erase_message:
    'hserout2 ["B:Communicate CAN C ",dec A_RS485string[1],".",dec A_RS485string[2],".",dec A_RS485string[3]," ",dec A_RS485string[4]," ",dec A_RS485string[5]," ",dec A_RS485string[6],13,10]
    if A_RS485string[4]="F" and A_RS485string[5]="X" and mode_com=0 then 'respond on "FX message in CLI mode
        hserout2 ["CAN Control erase done ",dec A_RS485string[0],".",dec A_RS485string[1],".",dec A_RS485string[2],".",dec A_RS485string[3],13,10]
    endif
return

Communicate_input:
  if A_RS485string[1]=A_ModID1[i-1] and A_RS485string[2]=A_ModID2[i-1] and A_RS485string[3]=A_ModID3[i-1] then
    if ForceCRC=1 then                      'CRC check is active at input slave module
      CRC2=A_RS485string[4]+A_RS485string[5]+A_RS485string[6]+A_RS485string[7]+A_RS485string[8]+A_RS485string[9]
      if CRC2.byte1=A_RS485string[10] and CRC2.byte0=A_RS485string[11] then  'CRC is correct
        if (i-1)<MAX_INPUT_MODULES then gosub Analyse_input
      else                                  'CRC is wrong
        A_ErrorID[0]= A_ModID0[i-1]           'Input device is responding but with wrong CRC
        A_ErrorID[1]= A_ModID1[i-1]
        A_ErrorID[2]= A_ModID2[i-1]
        A_ErrorID[3]= A_ModID3[i-1]
        ErrorTmp=i-1
        error_code = 27                     'Wrong CRC or CRC information is missing
        cid = 0
        Gosub Add_ErrorCount
        gosub send_error  
      endif  
    else
      if (i-1)<MAX_INPUT_MODULES then gosub Analyse_input
    endif
  else                                      'wrong device responded
    Gosub Error_10   
  endif                                                            
return

check_FV_instruction:
   if A_RS485string[4]="F" and A_RS485string[5]="V" then
     gosub Send_F_instruction
   endif
return

Error_10:
    A_ErrorID[0]= A_ModID0[i-1]               'Input device is not responding
    A_ErrorID[1]= A_ModID1[i-1]
    A_ErrorID[2]= A_ModID2[i-1]
    A_ErrorID[3]= A_ModID3[i-1]
    ErrorTmp=i-1
    error_code = 10
    cid = 0
    Gosub Add_ErrorCount
    gosub send_error 
return

Analyse_Input:
  A_Input[i-1]=~A_RS485string[4]
  A_Input[i-1]=A_Input[i-1]^~A_InputInvert[i-1]        'When inverted inputs are used, set A_Input[i-1] right and invert
  x=A_Input[i-1]^A_InputOld[i-1] 
  if x<>0 then                              'Input has changed
    for t=0 to 7                            'Check which input is activated
      v=((i-1)*8)+t
      q=A_SelOutput[v]     
      if A_InputEnable[v]=1 or AllInputsAlwaysEnabled=YES then             'input enabled?
        m=A_Input[i-1]>>t                    'Check current input state
        n=A_InputOld[i-1]>>t                 'Check old input state   
        if m.bit0=1 and n.bit0=0 then        'Button pressed
          press_state=1                 
          gosub Rs232_message
          if A_SwitchType[v]=1 then          'switch type normal
            if A_ModID0[30+(q/8)]<>"D" and A_ModID0[30+(q/8)]<>"d" then  'Only for Non dimmers                       
              input_pressed=v
              ToggleTypeUsed=NO                          
              gosub input_action
            else                            'Switch on Dimmer output at button release            
              if v<MAX_INPUTS then A_PressTime[v]=1                
            endif
          else                              'switch type toggle          
            input_pressed=v
            gosub check_input_follow
            gosub input_action
          endif              
        elseif m.bit0=0 and n.bit0=1 then   'Button released
          press_state=0
          gosub Rs232_message
          if A_SwitchType[v]=1 then          'Switch type normal
            if A_PressTime[v]>0 and A_PressTime[v]<dim_cycle then
              if dimmer_mem=0 and q<MAX_OUTPUTS then          'No memory function
                A_DimmerValue[q]=63          'Light at maximum
                dimmer_value_eeprom_write=YES
                A_OutUpdate[q]=1
              endif
              ToggleTypeUsed=NO                            
              gosub input_action            
            endif
          else                              'switch type toggle
            'press_state=1
            'gosub Rs232_message
            input_pressed=v             
            gosub check_input_follow           
            gosub input_action
          endif            
        endif            
      endif
    next t   
  else                                      'Input has not changed
    for t=0 to 7                            'Check which input is activated
      v=((i-1)*8)+t
      q=A_SelOutput[v]     
      if A_InputEnable[v]=1 then              'input enabled?
        if A_SwitchType[v]=1 then            'Only for push button switches
          m=A_Input[i-1]>>t                     'Check current input state
          if m.bit0=1 then                  'Button remains pressed
            gosub Input_dimmer_action 
          endif
        endif  
      endif    
    next t
  endif
  if (i-1)<MAX_INPUT_MODULES then A_InputOld[i-1]=A_Input[i-1]
  gosub check_pulsecounter    
return

check_input_follow:
  eep_addr.byte0=v                          'address
  eep_addr.byte1=230                        'page
  gosub read_eeprom    
  if i2cdata=255 then
    ToggleTypeUsed=NO
  else
    ToggleTypeUsed=YES                      'This function will enable the input follow function
  endif
return

RS232_message:
  if InputDebug=1 then
    hserout2 ["Input (",dec press_state,")=",dec v," selected output=",dec q,13,10]
  endif
  if mode_com=1 and AutResponseIL=1 then    'only in API mode and when Auto Response Output List bit is set
    gosub send_IL
  endif 
return

Input_action:
  if v<MAX_INPUTS then A_PressTime[v]=0
  if q<240 and ToggleTypeUsed=NO then                             'Input toggle or dim must be activated
    'A_QueueType[queue_end]=162           'toggle
    'A_QueueAction[queue_end]=q
    BA_type_queue=162
    BA_action_queue=q       
    gosub Increase_queue_pointer  
  elseif q<240 and ToggleTypeUsed=YES then 
    x=v//8
    y=v/8
    z=A_Input[y]>>x
    'hserout2 ["Input pressed=",dec v," input state=",dec z.bit0,13,10]
    if z.bit0=1 then    'switch output ON
      'A_QueueType[queue_end]=161           'Output ON
      'A_QueueAction[queue_end]=q
      BA_type_queue=161
      BA_action_queue=q         
      gosub Increase_queue_pointer       
    else                'switch output OFF    
      'A_QueueType[queue_end]=160           'Output OFF
      'A_QueueAction[queue_end]=q 
      BA_type_queue=160
      BA_action_queue=q        
      gosub Increase_queue_pointer     
    endif           
  else
    if q=240 then                           'Input Action list must be loaded
      CurrentInput=v
      queue_module_nr=i
      queue_input_nr=t
      gosub fill_queue         
    endif
    if q=241 then                           'All outputs including lights off
      gosub all_outputs_off
    endif
    if q=242 then                           'All lights off
      level=255
      gosub all_lights_off     
    endif
  endif
return

Input_Dimmer_action:
  if ((A_ModID0[30+(q/8)]="D" or A_ModID0[30+(q/8)]="d") and q<MAX_OUTPUTS) then   'For dimmer outputs with toggle function only
    if A_PressTime[v]<dim_cycle then         'Not yet start dimming
      if v<MAX_INPUTS then A_PressTime[v]=A_PressTime[v]+1
      if A_PressTime[v]=dim_cycle then
        A_DimDirection[q]=~A_DimDirection[q]  'Toggle dim direction
        if A_DimmerValue[q]=63 then
          A_DimDirection[q]=0                'dim down
        endif
        if A_DimmerValue[q]<=dim_minimum then
          A_DimDirection[q]=1                'dim up
        endif        
      endif                       
    else                                    'Start dimming
      if A_DimDirection[q]=1 then            'dim up
        'A_QueueType[queue_end]=154+dim_step-1    'dim up
        'A_QueueAction[queue_end]=q
        BA_type_queue=154+dim_step-1    'dim up
        BA_action_queue=q          
        gosub Increase_queue_pointer 
      else                                  'dim down
        'A_QueueType[queue_end]=157+dim_step-1    'dim down
        'A_QueueAction[queue_end]=q
        BA_type_queue=157+dim_step-1    'dim up
        BA_action_queue=q         
        gosub Increase_queue_pointer       
      endif
    endif   
  endif
return

Check_PulseCounter:
  if A_RS485string[5]="P" then                'PulseCounter Information is available
    x=A_RS485string[6]                        'Which input counter information is sent over
    if x<8 then
      y=((i-1)*8)+x
      for t=0 to (PULSECOUNTERS-1)
        if A_PulseInput[t]=y then
          t_word.byte1=A_RS485string[7]
          t_word.byte0=A_RS485string[8]
          if t<PULSECOUNTERS THEN A_PulseCounter[t]=t_word
          t=PULSECOUNTERS-1
        endif  
      next t
    endif
  endif
return

Add_ErrorCount:
    If ErrorTmp<MAX_ERRORS and A_ErrorCount[ErrorTmp]<64999 then 
        A_ErrorCount[ErrorTmp]=A_ErrorCount[ErrorTmp]+1
        if A_ModID0[ErrorTmp]="C" then      'Check if it's a CAN Control
            if ErrorCount_Can<64999 then ErrorCount_Can=ErrorCount_Can+1
        endif
    endif    
return

empty_e:
  for ti=0 to 19
    A_e[ti]=0
  next ti
return

rs485_receive_init:                         'Routine used when in initialization mode (mode="I")
  if mode_com=1 then                        'advanced mode
    if A_RS485string[4]="E" and A_RS485string[5]="I" then    'Erase ID
      gosub empty_e
      A_e[0]="E"
      A_e[1]="I"
      A_e[2]=0
      A_e[3]=A_RS485string[0]
      A_e[4]=A_RS485string[1]
      A_e[5]=A_RS485string[2]
      A_e[6]=A_RS485string[3]
      gosub send_api
    endif
  endif
  gosub Check_duplicates
  gosub Add_modules
  InterpreteSer1=0
  RCSTA1.4=1                                'enable receiving serial 1
  gosub bus_init                            'Generate new ID's for non-initialized modules  
return  

Check_duplicates:
  if LargeInstallation=1 and A_RS485string[0]="R" then                            'Shutter in a large installation
    a=controller_out_rs
    b=33                   'start page in eeprom
    c=173                  'start byte (ID0) in eeprom
    d=0                    'controller_out_rs used
  elseif A_RS485string[0]="D" or A_RS485string[0]="O" or A_RS485string[0]="R" then    'Output module 
    a=controller_out
    b=33                   'start page in eeprom
    c=0                    'start byte (ID0) in eeprom 
    d=1                    'controller_out used   
  else                                                                           'Input module
    a=controller_in
    b=2                    'start page in eeprom
    c=0                    'start byte (ID0) in eeprom
    d=2                    'controller_in used    
  endif
  DuplicateID=0
  if a>0 and a<30 then     'Max 30 modules
    for ic=1 to a
      DuplicateID=1
      for x=0 to 3
        eep_addr.byte1 = b+ic-1     'page
        eep_addr.byte0 = c+x
        Gosub read_eeprom
        if i2cdata<>A_RS485string[x] then
          DuplicateID=0
        endif
      next x
      if duplicateID=1 then 
        z=ic
        ic=a     'exit
      endif 
    next ic
  else
    if a>29 then a=0
  endif  
return

Add_modules:                'uses variable a, b, c and d from sub check_duplicates
  if DuplicateID=0 then     'No duplicate
    gosub add_m        
  else                      'duplicate
    if A_RS485string[5]="N" then    
      if mode_com=0 then
        hserout2 ["New module with duplicate ID found, generating new ID, please press button again",13,10]
      else
        gosub empty_e
        A_e[7]="D"                               'instruction
        gosub MI_linux
      endif
      error_code = 26
      gosub send_error
      gosub bus_init                        'initialize bus again, all non programmed ID's are generated again
    else
      if mode_com=0 then                    'CLI mode
        gosub existing_module_CLI
      else
        gosub existing_module
      endif  
    endif
  endif
return

existing_module_CLI:
  a=~A_RS485string[4]
  if A_RS485string[0]="D" or A_RS485string[0]="O" or A_RS485string[0]="R" then 
    hserout2 ["output ",A_RS485string[0],dec z-1," ",dec (z-1)*8,"->",dec ((z-1)*8)+7,13,10]
  elseif A_RS485string[0]="I" or A_RS485string[0]="B" then 
    hserout2 ["input ",A_RS485string[0],dec z-1," ",dec (c*8)+b," "]
    a=(c*8)+b
    length=8
    Spaces=0 
    gosub eeprom_input_address
    gosub display_name
    gosub display_LF_CR
  'elseif A_RS485string[0]="L" then 
  '  hserout2 ["OLED screen ",A_RS485string[0],dec z-1,13,10] 
  elseif A_RS485string[0]="T" then
    hserout2 ["Temp/Hum/ADC ",A_RS485string[0],dec z-1,13,10]                
  elseif A_RS485string[0]="C" then
    hserout2 ["CAN Control ",A_RS485string[0],dec z-1,13,10]
  endif   
return

add_m:                      'uses variable a, b, c and d from sub check_duplicates
  if a<29 then              'Module can still be added
    e=A_RS485string[0]
    'or e="i" or e="o" or e="d"
    'if A_RS485string[0]="I" or A_RS485string[0]="T" or A_RS485string[0]="L" or A_RS485string[0]="O" or A_RS485string[0]="D" or A_RS485string[0]="R" then
    if A_RS485string[0]="I" or A_RS485string[0]="T" or A_RS485string[0]="O" or A_RS485string[0]="D" or A_RS485string[0]="R" then
      gosub add_m_sub
    endif
    if A_RS485string[0]="i" or A_RS485string[0]="o" or A_RS485string[0]="d" or A_RS485string[0]="r" or A_RS485string[0]="C"  then    'Virtual modules
      gosub add_m_sub
    endif    
  else                      'Maximum number of modules is reached
    if mode_com=0 then                      'CLI mode
      hserout2 ["Max # of modules reached on the bus, module not added",13,10]
    endif
  endif   
return

add_m_sub:
  for x=0 to 3
    eep_addr.byte1 = b+a  'page
    eep_addr.byte0 = c+x
    i2cdata = A_RS485string[x]
    gosub write_eeprom
  next x
  eep_addr.byte1 = 0      'page
  i2cdata = a+1
  if d=0 then             'program controller_out_rs in eeprom
    eep_addr.byte0 = 3  
  elseif d=1 then         'program controller_out in eeprom
    eep_addr.byte0 = 2  
  else                    'program controller_in in eeprom
    eep_addr.byte0 = 1  
  endif
  gosub write_eeprom
  eep_addr.byte1 = b+a          'page
  eep_addr.byte0 = 252  
  if A_RS485string[6]="T" then      'Type is also received in the message
    if A_RS485string[7]<>255 then   'different type then std input or temp module is received
      i2cdata = A_RS485string[7]
    endif  
  else
    i2cdata = 255     
  endif
  gosub write_eeprom  
  Gosub Read_Controller_InOut     'Copy eeprom values into RAM
  gosub add_m_comm        'send message about module add
return

add_m_comm:
  a=~A_RS485string[4]
  if mode_com=0 then                    'CLI mode 
    hserout2 ["New module found with ID:",dec A_RS485string[0],".",dec A_RS485string[1],".",dec A_RS485string[2],".",dec A_RS485string[3]," LI ",dec d,13,10] 
    hserout2 ["Type ",A_RS485string[0],dec v," ",bin8 a,13,10]
  else                                  'API mode
    gosub empty_e
    A_e[7]="N"                               'instruction
    gosub MI_linux
    pause 100
    gosub empty_e
    A_e[7]="E"                               'instruction
    A_e[8]=controller_in                     'module number
    A_e[9]=a                                 'data
    gosub MI_linux      
  endif
  A_SerString[3]=A_RS485string[0]
  A_SerString[4]=A_RS485string[1]
  A_SerString[5]=A_RS485string[2]
  A_SerString[6]=A_RS485string[3]
  pause 100
  gosub activate_device
return

Existing_module:
  gosub empty_e  
  A_e[7]="E"                                     'instruction
  A_e[8]=c                                       'module number
  A_e[9]=a                                       'data
  gosub MI_linux 
return

MI_linux:
  pause 10
  A_e[0]="M"
  A_e[1]="I"
  A_e[2]=0
  A_e[3]=A_RS485string[0]
  A_e[4]=A_RS485string[1]
  A_e[5]=A_RS485string[2]
  A_e[6]=A_RS485string[3]
  A_e[10]=d
  gosub send_api
return

Calc_indicate:     
  x=indicate/8
  'if indicate<>255 then hserout2 ["Indicate=",dec indicate," z=",dec z," i=",dec i,13,10]
  if IndicateTemperature=0 then             'do the calc for non Temperature modules
    if (i-1)=x then                         'led needs indication
      y=indicate//8
      gosub all_leds_off
      'hserout2 ["In/Out Indicate=",dec indicate," y=",dec y," z=",dec z," i=",dec i," x=",dec x,13,10]
    else
      y=255
    endif
  else                                      'do the calc for Temperature modules
    if temperaturecount=x and indicate<>255 and A_ModID0[i-1]="T" then              'led needs indication
      y=indicate//8
      gosub all_leds_off
      'hserout2 ["Temp Indicate=",dec indicate," y=",dec y," z=",dec z," i=",dec i," x=",dec x,13,10]
    else
      y=255
    endif  
  endif  
  if (IndicateInput=1 or IndicateTemperature=1) and z=0 then y=255
  if (IndicateInput=0 or IndicateTemperature=1) and z=1 then y=255 
  if IndicateTemperature=0 and z=2 then y=255 
  if y<>255 then indicate=255
  'if y<>255 and IndicateInput=1 then indicate=255  
return

All_leds_off:
    broad1="l"                              'Led
    broad2="O"                              'On/Off
    BroadID="C"                             'For CAN modules only
    broadData=0                             '0=All leds off
    gosub Add_Broad_queue 
return

Update_Can_leds:
  if UpdateCanLeds=1 and controller_in>0 then
    UpdateCanLeds=0
    broad1="U"                              'Update
    broad2="L"                              'All CAN Leds
    BroadID=0                             
    broadData=0
    gosub Add_Broad_queue
  endif                               
return

Output_debug:
  if debugmode=1 then
    q=OdOutputNr
    gosub check_output                      'check if output is on, q must contain output nr  
    Hserout2 [dec days," ",dec2 hours,":",dec2 minutes," OD Information",13,10,"OD Code:",dec OdCode," Output Nr:",dec OdOutputNr]
    if z.bit0=0 then
      hserout2 [" OFF",13,10]
    else
      hserout2 [" ON",13,10]
    endif     
    hserout2 ["Timer Value:",dec A_TimerCd[odOutputNr]," Dimmer Value:",dec A_DimmerValue[odoutputNr],13,10]
  endif
return

'------------------------------------------------------------------------------
' Intelligent functions
' See http://wiki.openmotics.com/index.php/Action_Types
'------------------------------------------------------------------------------

' Fill Queue ------------------------------------------------------------------

fill_queue:                                 'read all the intelligent actions from the input page and put them in the Action queue
  'A_QueueType[queue_end]=4               'Indicate in the queue which input has triggered the actions, to be used to activate group actions when input is pressed for x seconds 
  'A_QueueAction[queue_end]=CurrentInput
  BA_type_queue=4
  BA_action_queue=CurrentInput   
  gosub Increase_queue_pointer 
  AddToQueue=1
  gosub input_action_eeprom   
return

Input_action_eeprom:
eep_addr.byte1 = queue_module_nr+1          'start from page 2
  for queue_counter=0 to 14                 'max 15 intelligent functions to read
    eep_addr.byte0 = (queue_input_nr*30)+(queue_counter*2)+12
    Gosub read_eeprom  
    f0=i2cdata
    eep_addr.byte0 = eep_addr.byte0 + 1
    gosub read_eeprom
    f1=i2cdata    
    if AddToQueue=1 then
      if f0<>255 then
        'A_QueueType[queue_end]=f0
        'A_QueueAction[queue_end]=f1
        BA_type_queue=f0
        BA_action_queue=f1 
        gosub Increase_queue_pointer 
      else
        queue_counter=14                    'abort routine
      endif
    else                                    'when used by API instruction "ri"
      Hserout2 [f0,f1]
      CRC=CRC+f0+f1
    endif
  next queue_counter    
return

' Check Queue -----------------------------------------------------------------

check_queue:
    if queue_end>0 and queue_end<queue_max then                   'something in the queue
        low led_red
        CurrentInput=255  
        for queue_pointer=0 to (queue_end-1)                'check all queue entries
            if queue_end>=QUEUE_MAX then queue_end=QUEUE_MAX-1
            BA_type=A_QueueType[queue_pointer]
            BA_action=A_QueueAction[queue_pointer]
            if debugmode=1 then                   'Debug info 
                Hserout2 ["Execute queue Action ",dec queue_pointer,"/",dec queue_end, ": ",dec BA_type," ",dec BA_action,13,10]
            endif
            if BA_type=235 then             'execute delayed Action                                                              
                DelayedTime=BA_action
                if DelayedTime>0 and DelayedTime<248 then DelayedTime=DelayedTime+1
            endif
            if BA_type=236 then             'execute Action at button release state
                if BA_action=0 then
                    ActionButtonRelease=1
                else
                    ActionButtonRelease=0
                endif
            endif          
            if BA_type=240 then             'IF THEN ELSE Instructions
                IfInstr=BA_action
            endif        
            if (BA_type=1 or BA_type=9 or BA_type=17) and (IfInstr<10) then         'call simple decision
                gosub simple_decision 
            elseif BA_type=4 then           'Remember which input has triggered the current actions
                CurrentInput=BA_action                                                 
            elseif (BA_type=25 or BA_type=49 or BA_type=57) and (IfInstr<10) then   'call simple decision
                gosub simple_decision   
            elseif BA_type>240 and BA_type<245 and BA_action<240 then               'Check Input/output
                gosub Check_InpOutp      
            elseif BA_type>244 and BA_type<248 then                                       'Check Validation Bit, Temperature, humidity, setpoint etc
                gosub Check_InpOutp                                                                                 
            endif
            if (IfInstr=255) or (IfInstr=10 and decision_new=1) or (IfInstr=20 and decision_new=0) then  'execute these instruction only when IF THEN is not active OR when "then" is valid OR when "else" is valid        
                if ActionButtonRelease=0 then       'check if Action must be performed immeadiatly or at button release
                    if DelayedTime>0 and DelayedTime<250 and BA_type<>235 and BA_type<>236 then              
                        gosub add_timer_queue           'Delayed Action
                    else
                        gosub check_queue_sub           'immeadiate Action
                    endif  
                else
                    if BA_type<>235 and BA_type<>236 then           
                        gosub add_timer_queue           'Action at button release -> copy to the timer_queue
                    endif
                endif  
            endif                 
        next queue_pointer
        queue_end=0                           'empty queue
        ToggleFollowON=0                      'Toggle follow function off
        ToggleFollowActive=0
    endif
return

check_queue_sub:
    if BA_type=4 then                   'Remember which input has triggered the current actions
        CurrentInput=BA_action    
    elseif BA_type>159 and BA_type<174 then 'Output ON/OFF/Toggle/All light off/all off function
        Gosub output_OnOff
    elseif BA_type>206 and BA_type<212 then 'Execute group Action when input is pressed longer than x seconds
        Gosub Timer_group         
'    elseif BA_type>127 and BA_type<144 then 'Thermostat function        
'        gosub Thermostat_action
'        gosub Send_thermostat_event  
'    elseif BA_type>144 and BA_type<150 then 'Thermostat function        
'        gosub Thermostat_action
'        gosub Send_thermostat_event
'    elseif BA_type>89 and BA_type<94 then  'Thermostat function Multi-Tenant        
'        gosub Thermostat_action
'        gosub Send_thermostat_event
    elseif BA_type>89 and BA_type<94 then   'Thermostat function
        gosub send_EV2
    elseif BA_type>127 and BA_type<150 then 'Thermostat function
        gosub send_EV2            
    elseif BA_type=68 then              'Virtual input press
        gosub Virtual_input_press
    elseif BA_type=69 then              'Virtual input release
        gosub Virtual_input_release             
    elseif BA_type=0 then               'call simple Action
        gosub simple_action 
    elseif BA_type=2 then               'call group Action
        gosub group_action  
    elseif BA_type=153 then             'output On and overrule timer with std timer value
        gosub output_on_overrule    
    elseif BA_type=174 then             'Toggle Follow ON
        ToggleFollowOn=1
        ToggleFollowActive=0 
    elseif BA_type=175 then             'Toggle Follow OFF
        ToggleFollowOn=0
        ToggleFollowActive=0 
    elseif BA_type>175 and BA_type<207 then                   'Output ON/Toggle function at 10%-100% dimmer value or timer value
        Gosub output_OnOff
    elseif BA_type>153 and BA_type<160 then                   'Dim output (up or down) with 1, 2 or 3 steps
        Gosub output_dim         
    elseif BA_type=1 or BA_type=9 or BA_type=17 then    'call simple decision
        gosub simple_decision                         
    elseif BA_type=25 or BA_type=49 or BA_type=57 then  'call simple decision
        gosub simple_decision    
    elseif BA_type=3 or BA_type=7 then                        'call scheduled Action
        if BA_type=3 then
            gosub scheduled_action
        else
            digitcount=1
            A_DigitTotal[0]=BA_action
            ok=0
            gosub schedule_queue_delete
            ok=1
        endif                                             
    elseif BA_type=64 then              'Switch on/off leds
        if BA_action=0 then
            gosub low_Powerstate
        endif
        if BA_action=1 then
            gosub normal_Powerstate
        endif
        if BA_action=2 then
            gosub normal_Powerstate_2
        endif
    elseif BA_type>99 and BA_type<114 then 'Store/Shutter Action in Large Installations
        Gosub StoreShutter_action    
    elseif BA_type=65 then              'Output indicate
        gosub Queue_output_indicate
    elseif BA_type=66 then              'Input indicate
        gosub Queue_input_indicate
    elseif BA_type=67 then              'Sensor indicate
        gosub Queue_sensor_indicate    
    elseif BA_type=116 then             'Disable Input x
        if BA_action<MAX_INPUTS then A_InputEnable[BA_action]=0        
    elseif BA_type=117 then             'Enable Input x
        if BA_action<MAX_INPUTS then A_InputEnable[BA_action]=1            
    elseif BA_type=118 then             'reset PulseCounter x
        gosub reset_pulsecounter         
    elseif BA_type>119 and BA_type<127 then   'Set Free variables        
        gosub Set_Free_Variables             
    elseif BA_type>211 and BA_type<221 then
        gosub CAN_Leds    
    elseif BA_type=237 then             'Set Validation Bit
        A_ValBit[BA_action]=1
        ValBitNr=BA_action
        gosub send_EV1
    elseif BA_type=238 then             'Clear Validation Bit
        A_ValBit[BA_action]=0
        ValBitNr=BA_action
        gosub send_EV1    
    elseif BA_type=239 then             'Toggle Validation Bit   
        i_bit2=A_ValBit[BA_action]
        toggle i_bit2
        A_ValBit[BA_action]=i_bit2
        ValBitNr=BA_action
        gosub send_EV1    
    elseif BA_type=70 then              'Switch OFF 5V All Sensor Modules (will switch automatically after 1 minute)
        broad1="P"                              'Power message broadcast
        broad2="F"
        BroadID=0
        gosub Add_Broad_queue                        'send broadcast on RS485 network 
    elseif BA_type=71 then              'Swicth ON 5V All sensor Modules
        broad1="P"                              'Power message broadcast
        broad2="N"
        BroadID=0
        gosub Add_Broad_queue                        'send broadcast on RS485 network 
    elseif BA_type=72 then              'Reset Power of all slave modules
        high PowerSlaves                        'Switch off power of all slaves
        pause 2000
        clearwdt
        pause 2000
        clearwdt
        low PowerSlaves                         'Switch on power of all slaves
        for u=1 to controller_out
            if u<MAX_OUTPUT_MODULES+1 then A_WriteYesMod[u-1]=OutputNrWrites
        next u
        write_yes=1
        pause 1000
        clearwdt
    elseif BA_type=73 then              'Switch DALI group ON
        if BA_action<32 then              'Max 32 groups (0..31)
            broad1="G"                            'Group message broadcast
            broad2=BA_action                'Group Number
            broadData=254                         'Dim Value
            GroupDimValue=254
            broadId="C"                           'CAN modules only
            gosub Add_Broad_queue
            GroupNr=BA_action
            GroupDimValue=BroadData
            GroupOn=1     
            gosub Set_Dali_outputs
        endif   
    elseif BA_type=74 then              'Switch DALI Group OFF
        if BA_action<32 then              'Max 32 groups (0..31)
            broad1="G"                            'Group message broadcast
            broad2=BA_action                'Group Number
            broadData=0                           'Dim Value
            broadId="C"                           'CAN modules only
            gosub Add_Broad_queue
            GroupNr=BA_action
            GroupDimValue=BroadData
            GroupOn=0
            gosub Set_Dali_outputs
        endif
    elseif BA_type=75 then              'Switch ON power micro CAN modules
        broad1="P"                              'Power message broadcast
        broad2="n"
        BroadID=0
        gosub Add_Broad_queue                        'send broadcast on RS485 network 
    elseif BA_type=76 then              'Swicth OFF power micro CAN modules
        broad1="P"                              'Power message broadcast
        broad2="f"
        BroadID=0
        gosub Add_Broad_queue           
    elseif BA_type=79 then              'Is Clean-up of doubles in the Timer Queue enabled or disabled for every new BA added in the timer queue
        if BA_action=0 then               'Clean-up disabled
            CleanTimerQueue=0
        else
            CleanTimerQueue=1  
        endif             
    elseif BA_type=60 then              'Sent Event
        gosub Send_EV    
    'elseif BA_type=80 then              'Cooling mode?
    '    gosub Set_Cooling
    '    gosub Send_thermostat_event 
    'elseif BA_type=81 then              'Enable/Disable Airco (RTD-10)
    '    gosub Set_Airco
    '    gosub Send_thermostat_event 
    'elseif BA_type=82 then              'Set Permanent Manual Mode
    '    u=1
    '    gosub SetClear_PermanentManual
    '    gosub Send_thermostat_event
    'elseif BA_type=83 then              'Clear Permanent Manual Mode
    '    u=0
    '    gosub SetClear_PermanentManual
    '    gosub Send_thermostat_event
    elseif BA_type>=80 and BA_type<=83 then   'Thermostat function
        gosub send_EV2            
    elseif BA_type=8 then               'Reset all errors and bring modules that are offline back online
        gosub Reset_error                     
    elseif BA_type=254 then             'reset processor
        asm
            reset
        endasm                                                                        
    endif
    BA_parameter_used=NO  
return

'Send_thermostat_event:
'    if ThermostatEnabled==0 then    'send event when thermostats are disabled
'        if mode_com=1 then
'            gosub empty_e
'            cid=0
'            A_e[0]="E"
'            A_e[1]="V"
'            A_e[2]=cid    'CID=0
'            A_e[3]=2
'            A_e[4]=BA_type
'            A_e[5]=BA_action
'            gosub send_api     
'        endif    
'    endif
'return

Set_Dali_Outputs:
  for ic=0 to 63                                             'Switch On/Off outputs
    eep_addr.byte1=104+(GroupNr/4)                           'page 104 till 107
    eep_addr.byte0=ic+(64*(GroupNr//4))                      'Maximum 64 outputs per group
    gosub read_eeprom
    'Hserout2 ["Group eep ",dec eep_addr.byte1," ",dec eep_addr.byte0, ": ",dec i2cdata,13,10]
    if i2cdata<240 then                                      'group output
      A_DigitTotal[0]=i2cdata
      A_DigitTotal[1]=GroupDimValue/4
      if GroupOn=1 then                                         
        digitcount=2
        ok=0
        gosub output_on
        ok=1
      else
        digitcount=1
        ok=0
        gosub output_off
        ok=1
      endif  
    else      
      ic=63                                                  'exit
    endif              
  next ic
return

CAN_Leds:
  if BA_type=218 then                 'Set Minimum brightness 
    broad1="l"                              'Led
    broad2="L"                              'Low
    BroadID="C"                             'For CAN modules only
    broadData=BA_action               'Led value
    gosub Add_Broad_queue
    eep_addr.byte0=31                       'address
    eep_addr.byte1=0                        'page
    i2cdata=BA_action
    gosub write_eeprom 
  elseif BA_type=219 then             'Set Maximum brightness 
    broad1="l"                              'Led
    broad2="H"                              'High
    BroadID="C"                             'For CAN modules only
    broadData=BA_action               'Led value
    gosub Add_Broad_queue                        'Set Led
    eep_addr.byte0=32                       'address
    eep_addr.byte1=0                        'page
    i2cdata=BA_action
    gosub write_eeprom
  elseif BA_type=220 then             'Switch OFF all leds
    Gosub all_leds_off      
  else                                      'Led
    'delete
    'Hserout2 ["Set Led ",dec BA_type," ",dec BA_action,13,10]
    broad1="l"  
    broad2=BA_type-212
    broadID="C"                             'For CAN modules only
    broadData=BA_action               'Led Nr
    gosub Add_Broad_queue
    'gosub send_broad
  endif  
return

'SetClear_PermanentManual:
'  a=BA_action
'  if a<(MAX_THERMOSTATS*2) then
'    eep_addr.byte0=32+a                      'address
'    eep_addr.byte1=195                       'page
'    if u=1 then                              'set permanent manual mode
'      i2cdata=0
'    else                                     'clear permanent manual mode
'      i2cdata=255
'    endif    
'    gosub write_eeprom
'    A_PermanentManual[a]=u  
'  endif       
'return

Check_InpOutp:
  if IfInstr<10 then                        'u will indicate which operator (u=0 -> no operator, u=1 -> AND, u=2 -> OR etc) must be applied
    u=IfInstr
  else
    u=0
  endif
  if BA_type=241 then                 'check if input is on
    v=1                                     'check if input is ON
    w=1                                     'check input
    gosub Set_Decision_new
  elseif BA_type=242 then             'check if input is off
    v=0                                     'check if input is OFF
    w=1                                     'check input
    gosub Set_Decision_new
  elseif BA_type=243 then             'check if output is on
    v=1                                     'check if output is ON
    w=0                                     'check output
    gosub Set_Decision_new 
  elseif BA_type=244 then             'check if output is off
    v=0                                     'check if output is OFF
    w=0                                     'check output
    gosub Set_Decision_new  
  elseif BA_type=245 then             'check if validation bit is on
    v=1                                     'check if output is ON
    w=2                                     'check Validation bit
    gosub Set_Decision_new
  elseif BA_type=246 then             'check if validation bit is off
    v=0                                     'check if output is OFF
    w=2                                     'check Validation bit
    gosub Set_Decision_new
  elseif BA_type=247 and A_QueueType[queue_pointer+1]>247 and A_QueueType[queue_pointer+1]<251 then  'check Temperature or light sensor or A_humidity or setpoint or time etc
    gosub Set_Decision_new2
  endif          
return

Set_Decision_New:
  x=BA_action//8
  y=BA_action/8
  if w=0 then                               'output
    z=A_Output[y]>>x
  endif  
  if w=1 then                               'input
    z=A_Input[y]>>x
  endif
  if w=2 then                               'validation bit
    z=A_ValBit[BA_action]
  endif
  if z.bit0=v then                          'true
    decision_new=1
  else                                      'false
    decision_new=0
  endif 
  gosub test_IfInstr       
return

Set_Decision_New2:  
  x=BA_action
  y=A_QueueAction[queue_pointer+1]
  if x<32 then                                'Temperature sensor
    z=A_Temperature[x]
  elseif x>31 and x<64 then     'A_humidity sensor
    z=A_humidity[x-32]
  elseif x>63 and x<96 then     'Light sensor
    z=A_ldr[x-64]
'  elseif x>95 and x<128 then    'Temperature setpoint
'    z=A_Setpt[x-96]
  elseif x>127 and x<160 then   'Free Variable
    z=A_FreeVar[x-128]    
  elseif x=228 then                           'Hour
    z=hours
  elseif x=229 then                           'Minute
    z=minutes
  elseif x=230 then                           'Day
    z=days
'  elseif x=235 then                           'Thermostat mode
'    z=ThermostatMode     
  endif
  
  if A_QueueType[queue_pointer+1]=248 then               '=
    if z=y then
      decision_new=1
    else
      decision_new=0
    endif
  elseif A_QueueType[queue_pointer+1]=249 then           '>
    if z>y then
      decision_new=1
    else
      decision_new=0
    endif  
  elseif A_QueueType[queue_pointer+1]=250 then           '<
    if z<y then
      decision_new=1
    else
      decision_new=0
    endif  
  endif
  gosub test_IfInstr
  if queue_pointer<(QUEUE_MAX-2) then queue_pointer=queue_pointer+1                                     'done 2 instruction from the queue         
return

test_IfInstr:
  if IfInstr=1 then                         'perform AND
    decision_new=decision_new&Decision_old
  endif  
  if IfInstr=2 then                         'perform OR
    decision_new=decision_new|Decision_old
  endif 
  if IfInstr=3 then                         'perform XOR
    decision_new=decision_new^Decision_old
  endif 
  if IfInstr=4 then                         'perform NAND
    decision_new=decision_new&/Decision_old
  endif 
  if IfInstr=5 then                         'perform NOR
    decision_new=decision_new|/Decision_old
  endif 
  if IfInstr=6 then                         'perform NXOR
    decision_new=decision_new^/Decision_old
  endif       
  decision_old=decision_new 
return

Timer_group:
  if CurrentInput<240 and timer_queue_pointer<(timer_queue-1) then  'only execute when valid input is used AND when Timer_queue is not full
    'add Action to the timer queue
    A_Action[5]=BA_action
    A_Action[4]=2                               'Execute group Action in timer queue if input is pressed more than x seconds
    A_Action[6]=CurrentInput
    A_Action[3]=BA_type-205
    gosub add_timer_queue2     
  endif
return

'correct_setpt:
'  for pid=0 to (MAX_THERMOSTATS-1)
'     'hier_thermo
'     if A_Setpt[pid]>150 then 
'       A_Setpt[pid]=88   '12 degree celcius
'       EepromSetptWrite=1                         'write eeprom
'       ThermostatNr=pid
'       gosub check_setpoint
'     endif  
'  next pid
'  PidCalcCheck=1 
'return

Set_Free_Variables:
  if BA_action<32 then                'only free variable 0-31 can be used
    a=BA_action
    if BA_type=120 then
      A_FreeVar[a]=0
    elseif BA_type=121 then
      A_FreeVar[a]=A_FreeVar[a]-1
    elseif BA_type=122 then
      A_FreeVar[a]=A_FreeVar[a]+1
    elseif BA_type=123 then
      A_FreeVar[a]=A_FreeVar[a]-2
    elseif BA_type=124 then
      A_FreeVar[a]=A_FreeVar[a]+2
    elseif BA_type=125 then
      A_FreeVar[a]=A_FreeVar[a]-3
    elseif BA_type=126 then
      A_FreeVar[a]=A_FreeVar[a]+3
    endif  
  endif
return

reset_pulsecounter:
  broad1="C"                                'Clear Pulse counters of all modules
  broad2="C"
  BroadID=0
  gosub Add_Broad_queue
  gosub Add_Broad_queue 
return

' Thermostat Action -----------------------------------------------------------

'Thermostat_action:
'  if BA_type>127 and BA_type<134 then       'copy individual programmed setpoint into current setpoint
'    a=BA_action                       'a=0..23
'    b=BA_type-128                     'b=0..5
'    if a<MAX_THERMOSTATS then
'      gosub Thermostat_action_sub    
'      gosub correct_setpt
'      if ThermostatMode.Bit6=1 then                     'Multi-tenancy is enabled so set the Multi-tenant configuration byte
'        eep_addr.byte1=199                                'page 199
'        eep_addr.byte0=a+32
'        gosub read_eeprom                               'byte
'        i2cdata=i2cdata & %11111000
'        i2cdata=i2cdata+b
'        gosub write_eeprom      
'      endif
'    endif   
'  elseif BA_type>133 and BA_type<140 then   'copy full series of programmed setpoint into current setpoint
'    if ThermostatMode.bit6=0 then                         'Multi tenancy is not enabled
'      b=BA_type-134 'b=0..5
'      ThermostatMode=ThermostatMode & %11111000
'      ThermostatMode=ThermostatMode | b
'      gosub Write_ThermostatMode
'      for a=0 to (MAX_THERMOSTATS-1)
'        if A_PermanentManual[a+(MAX_THERMOSTATS*thermostatCooling)]=0 then
'          gosub Thermostat_action_sub
'        endif
'      next a  
'      gosub correct_setpt
'    else
'      gosub Set_all_thermostats
'    endif
'  elseif BA_type>89 and BA_type<92 then   'Multi-Tenant mode instructions
'    if ThermostatMode.bit6=1 then           'Multi-tenant is enabled
'      a=BA_action                     'Thermostat Number
'      if a<MAX_THERMOSTATS then
'        gosub Thermostat_action_MultiT
'      endif
'    endif  
'  elseif BA_type=145 then             'set day1 Temperature of that day for Thermostat x
'    a=BA_action                       'Thermostat Number
'    b=0                                     'Day1
'    if a<MAX_THERMOSTATS then
'      c=days
'      gosub Thermostat_action_sub2
'    endif
'    gosub correct_setpt     
'  elseif BA_type=146 then             'set day2 Temperature of that day for Thermostat x
'    a=BA_action                       'Thermostat Number
'    b=1                                     'Day2
'    if a<MAX_THERMOSTATS then
'      c=days
'      gosub Thermostat_action_sub2
'    endif
'    gosub correct_setpt
'  elseif BA_type=147 then             'set Night Temperature of that day for Thermostat x
'    a=BA_action                       'Thermostat Number
'    b=2                                     'Night
'    if a<MAX_THERMOSTATS then
'      c=days
'      gosub Thermostat_action_sub2
'    endif
'    gosub correct_setpt
'  elseif BA_type=148 then             'Setpoint at 16 degree
'    a=BA_action
'    if a<MAX_THERMOSTATS then
'      A_Setpt[a]=96
'      'hier_thermo
'      EepromSetptWrite=1                                 'write eeprom
'      ThermostatNr=a
'      gosub check_setpoint
'      'delete
'      'hserout2 ["0:Temp(",dec a,")=",dec A_Setpt[a],13,10]
'      'hier_thermo
'      'if a<24 then
'      '  i2caddr = 40+a
'      '  i2cdata = A_Setpt[a]
'      '  gosub write_i2c_2
'      'endif  
'    endif
'  elseif BA_type=149 then             'Setpoint at 22.5 degree
'    a=BA_action
'    if a<MAX_THERMOSTATS then
'      A_Setpt[a]=109
'      'hier_thermo
'      EepromSetptWrite=1                         'write eeprom
'      ThermostatNr=a      
'      gosub check_setpoint
'      'delete
'      'hserout2 ["1:Temp(",dec a,")=",dec A_Setpt[a],13,10]      
'      'hier_thermo
'      'if a<24 then
'      '  i2caddr = 40+a
'      '  i2cdata = A_Setpt[a]
'      '  gosub write_i2c_2
'      'endif  
'    endif             
'  elseif BA_type=140 then             'write ThermostatMode and copy series of programmed setpoint into current setpoint
'    ThermostatMode=BA_action 
'    gosub Write_ThermostatMode
'    b=BA_action
'    b=b & %00000111
'    if b<6 then                           'b=0..5
'      for a=0 to (MAX_THERMOSTATS-1)
'        if A_PermanentManual[a+(MAX_THERMOSTATS*thermostatCooling)]=0 then
'          gosub Thermostat_action_sub
'        endif  
'      next a    
'    endif
'    gosub correct_setpt
'    gosub thermostat_timing               'set all thermostats in the right mode conform to the programmed timings  
'  elseif BA_type=141 then             'set Thermostat mode to Manual or automatic
'    if ThermostatMode.bit6=0 then           'Multi tenancy is not enabled
'      if BA_action=0 then
'        ThermostatMode.bit3=0                 'Manual mode, ignore automatic settings
'      else
'        ThermostatMode.bit3=1                 'Autmatic mode
'        gosub thermostat_timing               'set all thermostats in the right mode conform to the programmed timings
'      endif
'      gosub Write_ThermostatMode
'      gosub correct_setpt
'    else                                    'Multi-tenancy is enabled, set this change for all thermostats
'      gosub Set_all_thermostats
'    endif    
'  elseif BA_type=142 then             'Decrease current setpoint
'    a=BA_action
'    if a<MAX_THERMOSTATS then
'      A_Setpt[a]=A_Setpt[a]-1
'      'hier_thermo
'      EepromSetptWrite=1                         'write eeprom
'      ThermostatNr=a      
'      gosub check_setpoint
'      'delete
'      'hserout2 ["2:Temp(",dec a,")=",dec A_Setpt[a],13,10]      
'      'hier_thermo
'      'if a<24 then
'      '  i2caddr = 40+a
'      '  i2cdata = A_Setpt[a]
'      '  gosub write_i2c_2
'      'endif  
'    endif          
'  elseif BA_type=143 then             'Increase current setpoint
'    a=BA_action
'    if a<MAX_THERMOSTATS then
'      A_Setpt[a]=A_Setpt[a]+1
'      'hier_thermo
'      EepromSetptWrite=1                         'write eeprom
'      ThermostatNr=a      
'      gosub check_setpoint
'      'delete
'      'hserout2 ["3:Temp(",dec a,")=",dec A_Setpt[a],13,10]      
'      'hier_thermo
'      'if a<24 then
'      '  i2caddr = 40+a
'      '  i2cdata = A_Setpt[a]
'      '  gosub write_i2c_2
'      'endif       
'    endif
'  elseif BA_type=144 then             'Instruction received from Oled
'    a=BA_action
'    if a<MAX_THERMOSTATS then
'      A_DigitTotal[0]=BA_action         'Thermostat number
'      A_DigitTotal[1]=OledInstr0              'Config parameter
'      A_DigitTotal[2]=OledInstr1              'Data
'      digitcount=3
'      gosub interprete_thermostat_instr    
'    endif    
'  endif    
'return

'Set_all_Thermostats:
'  for q=0 to (MAX_THERMOSTATS-1)
'    if BA_type=141 then    'Change between Auto and Manual for all thermostats
'      if BA_action=0 then  'Manual Mode for all thermostats
'        'A_QueueType[queue_end]=91  'Thermostat in Manual Mode
'        'A_QueueAction[queue_end]=q
'        BA_type_queue=91
'        BA_action_queue=q          
'        gosub Increase_queue_pointer
'      else                            'Automatic mode for all thermostats
'        'A_QueueType[queue_end]=90  'Thermostat in Manual Mode
'        'A_QueueAction[queue_end]=q
'        BA_type_queue=90
'        BA_action_queue=q        
'        gosub Increase_queue_pointer       
'      endif
'    endif
'    if BA_type>136 and BA_type<140 then
'        'A_QueueType[queue_end]=BA_type-6  'Copy Away, VAC or Party setpoint (BA131,132 or 133)
'        'A_QueueAction[queue_end]=q 
'        BA_type_queue=BA_type-6
'        BA_action_queue=q
'        gosub Increase_queue_pointer    
'    endif
'  next q
'return

'check_setpoint:
'  if ThermostatNr<MAX_THERMOSTATS then
'    'hier_thermo
'    if A_Setpt[ThermostatNr]>170 or A_Setpt[ThermostatNr]<44 then 
'      A_Setpt[ThermostatNr]=94   'Temperature too low or high -> set 15 degree
'      'SetAuto=1     'Something is not normal, if Thermostat is in auto mode, reload auto temperatures
'      EepromSetptWrite=1
'    endif      
'    if A_Setpt[ThermostatNr]<76 then 
'      A_Setpt[ThermostatNr]=76                   'Minimum 6 degree
'      EepromSetptWrite=1
'    endif  
'    if A_Setpt[ThermostatNr]>128 then 
'      A_Setpt[ThermostatNr]=128                 'Maximum 32 degree
'      EepromSetptWrite=1
'    endif
'      
'    'hier_thermo
'    if startup=0 and EepromSetptWrite=1 then                                     'Only write eeprom after startup
'      eep_addr.byte1=199
'      eep_addr.byte0=ThermostatNr+64
'      i2cdata=A_Setpt[ThermostatNr]
'      gosub write_eeprom
'    endif     
'  endif
'return
  
'Read_Setpt:
'  'if A_ThermostatAuto[a]=0 then                        'Thermostat in Manual mode
'  if a<MAX_THERMOSTATS then
'    eep_addr.byte1=142+(59*thermostatCooling)           'page 142 or 201
'    eep_addr.byte0=(b*32)+a+32
'    gosub read_eeprom  
'    A_Setpt[a]=i2cdata
'    'hier_thermo
'    EepromSetptWrite=0
'    if startup=0 then EepromSetptWrite=1                                  'write eeprom
'    ThermostatNr=a
'    gosub check_setpoint
'    'delete
'    'hserout2 ["4:Temp(",dec a,")=",dec A_Setpt[a],13,10]
'  endif  
'return

'Thermostat_action_sub:
'  Gosub Read_Setpt
'  'if thermostatMode.byte6=0 then                      'Thermostat in Normal mode (not multi-tenant mode)
'  'hier_thermo
'  'if a<24 then
'  '  i2caddr = 40+a
'  '  gosub write_i2c_2
'  'endif  
'return

'Thermostat_action_MultiT:                             'Thermostat in multi-tenant mode
'  if BA_type=90 and a<MAX_THERMOSTATS then    'Set Thermostat in Auto mode
'    A_ThermostatAuto[a]=1
'    i2cdata=%00001000
'    eep_addr.byte1=199                                'page 199
'    eep_addr.byte0=a+32                               'byte
'    gosub write_eeprom
'    q=a
'    gosub thermostat_timing_sub    
'  endif
'  if BA_type=91 and a<MAX_THERMOSTATS then   'Set Thermostat in Manual mode
'    A_ThermostatAuto[a]=0
'    eep_addr.byte1=199                                'page 199
'    eep_addr.byte0=a+32                               'byte
'    gosub read_eeprom
'    i2cdata=i2cdata & %11110111
'    gosub write_eeprom
'    'b=BA_type-91
'    'ThermostatManualB1[a]=b.bit1
'    'ThermostatManualB0[a]=b.bit0
'  endif                    
'return

'Thermostat_action_sub2:
'  if a<MAX_THERMOSTATS then
'    gosub Thermostat_day1_day2 
'    A_Setpt[a]=i2cdata
'    'hier_thermo
'    EepromSetptWrite=1                         'write eeprom
'    ThermostatNr=a    
'    gosub check_setpoint
'    'delete
'    'hserout2 ["5:Temp(",dec a,")=",dec A_Setpt[a],13,10]
'  endif
'  'hier_thermo
'  'if a<24 then  
'  '  i2caddr = 40+a
'  '  gosub write_i2c_2
'  'endif
'return

'Thermostat_day1_day2:
'  eep_addr.byte0=((c-1)*32)+a
'  if b=0 then                               'day1
'    eep_addr.byte1=196+(14*thermostatCooling)        'page 196 or 210
'  elseif b=1 then                           'day2
'    eep_addr.byte1=197+(14*thermostatCooling)        'page 197 or 211
'  else                                      'night
'    eep_addr.byte1=198+(14*thermostatCooling)        'page 198 or 212  
'  endif  
'  gosub read_eeprom 
'return


output_dim:
  q=BA_action
  write_yes=1                                   'write to output modules
  if q<MAX_OUTPUTS then 
    A_WriteYesMod[q/8]=OutputNrWrites         'but only to selected module
    A_OutUpdate[q]=1    
    if BA_type<157 then                 'dim up
      v=BA_type-153
      A_DimmerValue[q]=A_DimmerValue[q]+v
      if A_DimmerValue[q]>63 then A_DimmerValue[q]=63
    else                                      'dim down
      v=BA_type-156
      A_DimmerValue[q]=A_DimmerValue[q]-v
      if A_DimmerValue[q]>63 or A_DimmerValue[q]<dim_minimum then A_DimmerValue[q]=dim_minimum  
    endif
    dimmer_value_eeprom_write=YES
    gosub Dimmer_Group_follow
  endif
return

' Store/Shutter actions when LargeInstallation is enabled ---------------------
StoreShutter_action:
    if BA_Action<120 then                   'Max 120 shutters 
        if BA_type==100 then                'Store x up
            x=BA_Action//4
            y=BA_Action/4
            shutter_nr=BA_action
            gosub Store_Up
            i_bit=1                                 'up
            if TimerRSenabled=1 then
                A_Action[4]=102                       'Stop Individual Store
                gosub Remove_timer                    'Erase
                gosub add_timer                       'Add
            endif
        elseif BA_type=101 then             'Store x down
            x=BA_Action//4
            y=BA_Action/4
            shutter_nr=BA_action
            gosub Store_down
            i_bit=0                                 'down
            if TimerRSenabled=1 then
                A_Action[4]=102                       'Stop Individual Store
                gosub Remove_timer                    'Erase
                gosub add_timer                       'Add
            endif       
        elseif BA_type=102 and All_stores_locked==NO then             'Store x stop
            x=BA_Action//4
            y=BA_Action/4
            gosub Store_Stop
            A_Action[4]=102                         'Stop Individual Store
            gosub Remove_timer                      'Erase
        elseif BA_type=103 then             'Store up/stop/down/stop
            UpDwn=1                                 'Up/Dwn function enabled
            gosub Prep_Store_action
        elseif BA_type=104 then             'Group x Up
            c=2
            gosub Store_group
            A_Action[4]=106                         'Stop group Store
            gosub Remove_timer                      'Erase
            i_bit=1                                 'Up
            gosub add_timer                         'Add
        elseif BA_type=105 then             'Group x down
            c=1
            gosub Store_group
            A_Action[4]=106                         'Stop group Store
            gosub Remove_timer                      'Erase
            i_bit=0                                 'Down
            gosub add_timer                         'Add
        elseif BA_type=106 and All_stores_locked==NO then             'Group x Stop               
            c=0
            gosub Store_group
            A_Action[4]=106                         'Erase group Store from queue
            gosub Remove_timer                      'Erase
        elseif BA_type=107 then             'Group x up/stop/down/stop               
            UpDwn=1
            gosub Prep_Group_Action
        elseif BA_type=108 then             'Store up/stop/up/stop
            UpDwn=0                                 'Up/Dwn function disabled
            UpDir=1                                 'Up
            gosub Prep_Store_action
        elseif BA_type=109 then             'Store down/stop/down/stop
            UpDwn=0                                 'Up/Dwn function disabled
            UpDir=0                                 'Down
            gosub Prep_Store_action
        elseif BA_type=110 then             'Group x up/stop/up/stop               
            UpDwn=0
            UpDir=1
            gosub Prep_Group_Action
        elseif BA_type=111 then             'Group x down/stop/down/stop               
            UpDwn=0
            UpDir=0
            gosub Prep_Group_Action
        elseif BA_type=112 then             'Enable/disable Automatic stop timer when a Roller/Shutter is moved up/down
            if BA_Action=0 then
                TimerRSenabled=0                            'Automatic stop timer disabled
            else
                TimerRSenabled=1                            'Automatic stop timer enabled
            endif
        elseif BA_type=113 then             'Enable/disable Roller/shutter Lock functionality
            if BA_Action=0 then
                All_stores_locked=NO                        'Lock functionality disabled
                i2cdata=255
                eep_addr.byte0=39                           'address
                eep_addr.byte1=0                            'page
                gosub write_eeprom                           
            else
                All_stores_locked=YES                       'Lock functionality enabled
                i2cdata=0
                eep_addr.byte0=39                           'address
                eep_addr.byte1=0                            'page
                gosub write_eeprom      
            endif                                        

        elseif All_stores_overule_locked=YES then       'overule is active
            if BA_type=102 then             'Store x stop
                All_stores_overule_locked=NO
                x=BA_Action//4
                y=BA_Action/4
                gosub Store_Stop
                A_Action[4]=102                         'Stop Individual Store
                gosub Remove_timer                      'Erase
            endif  
            if BA_type=106 then             'Group x Stop
                All_stores_overule_locked=NO               
                c=0
                gosub Store_group
                A_Action[4]=106                         'Erase group Store from queue
                gosub Remove_timer                      'Erase
            endif            
        endif  
    endif        
return

Prep_Group_Action:
  c=3
  w=0
  StoreMove=0
  gosub Store_group                       'Check if any stores are moving
  c=3
  w=1
  gosub Store_group                       'Execute Stop or Up or Down
  A_Action[4]=106                           'Erase group Store from queue
  gosub Remove_timer                      'Erase
  if StoreMove=0 then gosub add_timer     'Add 
Return

Prep_Store_action:
  c=4
  x=BA_Action//4
  y=BA_Action/4
  shutter_nr=BA_action  
  gosub Store_1Action
  A_Action[4]=102                           'Stop Individual Store
  gosub Remove_timer                      'Erase
  if StoreMove=0 then gosub add_timer     'Add
return    

Remove_timer:
  A_Action[5]=BA_action
  gosub remove_timer_queue 
return

Remove_timer_queue:                         'Remove item from timer queue, A_Action[4] and A_Action[5] used
  if timer_queue_pointer>0 then
    for t=timer_queue_pointer+1 to 1 step -1
      if A_Action[4]=A_TimerType[t-1] and A_Action[5]=A_TimerAction[t-1] and (t-1)<timer_queue then     'Already exist?
        A_TimerAction[t-1]=255                                             'Remove from queue
        A_TimerType[t-1]=255
        A_TimerInput[t-1]=255
        A_TimerSeconds[t-1]=255
      endif
    next t    
  endif
return

Add_timer:
    a=BA_action
    b=BA_action/4
    c=BA_action//4
    if A_Action[4]=102 then                     'Individual store
        eep_addr.byte1 = 33+b                   'page    
        if i_bit=1 then                         'Up
            eep_addr.byte0 = 177+(c*2)  
        else                                    'down
            eep_addr.byte0 = 178+(c*2)
        endif      
    else                                      'Group store
        eep_addr.byte1 = 64                     'page
        if i_bit=1 then                         'Up
            eep_addr.byte0 = a*2
        else
            eep_addr.byte0 = (a*2)+1
        endif     
    endif
    if BA_parameter_used==NO then               'No additional parameters are used
        gosub read_eeprom
        if i2cdata<250 then
            A_Action[3]=i2cdata                       'set seconds
        else
            A_Action[3]=239  
        endif
    else
        if BA_parameter<251 then
            A_Action[3]=1+BA_parameter.byte0 
        else
            A_Action[3]=239
        endif    
    endif    
    A_Action[6]=240  
    gosub add_timer_queue2
return

Store_group:
    if controller_out_RS>0 and controller_out_RS<MAX_RS_MODULES then
        for ic=1 to controller_out_RS           'Check all Shutter/Store controllers in Large Installation mode
            for a=0 to 3                          'Check all stores per module
                for b=0 to 1                        'Check the 2 groups per store
                    eep_addr.byte1 = 63                   'page
                    eep_addr.byte0 = ((ic-1)*8)+(a*2)+b
                    Gosub read_eeprom
                    if i2cdata=BA_action then       'Group found, execute Up for that store
                        x=(((ic-1)*4)+a)//4
                        y=(((ic-1)*4)+a)/4
                        shutter_nr=(((ic-1)*4)+a)
                        if c=2 then
                            gosub Store_up
                        elseif c=1 then
                            gosub Store_down
                        elseif c=3 then
                            gosub store_1action 
                        else
                            gosub Store_Stop
                        endif      
                    endif
                next b
            next a
        next ic
        if c=3 and w=1 then                         'group up/stop/down/stop has been performed
            if StoreMove=0 then
                eep_addr.byte0=BA_Action                    'address
                eep_addr.byte1=234                          'page
                gosub read_eeprom                             
                'if A_ValBit[90+v]=0 then
                if i2cdata==0 then
                    'A_ValBit[90+v]=1
                    i2cdata=1
                    gosub Write_GroupDirection_in_eeprom
                else
                    'A_ValBit[90+v]=0
                    i2cdata=0
                    gosub Write_GroupDirection_in_eeprom
                endif
                ValBitNr=90+v
                gosub send_EV1    
            endif
        endif
        c=0
    endif  
return

Store_1Action:
    z=%00000011
    z=z<<(x*2)
    u=A_OutputRS[y]&z
    v=BA_action
    if c=3 and w=0 then                       'Check if any store is moving (group only)
        if u<>0 then                            'Store is moving
            StoreMove=1
        endif
    elseif c=3 and w=1 then                   'Execute Action (stop, or up or down)(group only)
        if StoreMove=1 then
            gosub Store_Stop
        else
            if UpDwn=1 then
                eep_addr.byte0=BA_Action                    'address
                eep_addr.byte1=234                          'page
                gosub read_eeprom             
                'if A_ValBit[90+v]=0 then
                if i2cdata==0 then      
                    gosub Store_Up
                else
                    gosub store_down
                endif
            else
                if UpDir=1 then
                    gosub Store_Up
                else
                    gosub store_down
                endif
            endif    
        endif
    else                                      'Execute Action (stop, or up or down)(Non group)
        x=BA_action//4
        y=BA_action/4
        z=%00000011
        z=z<<(x*2)    
        u=A_OutputRS[y]&z
        if u=0 then                             'Store is not moving
            StoreMove=0
            if UpDwn=1 then
                eep_addr.byte0=BA_Action                    'address
                eep_addr.byte1=233                          'page
                gosub read_eeprom                
                'if A_ValBit[120+v]=0 then
                if i2cdata==0 then                              
                    gosub Store_Up
                    'A_ValBit[120+v]=1
                else
                    gosub store_down
                    'A_ValBit[120+v]=0        
                endif
                'ValBitNr=120+v
                'gosub send_EV1
            else
                if UpDir=1 then
                    gosub Store_Up
                else
                    gosub store_down
                endif     
            endif    
        else                                      'Store is moving
            StoreMove=1
            gosub Store_Stop
        endif
    endif   
return

Write_StoreDirection_in_eeprom:
    if BA_parameter_used==NO then
        eep_addr.byte0=shutter_nr                   'address
        eep_addr.byte1=233                          'page
        gosub write_eeprom
    endif
return

Write_GroupDirection_in_eeprom:
    if BA_parameter_used==NO then
        eep_addr.byte0=BA_Action                    'address
        eep_addr.byte1=234                          'page
        gosub write_eeprom
    endif
return

Get_UpDownConfig:
  eep_addr.byte1 = 33+y     'page
  eep_addr.byte0 = 185+x
  Gosub read_eeprom
  if i2cdata.bit0=i_bit then
    z=z<<(x*2)
  else
    z=z<<((x*2)+1)
  endif  
return

Store_Up:
    if All_stores_locked==NO then
        gosub Store_stop
        i2cdata=1
        gosub Write_StoreDirection_in_eeprom    
        i_bit=1
        z=%00000001
        gosub Get_UpDownConfig  
        if y<MAX_RS_MODULES then A_OutputRS[y]=A_OutputRS[y]|z
        write_yes_rs=1
        if y<MAX_RS_MODULES then A_WriteYesModRS[y]=1
    endif      
return

Store_Down:
    if All_stores_locked==NO then
        gosub Store_stop
        i2cdata=0
        gosub Write_StoreDirection_in_eeprom    
        i_bit=0
        z=%00000001
        gosub Get_UpDownConfig  
        if y<MAX_RS_MODULES then A_OutputRS[y]=A_OutputRS[y]|z
        write_yes_rs=1
        if y<MAX_RS_MODULES then A_WriteYesModRS[y]=1
    endif     
return

Store_Stop:
    z=%00000011
    z=z<<(x*2)
    z=~z
    if y<MAX_RS_MODULES then A_OutputRS[y]=A_OutputRS[y]&z    
    write_yes_rs=1
    if y<MAX_RS_MODULES then A_WriteYesModRS[y]=1  
return

'Set_Cooling:
'  gosub Thermostat_output_off       'Switch off all Thermostat and pump outputs in the current mode (cooling or heating)
'  if BA_action=0 then         'Cooling Disabled, Heating enabled
'    thermostatCooling=0
'    thermostatmode.bit4=0
'  elseif BA_action=1 then     'Cooling Enabled (Heating disabled) but Cooling OFF
'    thermostatCooling=1
'    thermostatmode.bit4=1
'    thermostatmode.bit7=0
'    thermostatOn=0
'    for u=0 to (MAX_THERMOSTATS-1)      'Also switch OFF RTD-10 Airco units
'      A_Airco[u]=0
'    next u
'    gosub OnOffAirco  
'  else                              'Cooling Enabled (Heating disabled) and Cooling ON
'    thermostatCooling=1
'    thermostatmode.bit4=1
'    thermostatOn=1
'    thermostatmode.bit7=1    
'  endif
'  gosub write_thermostatmode
'  gosub read_thermostat_par
'  gosub Set_CoolingHeating
'return

'Set_airco:
'  u=BA_action  
'  if BA_action<MAX_THERMOSTATS then        'Enable Airco
'    if u<MAX_THERMOSTATS then A_Airco[u]=1
'    PidCalcCounter=u    
'    gosub RTD10    
'  endif
'  if BA_action>99 and BA_action<132 then        'Disable Airco
'    if (u-100)<MAX_THERMOSTATS then A_Airco[u-100]=0
'    PidCalcCounter=u-100   
'    gosub RTD10    
'  endif   
'return

'OnOffAirco:        'Switch ON or OFF Airco RTD-10 when changing mode
'  for PidCalcCounter=0 to (MAX_THERMOSTATS-1)
'    gosub RTD10
'  next PidCalcCounter
'return

'Set_CoolingHeating:
'  ok=0
'  for b=0 to 3
'    a=(thermostatCooling)*8
'    eep_addr.byte1 = 199            'page
'    eep_addr.byte0 = a+(b*2)
'    Gosub read_eeprom
'    if i2cdata<>255 then
'      A_DigitTotal[0]=i2cdata
'      eep_addr.byte0 = a+(b*2)+1
'      Gosub read_eeprom
'      if i2cdata=0 then             'Output off
'        digitcount=1
'        gosub output_off
'      else                          'Output on
'        digitcount=2
'        A_DigitTotal[1]=i2cdata
'        gosub output_on
'      endif  
'    endif
'  next b
'  ok=1  
'return

' OUTPUT ON/OFF Action --------------------------------------------------------

Output_OnOff:
  Digitcount=1
  A_DigitTotal[0]=BA_action
  A_DigitTotal[1]=0
  q=BA_action
  if BA_type=160 then                 'output off
    gosub output_off
  elseif BA_type=161 then             'output On
    gosub output_on    
  elseif BA_type=162 and q<240 then   'output toggle
    gosub Toggle_lights      
  elseif BA_type=163 then             'all lights off
    level=255
    gosub all_lights_off 
  elseif BA_type=164 then             'all outputs off
    gosub all_outputs_off
  elseif BA_type=165 and q<MAX_OUTPUTS then   'Light on at minimum dimmer level
    A_DimmerValue[q]=dim_minimum
    dimmer_value_eeprom_write=YES
    gosub output_on
  elseif BA_type=166 and q<MAX_OUTPUTS then   'Light on at maximum dimmer level
    A_DimmerValue[q]=63
    dimmer_value_eeprom_write=YES
    gosub output_on
  elseif BA_type=167 and q<MAX_OUTPUTS then   'Light on, decrease dimmer value with 5
    A_DimmerValue[q]=A_DimmerValue[q]+5
    if A_DimmerValue[q]>63 then
      A_DimmerValue[q]=63
    endif
    dimmer_value_eeprom_write=YES
    gosub output_on
  elseif BA_type=168 and q<MAX_OUTPUTS then   'Light on, increase dimmer value with 5
    if A_DimmerValue[q]<10 or (A_DimmerValue[q]-5)<dim_minimum then
      A_DimmerValue[q]=dim_minimum
    else
      A_DimmerValue[q]=A_DimmerValue[q]-5
    endif
    dimmer_value_eeprom_write=YES
    gosub output_on
  elseif BA_type=169 and q<MAX_OUTPUTS then   'set dimmer value at minimum
    A_DimmerValue[q]=dim_minimum
    dimmer_value_eeprom_write=YES               
  elseif BA_type=170 and q<MAX_OUTPUTS then   'set dimmer value at maximum
    A_DimmerValue[q]=63
    dimmer_value_eeprom_write=YES
  elseif BA_type=171 then             'all lights off of a certain floor level or group
    level=q
    gosub all_lights_off      
  elseif BA_type=172 then             'all lights on of a certain floor level or group
    level=q
    gosub all_lights_on 
  elseif BA_type=173 then             'toggle all lights of a certain floor level or group
    level=q
    gosub all_lights_toggle 
  elseif BA_type>175 and BA_type<185 and q<MAX_OUTPUTS then  'Light on at 10%-90%
    A_DimmerValue[q]=(BA_type-175)*6
    dimmer_value_eeprom_write=YES
    gosub output_on 
  elseif BA_type>184 and BA_type<195 and q<MAX_OUTPUTS then  'Toggle Light at 10%-100%
    A_DimmerValue[q]=(BA_type-184)*6
    dimmer_value_eeprom_write=YES
    gosub Toggle_lights
  elseif BA_type>194 and BA_type<201 and q<MAX_OUTPUTS then  'Switch on light with timer setting between 2m30 and 1h20
    gosub set_output_on    
  elseif BA_type>200 and BA_type<207 and q<MAX_OUTPUTS then  'Switch on light with timer setting between 2m30 and 1h20 but doesn't overule when light is already on
    gosub check_output                                           'check if output is on, q must contain output nr
    if z.bit0=0 then gosub set_output_on                         'if output is off, switch it on and set timer              
  endif          
return

check_output:
  'output number must be A_Output in q, result in z.bit0
  x=q//8
  y=q/8
  z=A_Output[y]>>x
return

Set_Output_on:
  digitcount=3
  A_DigitTotal[1]=A_DimmerValue[q]                                 'dimmer value
  if BA_type>200 then
    A_DigitTotal[2]=(BA_type-200)*(BA_type-199)*75    'timer value
  else
    A_DigitTotal[2]=(BA_type-194)*(BA_type-193)*75    'timer value
  endif
  gosub output_on
return


Toggle_lights:
  if ToggleFollowON=1 and ToggleFollowActive=1 then
    if ToggleFollowData=1 then
      gosub output_on
    else
      gosub output_off
    endif
  endif
  if ToggleFollowON=0 or (ToggleFollowON=1 and ToggleFollowActive=0) then
    write_yes=1                             'write to output modules
    if q<MAX_OUTPUTS then 
      z=(A_Output[q/8])>>(q//8)
      if z.bit0=1 then                          'Toggle Output
         gosub output_off
      else
         gosub output_on
      endif      
      A_OutUpdate[q]=1
      if ToggleFollowON=1 then
        ToggleFollowActive=1
        ToggleFollowData=A_Output[q/8]>>(q//8)
      endif    
      gosub Dimmer_Group_follow
    endif     
  endif
  gosub check_output     'check if output is on, q must contain output nr, result in z.bit0               
  if z.bit0=0 then       'Output is off
    timer=q
    gosub timer_value_read
    if q<MAX_OUTPUTS then A_TimerCd[q]=timer    
  endif 
  OdCode=5
  OdOutputNr=q
  gosub Output_debug  
return



' Group Action ----------------------------------------------------------------

group_action:
'Queue_pointer is used from check_queue routine
  if BA_action<160 then               'page 67-86 in eeprom
    eep_addr.byte1 = 67 + (BA_action/8)
    x=BA_action - (8*(BA_action/8))  
    for t=0 to 15
      eep_addr.byte0 = (x*32)+(t*2)
      Gosub read_eeprom 
      a=i2cdata                             'read type from eeprom 
      eep_addr.byte0 = (x*32)+(t*2)+1
      Gosub read_eeprom 
      b=i2cdata                             'read Action from eeprom
      if a<255 then                         'add intelligent Action to the queue
        'A_QueueType[queue_end]=a
        'A_QueueAction[queue_end]=b
        BA_type_queue=a
        BA_action_queue=b
        gosub Increase_queue_pointer      
      endif             
    next t    
  endif
return


' Simple decision -------------------------------------------------------------

simple_decision:
  if BA_action<192 then               'page 87-92 in eeprom
    eep_addr.byte1 = 87 + (BA_action/32)
    x=BA_action - (32*(BA_action/32)) 
    for t=0 to 7
      eep_addr.byte0 = x*8+t
      Gosub read_eeprom 
      A_Action[t]=i2cdata                     'read A_Action from eeprom 
    next t
    a=A_Action[0]                             'config byte
    d=A_Action[1]
    x=A_Action[1]/8
    y=A_Action[1]//8
    if a.bit2=0 and a.bit1=0 and a.bit0=0 then      'check output  
      b=A_Output[x]>>y                           'put selected bit on BIT0
      b=b & %00000001                       'all bits on 0 except BIT0
      gosub compare_decision
    elseif a.bit2=0 and a.bit1=0 and a.bit0=1 then  'check input  
      b=A_Input[x]>>y                           'put selected bit on BIT0
      b=b & %00000001                       'all bits on 0 except BIT0     
      gosub compare_decision
    elseif a.bit2=0 and a.bit1=1 and a.bit0=0 then  'check Temperature  
      b=A_Temperature[d]
      gosub compare_decision
    elseif a.bit2=0 and a.bit1=1 and a.bit0=1 then  'check brigtness level  
      b=A_ldr[d]
      gosub compare_decision
    elseif a.bit2=1 and a.bit1=0 and a.bit0=0 then  'check press cycles in seconds 
      b=A_Input[x]>>y                           'put selected bit on BIT0
      if b.bit0=1 and timer_queue_pointer<(timer_queue-1) then  'selected input is active -> add Action in the timer queue
        A_Action[6]=CurrentInput      
        Gosub add_timer_queue2             
      endif
    elseif a.bit2=1 and a.bit1=1 and a.bit0=1 then  'check validation bit  
      b=A_ValBit[d]     
      gosub compare_decision
    endif   
  endif
return


compare_decision:
  if a.bit4=0 and a.bit3=0 then             'equal with data field
    if b=A_Action[3] then
      decision_new=1                        'true
      gosub compare
    else
      decision_new=0                        'false
      gosub compare
    endif
  elseif a.bit4=0 and a.bit3=1 then         'higher than data field  
    if b>A_Action[3] then
      decision_new=1                        'true
      gosub compare
    else
      decision_new=0                        'false
      gosub compare
    endif
  elseif a.bit4=1 and a.bit3=0 then         'lower than data field   
    if b<A_Action[3] then
      decision_new=1                        'true
      gosub compare
    else
      decision_new=0                        'false
      gosub compare
    endif
  endif     
return

compare:
  if BA_type.bit4=1 then                  'perform AND or OR function with pervious decision
    if BA_type.bit5=1 then                'perform AND  
      decision_new=decision_old&decision_new
    else                                    'perform OR   
      decision_new=decision_old|decision_new 
    endif
  endif
  if decision_new=1 then                    'true
    gosub true_action
    decision_old=decision_new
  else                                      'false
    gosub false_action
    decision_old=decision_new
  endif
return

true_action:                                'add "true" Action in the queue
  if BA_type.bit3=1 then                  'perform true Action
    'A_QueueType[queue_end]=A_Action[4]
    'A_QueueAction[queue_end]=A_Action[5]
    BA_type_queue=A_Action[4]
    BA_action_queue=A_Action[5]    
    gosub Increase_queue_pointer
  endif 
return

false_action:                               'add "false" Action in the queus
  if BA_type.bit3=1 then                  'perform false Action
    'A_QueueType[queue_end]=A_Action[6]
    'A_QueueAction[queue_end]=A_Action[7]
    BA_type_queue=A_Action[6]
    BA_action_queue=A_Action[7]    
    gosub Increase_queue_pointer   
  endif
return

' Simple Action ---------------------------------------------------------------

simple_action:
'queue_pointer is used from check_queue routine
  if BA_action<204 then               'page 93-108 in eeprom
    eep_addr.byte1 = 93 + (BA_action/51)
    x=BA_action - (51*(BA_action/51))
    for t=0 to 4
      eep_addr.byte0 = x*5+t
      Gosub read_eeprom 
      A_Action[t]=i2cdata                     'read Action from eeprom    
    next t 
    b=A_Action[0]                             'config byte
    a=A_Action[1]
    x=a/8
    z=a//8
    y=%00000001<<z               
    if a<240 then                           'Action from 0 - 239
      write_yes=1
      if a<MAX_OUTPUTS then 
        A_WriteYesMod[a/8]=OutputNrWrites
        A_OutUpdate[a]=1
        if b.bit1=0 and b.bit0=0 then         'Put output off 
          y=~y                                'invert
          if x<MAX_OUTPUT_MODULES then A_Output[x]=A_Output[x]&y
          OdCode=6                            'Output debug code
          OdOutputNr=a
          gosub Output_debug                  'Display on console when outbug debug is on    
        elseif b.bit1=0 and b.bit0=1 then     'put output on and select timer
          if x<MAX_OUTPUT_MODULES then A_Output[x]=A_Output[x]|y                     'put selected output on       
          gosub simple_action_on
          OdCode=7                            'Output debug code
          OdOutputNr=a
          gosub Output_debug                  'Display on console when outbug debug is on        
        elseif b.bit1=1 and b.bit0=0 then     'Toggle output
          if x<MAX_OUTPUT_MODULES then A_Output[x]=A_Output[x]^y
          c=A_Output[x]
          c=c>>z
          if c.bit0=0 then                    'output is toggled off
            'TBC
          endif
          if c.bit0=1 then                    'output is toggled on
            gosub simple_action_on
          endif
          OdCode=8                            'Output debug code
          OdOutputNr=a
          gosub Output_debug                  'Display on console when outbug debug is on 
        endif  
      endif       
    endif
    if b.bit1=1 and b.bit0=1 then           'set or clear validation bit
      gosub validation_bit
    endif
    if a=241 and b.bit1=0 and b.bit0=0 then 'all outputs off   
      gosub all_outputs_off
      OdCode=9                              'Output debug code
      OdOutputNr=255
      gosub Output_debug                    'Display on console when outbug debug is on       
    endif
    if a=242 and b.bit1=0 and b.bit0=0 then 'all lights off   
      level=255
      gosub all_lights_off
      OdCode=10                             'Output debug code
      OdOutputNr=255
      gosub Output_debug                    'Display on console when outbug debug is on 
    endif
    if a>242 and a<249 and b.bit1=0 and b.bit0=0 then 'all lights off of a certain floor (243: floor0, 244: floor1, etc)   
      level=a-243
      gosub all_lights_off
      OdCode=11                             'Output debug code
      OdOutputNr=255
      gosub Output_debug                    'Display on console when outbug debug is on 
    endif            
  endif 
return

validation_bit:
  if b.bit5=0 and b.bit4=0 then             'clear validation bit
    A_ValBit[a]=0
  elseif b.bit5=0 and b.bit4=1 then         'set validation bit
    A_ValBit[a]=1
  elseif b.bit5=1 and b.bit4=0 then         'toggle validation bit
    A_ValBit[a]=~A_ValBit[a]  
  endif
  ValBitNr=a
  gosub send_EV1  
return

simple_action_on:
  if a<MAX_OUTPUTS then
    if A_ModID0[30+(a/8)]="D" or A_ModID0[30+(a/8)]="d" then             'only when dimmer
      A_DimmerValue[a]=A_Action[4]
      dimmer_value_eeprom_write=YES
    else
      A_DimmerValue[a]=63
    endif
    if b.bit3=1 then             
      e_word.byte0=A_Action[2]                  'timer LSB
      e_word.byte1=A_Action[3]                  'timer MSB
      A_TimerCd[a]=e_word                      'put timer value
    endif
  endif  
return

'Scheduled Action ------------------------------------------------

scheduled_action:
'queue_pointer is used from check_queue routine
  if BA_action<102 then               'page 113-114 in eeprom
    eep_addr.byte1 = 113 + (BA_action/51)
    x=BA_action - (51*(BA_action/51))    
    for t=0 to 4
      eep_addr.byte0 = x*5+t
      Gosub read_eeprom 
      A_Action[t]=i2cdata                     'read Action from eeprom    
    next t 
    'put scheduled Action in scheduled Action queue
    if A_Action[0]<25 and A_Action[1]<60 then   'hour and minute must be valid,if =24, perform every minute
      gosub add_schedule_queue
    endif          
  endif  
return

add_schedule_queue:
  'queue_pointer is used from check_queue routine
  if Sched_queue_counter<sched_queue_max then
    t=BA_action
    if t<Sched_queue_max then
      A_SchedHour[t]=A_Action[0]
      A_SchedMinute[t]=A_Action[1]
      A_SchedDay[t]=A_Action[2]
      A_SchedType[t]=A_Action[3]
      A_SchedAction[t]=A_Action[4]
      Sched_queue_counter=Sched_queue_counter+1
    endif  
  else
    'error queue overflow
    A_ErrorID[0]= 0                          'Error code for queue overflow
    A_ErrorID[1]= 0
    A_ErrorID[2]= 0
    A_ErrorID[3]= 0
    error_code = 24
    gosub send_error 
  endif 
return

all_lights_off:                             'if level=255->All lights off, if level<255, only (floor)level will be switched off
  cf=160                                    'Lights off
  gosub Lights_on_off
return

all_lights_on:                              'if level=255->All lights on, if level<255, only (floor)level or group will be switched on
  cf=161                                    'Lights on
  gosub Lights_on_off
return

all_lights_toggle:
  cf=162                                    'Lights toggle
  gosub Lights_on_off                       'first time to test to see if any lights are on (toggle all on or all off)
  if z1=1 then                              'at least one light on
    cf=160                                  'turn off lights
  else
    cf=161                                  'turn on lights
  endif
  gosub Lights_on_off
return

lights_on_off:
  z1=0
  if controller_out<MAX_OUTPUT_MODULES then
    for jf=0 to (controller_out-1)
      for xf=0 to 7
        yf=A_Output[jf]
        zf=yf>>xf       
        eep_addr.byte1=33+jf
        eep_addr.byte0=157+xf                 'address (Floor Level)
        gosub read_eeprom
        af=i2cdata
        eep_addr.byte0=149+xf                 'address (Output type: 0-127->output, 128-255->Light)
        gosub read_eeprom
        bf=i2cdata 
        if (level=af or level=255) and bf>127 then  'switch light
          if cf=160 or cf=161 then
            A_DigitTotal[0]=(jf*8)+xf
            digitcount=1
            A_DigitTotal[1]=0
            if cf=160 then 
              gosub output_off
            else
              gosub output_on
            endif  
          else                                'for toggle lights, check if light is on
            if zf.bit0=1 then                 'light is on
              z1=1
              xf=7
              jf=controller_out-1
            endif  
          endif    
        endif        
      next xf
    next jf
  endif  
return

all_outputs_off:
  write_yes=1                            'write outputs
  for u=0 to MAX_OUTPUTS-1
    A_OutUpdate[u]=1
  next u
  if controller_out<=MAX_OUTPUT_MODULES then  
    for u=1 to controller_out
      A_Output[u-1]=0                              'Put all outputs into off state
      if u<MAX_OUTPUT_MODULES+1 then A_WriteYesMod[u-1]=OutputNrWrites
    next u
  endif    
return

all_outputs_off_rs:
  if controller_out_RS<MAX_RS_MODULES then
    write_yes_rs=1
    for u=1 to controller_out_RS
      A_OutputRS[u-1]=0                            'Put all outputs into off state
      if u<MAX_RS_MODULES+1 then A_WriteYesModRS[u-1]=1
    next u
  endif   
return

RO_Linux2:
  if A_WriteYesMod[ic-1]=1 then         'only changes in module will be communicated
    x=(ic-1)*8
    Hserout2 ["RO",cid,ic-1,0,0,0,A_Output[ic-1],A_DimmerValue[x],A_DimmerValue[x+1],A_DimmerValue[x+2],A_DimmerValue[x+3],A_DimmerValue[x+4],A_DimmerValue[x+5],A_DimmerValue[x+6],A_DimmerValue[x+7],13,10]
  endif
  cid=0
return

SO_Linux2:
  if mode_com=1 then Hserout2 ["SO",cid,ic-1,0,0,0,A_OutputRS[ic-1],All_stores_locked,13,10]
return

'For the complete error list see http://wiki.openmotics.com/index.php/Error_Codes
send_error:                                 '"ER
'if A_ErrorBit[ErrorTmp]=0 then                'no error on selected input/output
if A_ErrorCount[ErrorTmp]<2 then
  low led_red                                       
  if mode_com=1 then                        'only in advanced mode
    gosub empty_e
    A_e[0]="E"
    A_e[1]="R"
    A_e[2]=0
    A_e[3]=error_code
    A_e[4]=A_ErrorID[0]
    A_e[5]=A_ErrorID[1]
    A_e[6]=A_ErrorID[2]
    A_e[7]=A_ErrorID[3]
    gosub send_api        
  else
    if ErrorTmp<60 then
      hserout2 ["ERROR ",dec error_code," ID: ",dec3 A_ErrorID[0],".",dec3 A_ErrorID[1],".",dec3 A_ErrorID[2],".",dec3 A_ErrorID[3],13,10]
    else
      hserout2 ["ERROR ",dec error_code,13,10]
    endif
  endif
endif
if A_ErrorCount[ErrorTmp]>(ErrorMax-1) then          'check if module must be disabled
  if ErrorTmp<MAX_ERRORS then A_ErrorBit[ErrorTmp]=1
endif 
error_code=255
cid=0
ErrorTmp=MAX_ERRORS-2                                 'not used module -> this code will be used for non input/output related errors
A_ErrorBit[ErrorTmp]=0  
return

send_ST:                                    '"ST
  x=version
  y=firmware
  z=built
  a=hardware
  if A_SerString[3]="W" then
    OledEeprom.Byte1=A_SerString[4]
    OledEeprom.byte0=0
  endif
  gosub empty_e
  A_e[0]="S"
  A_e[1]="T"
  A_e[2]=cid
  A_e[3]=seconds
  A_e[4]=minutes
  A_e[5]=hours
  A_e[6]=days
  if A_SerString[3]="R" or A_SerString[3]="W" then
    A_e[7]="S"
    A_e[8]=OledEeprom.byte1
    A_e[9]=OledEeprom.Byte0    
  else
    A_e[7]=0
    A_e[8]=0
    A_e[9]=0
  endif
  A_e[10]=0  
  A_e[11]=mode
  A_e[12]=x
  A_e[13]=y
  A_e[14]=z
  A_e[15]=a  
  gosub send_api   
  cid=0
return

send_rt:
  gosub empty_e
  A_e[0]="r"
  A_e[1]="t"
  A_e[2]=cid
  A_e[3]=seconds
  A_e[4]=minutes
  A_e[5]=hours
  A_e[6]=days
  A_e[7]=date
  A_e[8]=month
  A_e[9]=year      
  gosub send_api   
  cid=0
return

send_AE:
  if mode_com=1 then
    gosub empty_e
    A_e[0]="A"
    A_e[1]="E"
    A_e[2]=cid
    A_e[3]=0
    A_e[4]="O"
    A_e[5]="K"
    gosub send_api     
  endif
  cid=0
return

send_AE2:
  if mode_com=1 then
    gosub empty_e
    A_e[0]="a"
    A_e[1]="e"
    A_e[2]=cid
    A_e[3]=0
    A_e[4]="O"
    A_e[5]="K"
    gosub send_api     
  endif
  cid=0
return

send_EV:
  if mode_com=1 then
    gosub empty_e
    cid=0
    A_e[0]="E"
    A_e[1]="V"
    A_e[2]=cid    'CID=0
    A_e[3]=0
    A_e[4]=BA_action
    gosub send_api     
  endif
Return

send_EV1:
  if mode_com=1 then
    gosub empty_e
    cid=0
    A_e[0]="E"
    A_e[1]="V"
    A_e[2]=cid    'CID=0
    A_e[3]=1
    A_e[4]=ValBitNr
    A_e[5]=A_ValBit[ValBitNr]
    gosub send_api     
  endif
Return

send_EV2:
  if mode_com=1 then
    gosub empty_e
    cid=0
    A_e[0]="E"
    A_e[1]="V"
    A_e[2]=0    'CID=0
    A_e[3]=2
    A_e[4]=BA_type
    A_e[5]=BA_action
    gosub send_api     
  endif
Return

send_AD:
  if mode_com=1 then
    gosub empty_e
    A_e[0]="A"
    A_e[1]="D"
    A_e[2]=cid
    A_e[3]=A_SerString[3]
    A_e[4]=A_SerString[4]
    A_e[5]=A_SerString[5]
    A_e[6]=A_SerString[6]
    A_e[7]="A"
    gosub send_api     
  endif
  cid=0
return

send_crc:
  Hserout2 ["C",CRC.byte1,CRC.byte0]
return

send_OO:
  Hserout2 ["OO"]
  gosub send_lightsOn
return

send_OL:
  gosub calculate_NrofOutputs
  Hserout2 ["OL",cid,NrOutputsOn]
  gosub send_lightsOn
  cid=0
return

send_PL:
  crc=0
  Hserout2 ["PL",cid]
  for ic=0 to (PULSECOUNTERS-1)
    t_word=A_PulseCounter[ic]
    crc=crc+t_word.byte1+t_word.byte0
    hserout2 [t_word.byte1,t_word.byte0]
  next ic
  gosub send_crc    
  gosub display_LF_CR
  cid=0
return

send_IL:
  Hserout2 ["IL",0,v,q,press_state]
  gosub display_LF_CR
  cid=0
return

calculate_NrofOutputs:
  NrOutputsOn=0
  for j=1 to controller_out                'check all output devices
    for t=0 to 7                            'check all outputs of a selected device
      x=A_Output(j-1)>>t
      y=((j-1)*8)+t
      if x.bit0=1 then                      'selected output is ON, remember (var A_TimerSet) to put back the timer value
        NrOutputsOn=NrOutputsOn+1
      endif  
    next t
  next j
return

send_lightsOn:
  for j=0 to (controller_out-1)
    if A_Output[j]>0 then
      y=A_Output[j]
      for x=0 to 7
        z=y>>x
        if z.bit0=1 then
          Hserout2 [(j*8)+x,A_DimmerValue[(j*8)+x]]
        endif
      next x
    endif
  next j
  gosub display_LF_CR
return

instr_EL:
  eep_addr.byte1=A_SerString[3]               'Page to read
  hserout2 ["EL",CID,eep_addr.byte1]
  for x=0 to 255
    eep_addr.byte0=x
    gosub read_eeprom
    gosub print_i2cdata
  next x
  gosub display_LF_CR
return

instr_VL:
  CRC=0
  hserout2 ["VL",CID]
  for x=0 to 31
    i2cdata=A_VirtualSensor[x]
    crc=crc+i2cdata
    gosub print_i2cdata
  next x
  gosub send_crc
  gosub display_LF_CR
  cid=0
return

'instr_pL:    '"pL"
'  CRC=ThermostatCooling
'  hserout2 ["pL",CID,ThermostatCooling]
'  for x=0 to (MAX_THERMOSTATS-1)
'    i2cdata=A_PermanentManual[x+(MAX_THERMOSTATS*ThermostatCooling)]
'    crc=crc+i2cdata
'    gosub print_i2cdata
'  next x
'  gosub send_crc
'  gosub display_LF_CR
'  cid=0
'return

print_i2cdata:
  hserout2 [i2cdata]
return

send_reset:
  gosub empty_e
  A_e[0]="r"
  A_e[1]="e"
  A_e[2]=cid
  gosub send_api 
return

send_ws:
  if mode_com=1 then
    gosub empty_e
    A_e[0]="w"
    A_e[1]="s"
    A_e[2]=cid
    A_e[3]=A_SerString[3]
    A_e[4]=A_SerString[4]
    A_e[5]=A_SerString[5]
    gosub send_api     
  endif
return

'send_RS:
'  if mode_com=1 then
'    CRC=0
'    x=A_ThermostatSensor[pid]
'    a=A_Thermostat[pid]
'    c=A_Thermostat2[pid]
'    CRC=pid+A_Temperature[x]+A_Setpt[pid]
'    if CIDused=0 then
'      Hserout2 ["RS"]
'    else
'      Hserout2 ["rs",cid]
'    endif
'    hserout2 [pid,A_Temperature[x],A_Setpt[pid]]
'    eep_addr.byte1 = 142+(59*thermostatCooling)       'Page 142 o 201
'    for ic=1 to 6
'      eep_addr.byte0 = (32*ic)+pid
'      gosub read_eeprom
'      gosub print_i2cdata
'      CRC=CRC+i2cdata
'    next ic
'    CRC=CRC+x+a+c+A_DimmerValue[a]+A_DimmerValue[c]+A_Temperature[outside_sensor]+ThermostatMode
'    Hserout2 [x,a,c,A_DimmerValue[a],A_DimmerValue[c],A_Temperature[outside_sensor],ThermostatMode]
'    for ic=0 to 15
'      eep_addr.byte1 = 187 + (pid/16)+(17*thermostatCooling)      'Start page 187 or 204
'      eep_addr.byte0 = ((pid//16)*16)+ic
'      Gosub read_eeprom     
'      b=i2cdata
'      if b>126 then
'        b=32                                'space
'      endif
'      CRC=CRC+b
'      Hserout2 [b]   
'    next ic
'    gosub PID_read
'    CRC=CRC+Kp+Ki+Kd+IntThresh+Temp_threshold+days+hours+minutes
'    Hserout2 [Kp,Ki,Kd,IntThresh,Temp_threshold,days,hours,minutes]
'    for ic=0 to 6                           'retrieve timings A_Output of eeprom
'      for t=0 to 3
'        eep_addr.byte1 = 189 + (ic/2)+(17*thermostatCooling)      'Start page 189 or 206
'        eep_addr.byte0 = (128*(ic//2))+(pid*4)+t
'        Gosub read_eeprom  
'        CRC=CRC+i2cdata   
'        gosub print_i2cdata     
'      next t
'    next ic
'    if CIDused=1 then                       '"rs" instruction is used
'      hserout2 ["T"]
'      CRC=CRC+"T"
'      a=pid
'      for b=0 to 2                          'Day1/Day2/Night
'        for c=1 to 7                        'Retrieve Temperature Mon-Sun
'          gosub Thermostat_day1_day2 
'          CRC=CRC+i2cdata   
'          gosub print_i2cdata                
'        next c
'      next b       
'    endif
'    gosub send_crc
'    gosub display_LF_CR   
'  endif
'  cid=0
'return


'------------------------------------------------------------------------------
' RS232: API and CLI
' For API documentation see http://wiki.openmotics.com/index.php/API_Reference_Guide
' For CLI documentation see http://wiki.openmotics.com/index.php/CLI_Reference_Guide
'------------------------------------------------------------------------------              

Rs232_interprete: 
  if RCSTA2.4=0 then                        'Data Ready to be Interpreted
    low led_red
    cid=A_SerString[2]                        'cid code
    if Mode_com=1 then                      'API mode      
      if (A_SerString[1] = "l") then          'Read list (Thermostat, Temperature, humidity or Brightness,error)
        gosub instr_xl                                              '"tl      
      elseif (A_SerString[1] = "L") then      'other type of List 
        gosub instr_xL2       
      elseif (A_SerString[0] = "F") then      'Slave Firmware instruction set 
        if RS485busy=NO then                 'wait until bus is free
          gosub instr_F
        else                                'RS485 bus is not free yet
          goto end_rs232_interprete
        endif                                                                 
'      elseif (A_SerString[0] = "r") and (A_SerString[1] = "s") then     'read Thermostat data, detailed information of 1 Thermostat  
'        gosub instr_RS2                                             '"rs        
      elseif (A_SerString[0] = "r") and (A_SerString[1] = "o") then     'read output Data, detailed information of 1 output 
        CIDused=1                                                   '"ro
        cid=A_SerString[2]
        x=A_SerString[3]
        gosub send_RD
      elseif (A_SerString[0] = "w") and (A_SerString[1] = "d") then     'Write dimmer output 
        gosub instr_wd2                                             '"wd
      elseif (A_SerString[0] = "V") and (A_SerString[1] = "S") then     'Write Virtual Sensor data 
        gosub instr_VS                                              '"VS        
      elseif (A_SerString[0] = "B") and (A_SerString[1] = "A") then     'Execute Basic Action 
        gosub instr_BA                                              '"BA                                         
'      elseif (A_SerString[0] = "T") and (A_SerString[1] = "M") then     'Read Thermostat Mode
'        gosub instr_TM                                              '"TM
'      elseif (A_SerString[0] = "R") and (A_SerString[1] = "S") then     'read Thermostat data, detailed information of 1 Thermostat  
'        gosub instr_RS                                              '"RS                                        
      elseif (A_SerString[0] = "O") and (A_SerString[1] = "O") then     'read output Data, Give list of outputs that are ON 
        gosub send_OO                                               '"OO    
      elseif (A_SerString[0] = "R") and (A_SerString[1] = "D") then     'read output Data, detailed information of 1 output 
        CIDused=0                                                   '"RD
        gosub instr_RD     
      elseif (A_SerString[0] = "W") and (A_SerString[1] = "D") then     'Write output data, detailed information of 1 output
        gosub instr_WD                                              '"WD    
'      elseif (A_SerString[0] = "W") and (A_SerString[1] = "S") then     'Write Thermostat data, detailed information of 1 Thermostat
'        gosub instr_WS                                              '"WS
'      elseif (A_SerString[0] = "w") and (A_SerString[1] = "s") then     'Write Thermostat data, detailed information of 1 Thermostat
'        gosub instr_wsl                                             '"ws     
      elseif (A_SerString[0] = "r") and (A_SerString[1] = "e") then     'reset processor
        gosub instr_reset                                           '"re
      elseif (A_SerString[0] = "I") and (A_SerString[1] = "F") then     'perform intelligent function
        gosub instr_IF                                              '"IF  
      elseif (A_SerString[0] = "S") and (A_SerString[1] = "T") then     'Status information
        cid=A_SerString[2]
        Gosub send_ST                                               '"ST    
      elseif (A_SerString[0] = "s") and (A_SerString[1] = "t") then     'Set Time
        gosub instr_st                                              '"st  
      elseif (A_SerString[0] = "D") and (A_SerString[1] = "I") then     'Dim up or down Last dimmer light switched on with "ON" instruction
        gosub instr_DI                                              '"DI   
      elseif (A_SerString[0] = "R") and (A_SerString[1] = "O") then     'Read output                                       
        for ic=1 to controller_out                                  '"RO
          if ic<MAX_OUTPUT_MODULES+1 then A_WriteYesMod[ic-1]=OutputNrWrites
          gosub RO_linux2                                           'All output modules
        next ic 
      elseif (A_SerString[0] = "S") and (A_SerString[1] = "O") then     'Read output Roller/Shutter in Large Installation mode                                                                                          '"ro
        cid=A_SerString[2]
        ic=A_SerString[3]+1
        gosub SO_linux2                                       'All output modules
      elseif (A_SerString[0] = "R") and (A_SerString[1] = "U") then     'Read User data
        gosub instr_RU                   
      elseif (A_SerString[0] = "R") and (A_SerString[1] = "E") then     'Read Eeprom
        gosub instr_RE                                              '"RE       
      elseif (A_SerString[0] = "W") and (A_SerString[1] = "E") then     'Write Eeprom
        gosub instr_WE 
      elseif (A_SerString[0] = "W") and (A_SerString[1] = "T") then     'Write Timer
        gosub instr_WT                                                     '"WT
      elseif (A_SerString[0] = "e") and (A_SerString[1] = "c") then     'Error Clear (clear all error counters)
        gosub instr_ec                                              '"ec  
      elseif (A_SerString[0] = "A") and (A_SerString[1] = "E") then     'Activate data in Eeprom (copy into RAM)                          '"AE
        gosub eeprom_activate 
        gosub send_AE 
'      elseif (A_SerString[0] = "a") and (A_SerString[1] = "e") then     'Activate data in Eeprom for RTD10 function                       '"ae
'        gosub OnOffAirco 
'        gosub send_AE2           
      elseif (A_SerString[0] = "A") and (A_SerString[1] = "D") then     'Activate Device                                                  '"AD
        gosub activate_device
        gosub send_AD 
'      elseif (A_SerString[0] = "A") and (A_SerString[1] = "R") then     '"AR Airco read                                                  '"AD
'        gosub instr_AR 
'      elseif (A_SerString[0] = "A") and (A_SerString[1] = "W") then     '"AW Airco write                                                 '"AD
'        gosub instr_AW                       
      elseif (A_SerString[0] = "C") and (A_SerString[1] = "M") then     'Command mode (switch between advanced mode and simple mode (command line)                                      
        if A_SerString[2]="1" then                                    '"CM
          mode_com=1                                                'advanced mode - API
        else
          mode_com=0                                                'simple mode CLI and fixed length command mode
          gosub send_mes_ok
          ApiExit=1   
        endif
      elseif (A_SerString[0] = "c") and (A_SerString[1] = "m") then     'Change Number of char to be received for Data upload bootloader slave modules
        gosub instr_cm                                              '"cm      
      elseif (A_SerString[0] = "R") and (A_SerString[1] = "T") then     'Read Temperature "RT"
        a=0                                                         'read Temperature
        CIDused=0
        gosub start_serstring                                                  
      elseif (A_SerString[0] = "r") and (A_SerString[1] = "n") then     'Read number of input and output modules
        cid=A_SerString[2]                                            '"rn
        gosub instr_rn      
      elseif (A_SerString[0] = "r") and (A_SerString[1] = "i") then     'read input Data, detailed information of 1 output 
        CIDused=1                                                   '"ri
        cid=A_SerString[2]
        x=A_SerString[3]
        gosub send_ri  
      elseif (A_SerString[0] = "R") and (A_SerString[1] = "I") then     'read input Data of an Input module 
        CIDused=1                                                   '"RI
        cid=A_SerString[2]
        gosub send_RI2                   
      elseif (A_SerString[0] = "R") and (A_SerString[1] = "V") then     'Read Validation Bits
        gosub instr_RV                                              '"RV     
      elseif (A_SerString[0] = "I") and (A_SerString[1] = "N") then     'Execute Led Indicate Instruction 
        gosub instr_IN                                              '"IN             
      elseif (A_SerString[0] = "D") and (A_SerString[1] = "A") then     'Discover stArt "DA"                   
        gosub bus_init
        x="D"
        y="A" 
        gosub return_api_ok        
      elseif (A_SerString[0] = "D") and (A_SerString[1] = "O") then     'Discover stOp "DO"                    
        gosub bus_live
        x="D"
        y="O" 
        gosub return_api_ok
      elseif (A_SerString[0] = "r") and (A_SerString[1] = "t") then     'Read Time "rt"
        cid=A_SerString[2]
        gosub send_rt       
      elseif (A_SerString[0] = "A") and (A_SerString[1] = "V") then     'Add Virtual Module "AV"                    
        if A_SerString[3]="i" or A_SerString[3]="d" or A_SerString[3]="o" or A_SerString[3]="r" then
          e=A_SerString[3]
          gosub add_virtual_m
          gosub add_m
          x="A"
          y="V"
          gosub return_api_ok
        endif
      endif                     
  endif 
  if Mode_com=0 and ApiExit=0 then                                  'simple command (CLI) received     
    for j=0 to (BUFFER_RS232-1)  
      A_RecChar[j]=A_SerString[j]
    next j
    if A_RecChar[0]=13 then
      gosub send_mes_ok
    else
      if echoonbit=1 and Mode_com=0 then
        Hserout2 [10]
      endif   
      gosub interprete_cmd                                          'interprete command
    endif
    gosub Empty_RecInstr
  endif
  PointerSer2=0
  RecSer2=0
  ApiExit=0
  RCSTA2.4=1                                                        'enable receiving serial 2  
ENDIF
end_rs232_interprete:
return

instr_reset:
  gosub send_reset
  pause 1000
  asm
    reset
  endasm
return

instr_ec:
  if ok=1 then
    ok=0
    gosub error_clear
    ok=1
  else
    gosub error_clear
  endif
  x="e"
  y="c" 
  gosub return_api_ok
return

return_api_ok:
  gosub empty_e
  A_e[0]=x
  A_e[1]=y
  A_e[2]=cid
  A_e[3]="O"
  A_e[4]="K"
  gosub send_api 
return

'instr_AR:     '"AR
'  CID=A_SerString[2]
'  u="A"
'  v="R"
'  gosub instr_AR_AW_sub
'return

'instr_AW:     '"AW
'  u=A_SerString[3]
'  if u<MAX_THERMOSTATS then
'    if A_SerString[4]=0 then
'      A_Airco[u]=0           'Switch off Airco with RTD-10
'    else
'      A_Airco[u]=1           'Switch on Airco with RTD-10
'    endif
'  endif  
'  CID=A_SerString[2]
'  u="A"
'  v="W"
'  gosub instr_AR_AW_sub
'return

'instr_AR_AW_sub:
'  Hserout2 [u,v,cid]
'  for a=0 to (MAX_THERMOSTATS-1)
'    hserout2 [A_Airco[a]]
'  next a 
'  gosub display_LF_CR
'return

instr_RE:
  gosub empty_e
  A_e[0]="R"
  A_e[1]="E"
  A_e[2]=cid
  A_e[3]=A_SerString[3]
  A_e[4]=A_SerString[4]
  A_e[5]=A_SerString[5] 
  if A_SerString[5]<11 then
    gosub Display_RE_WE   
  endif
return

instr_RU:
  if A_SerString[3]=0 then  'Type=0 -> Read validation bit
    gosub empty_e
    A_e[0]="R"
    A_e[1]="U"
    A_e[2]=cid
    A_e[3]=A_SerString[3]
    A_e[4]=A_SerString[4]
    ValBitNr=A_SerString[4]
    for i=0 to 10
      x.bit0=A_ValBit[ValBitNr+(i*8)]
      x.bit1=A_ValBit[ValBitNr+(i*8)+1]
      x.bit2=A_ValBit[ValBitNr+(i*8)+2]
      x.bit3=A_ValBit[ValBitNr+(i*8)+3]
      x.bit4=A_ValBit[ValBitNr+(i*8)+4]
      x.bit5=A_ValBit[ValBitNr+(i*8)+5]
      x.bit6=A_ValBit[ValBitNr+(i*8)+6]
      x.bit7=A_ValBit[ValBitNr+(i*8)+7]
      A_e[i+5]=x
    next i
    gosub send_api   
  endif
return

Display_RE_WE: 
    for ic=1 to A_SerString[5]
      eep_addr.byte0 = A_SerString[4]+ic-1
      eep_addr.byte1 = A_SerString[3]
      Gosub read_eeprom                     'Read data being written and send it back
      if (5+ic)<MAX_E then A_e[5+ic]=i2cdata
    next ic
    gosub send_api
    cid=0
return

instr_WE:
  if A_SerString[5]<11 and A_SerString[5]>0 then
    gosub empty_e
    A_e[0]="W"
    A_e[1]="E"
    A_e[2]=cid   
    for ic=1 to A_SerString[5]
      eep_addr.byte0 = A_SerString[4]+ic-1
      eep_addr.byte1 = A_SerString[3]
      i2cdata=A_SerString[5+ic]
      Gosub write_eeprom                    'Write data to eeprom
    next ic
    gosub Display_RE_WE
  endif  
return

instr_WT:
  if A_SerString[3]<240 then
    digitcount=2
    A_DigitTotal[0]=A_SerString[3]
    A_DigitTotal[1]=(256*A_SerString[4])+A_SerString[5]
    ok=0
    gosub output_timer_write
    ok=1
    gosub empty_e
    a=A_SerString[3]
    A_e[0]="R"
    A_e[1]="T"
    A_e[2]=cid 
    A_e[3]=a
    A_e[4]=A_TimerCd[a]/256
    A_e[5]=A_TimerCd[a]  
    gosub send_api
  endif  
return

'instr_RS:
'  for j=2 to 17  
'    A_RecChar[j]=A_SerString[j]
'  next j
'  charpointer=2
'  reccounter=17
'  gosub convert_dec        
'  if A_DigitTotal[0]<MAX_THERMOSTATS then
'    t_word=A_DigitTotal[0]
'    pid=t_word.byte0
'    CIDused=0
'    gosub send_RS
'  endif  
'return

'instr_RS2:
'  CID=A_SerString[2]
'  pid=A_SerString[3]        
'  if pid<MAX_THERMOSTATS then
'    CIDused=1
'    gosub send_RS
'  endif
'return

instr_RD:
  for j=2 to 17  
    A_RecChar[j]=A_SerString[j]
  next j
  charpointer=2
  reccounter=17
  gosub convert_dec        
  if A_DigitTotal[0]<240 then
    t_word=A_DigitTotal[0]
    x=t_word.byte0
    gosub send_RD
  endif
Return

send_ri:
  y=A_SelOutput[x] 
  CRC=x+y 
  Hserout2 ["ri",CID,x,y]  
  CurrentInput=x
  Queue_module_nr=(x/8)+1
  Queue_input_nr=x//8
  AddToQueue=0
  gosub input_action_eeprom                 'Add full Action list of the requested input  
  a=x
  length=8
  Spaces=1 
  gosub eeprom_input_address
  gosub display_name
  gosub send_crc
  gosub display_LF_CR
return

send_RI2:
  x=A_SerString[3]
  CRC=x+A_Input[x]
  A_e[0]="R"
  A_e[1]="I"
  A_e[2]=cid
  A_e[3]=x          'Input module Nr
  A_e[4]=A_Input[x]
  A_e[13]="C"
  A_e[14]=CRC.Byte1
  A_e[15]=CRC.Byte0
  gosub send_api 
return

send_RD:
  CRC=0
  y=A_ModID0[30+(x/8)]                       'Dimmer or output?
  u=x//8
  v=x/8
  z=A_Output[v]>>u                               'Status output on (1) or off (0)
  z=z&%00000001
  timer=x
  gosub Timer_value_read                    'Retreive Timer Value
  t_word=timer
  t_word2=A_TimerCd[x] 
  'eep_addr.byte1=33+v
  'eep_addr.byte0=173+u                      'address (Max Power), this eeprom address is now in use for LargeInstallation
  'gosub read_eeprom
  q=255
  eep_addr.byte0=157+u                      'address (Floor Level)
  gosub read_eeprom
  t=i2cdata
  eep_addr.byte0=149+u                      'address (Output type: 0-127 ->output, 128-255 ->Light)
  gosub read_eeprom
  d=i2cdata
  eep_addr.byte0=165+u                      'address (Menu Position)
  gosub read_eeprom
  s=i2cdata  
  if d>1 then d=1  
  CRC=x+y+d+t_word.byte1+t_word.byte0+t_word2.byte1+t_word2.byte0+z
  CRC=CRC+A_DimmerValue[x]+controller_out+q+t+input_pressed+A_SelOutput[input_pressed]+s  
  if CIDused=1 then
    Hserout2 ["ro",CID]
  else
    Hserout2 ["RD"]
  endif  
  Hserout2 [x,y,d,t_word.byte1,t_word.byte0,t_word2.byte1,t_word2.byte0,z,A_DimmerValue[x],controller_out,q,t,input_pressed,A_SelOutput[input_pressed],s]
  a=x
  length=16
  Spaces=1 
  gosub eeprom_output_address
  gosub display_name
  gosub send_crc
  gosub display_LF_CR
return

instr_WD:
  for j=2 to 17  
    A_RecChar[j]=A_SerString[j]
  next j
  charpointer=2
  reccounter=17
  gosub convert_dec
  if A_DigitTotal[0]<240 and digitcount=3 then
    t_word=A_DigitTotal[0]
    x=t_word.byte0
    u=x//8
    v=x/8         
    t_word=A_DigitTotal[1]
    a=t_word.byte0                          'instruction 0 to ...
    t_word2=A_DigitTotal[2]
    i2cdata=t_word2.byte0                   'data to be writen       
    if a=0 then                             'Timer value     
      if x<MAX_OUTPUTS THEN A_TimerCd[x]=t_word2 
      eep_addr.byte1=33+v                   'page
      eep_addr.byte0=4+(u*2)
      i2cdata=t_word2.byte0
      gosub write_eeprom
      i2cdata=t_word2.byte1
      eep_addr.byte0=5+(u*2)
      gosub write_eeprom           
    endif
    if a=1 then                             'Output Type     
      eep_addr.byte1=33+v
      eep_addr.byte0=149+u                  'address (Output Type)
      gosub write_eeprom
    endif
    'if a=2 then                             'Max Power, address is now in use by large installations     
    ' eep_addr.byte1=33+v
    ' eep_addr.byte0=173+u                   'address (Max Power)
    ' gosub write_eeprom
    'endif
    if a=3 then                             'Floor Level     
      eep_addr.byte1=33+v
      eep_addr.byte0=157+u                  'address (Floor Level)
      gosub write_eeprom
    endif
    if a=4 then                             'Link an input to the current output
      y=i2cdata/8                           'Output needs to be written at the input page
      z=i2cdata//8
      eep_addr.byte1=2+y                    'page 2 to 31
      eep_addr.byte0=4+z                    'byte 4 to 11
      i2cdata=x                             'Output needs to be written at the input page
      gosub write_eeprom
      gosub eeprom_activate
    endif 
    if a=5 then                             'Menu Position     
      eep_addr.byte1=33+v
      eep_addr.byte0=165+u                  'address (Menu position)
      gosub write_eeprom
    endif                          
    gosub send_OO
  endif        
Return

instr_wd2:
  cid=A_SerString[2]
  x=A_SerString[3]  'Output Number
  y=A_SerString[4]  'Dimmer Value
  if y<64 and x<MAX_OUTPUTS then    'Dimmer & output value are valid
    A_DimmerValue[x]=y
    write_yes=1
    dimmer_value_eeprom_write=YES
    A_WriteYesMod[x/8]=1    
  endif
  hserout2["wd",CID,x,A_DimmerValue[x],0,0,0,0,0,0,0,0,0,0,0,13,10]
return

instr_VS:
  cid=A_SerString[2]
  x=A_SerString[3]  'Sensor Number
  if A_VirtualSensor[x]=1 and x<MAX_SENSORS then
    A_Temperature[x]=A_SerString[4]
    A_humidity[x]=A_SerString[5]
    A_ldr[x]=A_SerString[6]
  endif
  hserout2["VS",CID,x,A_Temperature[x],A_humidity[x],A_ldr[x],0,0,0,0,0,0,0,0,0,13,10]  
return

'instr_wsl:
'  cid=A_SerString[2]
'  A_DigitTotal[0]=A_SerString[3]
'  A_DigitTotal[1]=A_SerString[4]
'  A_DigitTotal[2]=A_SerString[5]
'  digitcount=3
'  instrOK=0
'  gosub interprete_thermostat_instr
'  if instrOK=1 then
'    Gosub send_ws
'  endif      
'return

'instr_WS:
'  for j=2 to 17  
'    A_RecChar[j]=A_SerString[j]
'  next j
'  charpointer=2
'  reccounter=17
'  gosub convert_dec
'  instrOK=0
'  gosub interprete_thermostat_instr
'  if instrOK=1 then
'    gosub send_RS
'  endif 
'return

'thermostat_program_data:
'  if digitcount=3 and A_DigitTotal[0]<MAX_THERMOSTATS then
'    gosub interprete_thermostat_instr  
'    gosub send_mes_ok
'  else
'    error_code=23
'    gosub send_error 
'  endif
'return

'interprete_thermostat_instr:
'  if A_DigitTotal[0]<MAX_THERMOSTATS and digitcount=3 then
'    t_word=A_DigitTotal[0]
'    pid=t_word.byte0
'    t_word=A_DigitTotal[1]
'    a=t_word.byte0                          'instruction 0 to ...
'    t_word=A_DigitTotal[2]
'    i2cdata=t_word.byte0                    'data to be writen
'    A_Setpt[pid]=i2cdata
'    'hier_thermo
'    ThermostatNr=pid
'    EepromSetptWrite=1                       'write eeprom    
'    gosub check_setpoint
'    'delete
'    'hserout2 ["6:Temp(",dec pid,")=",dec A_Setpt[pid],13,10]
'    'hier_thermo       
'    'if a=0 and pid<24 then                  'current setpoint
'    '  i2caddr=40+pid
'    '  gosub write_i2c_2                     'write setpoint in RAM memory of DS1307
'    'endif  
'    if a>0 and a<7 then                     'programmed setpoint
'      eep_addr.byte1 = 142+(59*thermostatCooling)                 'page 142 or 201
'      eep_addr.byte0 = (32*a)+pid
'      gosub write_eeprom
'    endif
'    if a>6 and a<18 then
'      if a=7 then                           'P parameter
'        eep_addr.byte0=pid*4                'address
'        eep_addr.byte1=141+(59*thermostatCooling)                  'page 141 or 200
'        gosub write_eeprom           
'      elseif a=8 then                       'I parameter
'        eep_addr.byte0=(pid*4)+1            'address
'        eep_addr.byte1=141+(59*thermostatCooling)                  'page 141 or 200
'        gosub write_eeprom             
'      elseif a=9 then                       'Int parameter
'        eep_addr.byte0=(pid*4)+3            'address
'        eep_addr.byte1=141+(59*thermostatCooling)                  'page 141 or 200  
 '       gosub write_eeprom                      
 '     elseIF a=10 then                      'D parameter
 '       eep_addr.byte0=(pid*4)+2            'address
 '       eep_addr.byte1=141+(59*thermostatCooling)                  'page 141 or 200   
 '       gosub write_eeprom            
 '     elseif a=11 then                      'Temp threshold
 '       eep_addr.byte0=17                   'address
 '       eep_addr.byte1=0                    'page
 '       gosub write_eeprom 
 '       temp_threshold=i2cdata
 '     elseif a=12 then                      'Day
 '       i2caddr = 3                         'write days
 '       t_word=i2cdata
 '       gosub DS1307_write 
 '       gosub read_day
 '       gosub thermostat_timing
 '     elseif a=13 then                      'Time:Hours
 '       i2caddr = 2                         'write hours
 '       t_word=i2cdata
 '       gosub DS1307_write 
 '       gosub read_hours
 '       gosub thermostat_timing
 '     elseif a=14 then                      'Time:Minutes
 '       i2caddr = 1                         'write minutes
 '       t_word=i2cdata
 '       gosub DS1307_write 
 '       gosub read_minutes   
 '       gosub thermostat_timing
 '     elseif a=15 then                      'Room sensor
 '       if pid<MAX_THERMOSTATS then
 '         A_ThermostatSensor[pid]=i2cdata
 '         eep_addr.byte1=144+(59*thermostatCooling)                  'Page 144 or 203
 '         eep_addr.byte0=pid+8                'address
 '         gosub write_eeprom   
 '       endif           
 '     elseif a=16 then                      'Output1
 '       if pid<MAX_THERMOSTATS then
 '         A_Thermostat[pid]=i2cdata
 '         eep_addr.byte1=142+(59*thermostatCooling)                  'Page 142 or 201
 '         eep_addr.byte0=pid                  'address
 '         gosub write_eeprom
 '       endif              
 '     elseif a=17 then                      'Output2
 '       if pid<MAX_THERMOSTATS then
 '         A_Thermostat2[pid]=i2cdata 
 '         eep_addr.byte1=142+(59*thermostatCooling)                  'Page 142 or 201
 '         eep_addr.byte0=pid+224              'address
 '         gosub write_eeprom
 '       endif  
 '     endif
 '   endif    
 '   if a>17 and a<46  then                  'programmed timings
 '     gosub programmed_timings
 '     gosub write_eeprom                                                                                  
 '   endif
 '   if a>45 and a<67 then                   'Programmed Temperature (day1/day2/Night) for every day of the week
 '     gosub programmed_temperature
 '     gosub write_eeprom        
 '   endif
 '   if a=67 then                            'Write the Multi-Tenant configuration byte
 '     if pid<MAX_THERMOSTATS then
 '       eep_addr.byte1 = 199                  'page 199
 '       eep_addr.byte0 = 32+pid
 '       gosub write_eeprom
 '       A_ThermostatAuto[PID]=i2cdata.bit3
 '     endif  
 '   endif                       
 '   PidCalcCheck=1 
 '   instrOK=1
 ' else
 '   error_code=30
 '   gosub send_error          
 ' endif
'return

'programmed_timings:
'  t=(a-18)//4
'  u=(a-18)/4 
'  eep_addr.byte1 = 189 + (u/2) +(17*thermostatCooling)      'Start page 189 or 206
'  eep_addr.byte0 = (128*(u//2))+(pid*4)+t
'return

'programmed_temperature:
'  if a<53 then                              'day1
'    eep_addr.byte1=196+(14*thermostatCooling)        'page 196 or 210
'    eep_addr.byte0=((a-46)*32)+pid
'  elseif a<60 then                          'day2
'    eep_addr.byte1=197+(14*thermostatCooling)        'page 197 or 211
'    eep_addr.byte0=((a-53)*32)+pid
'  else                                      'night
'    eep_addr.byte1=198+(14*thermostatCooling)        'page 198 or 212
'    eep_addr.byte0=((a-60)*32)+pid    
'  endif 
'return

instr_RV:
  error_code=255
  for j=2 to 15  
    A_RecChar[j]=A_SerString[j]
  next j
  charpointer=2
  reccounter=15  
  gosub convert_dec      
  if A_DigitTotal[0]<32 then 
    t_word=A_DigitTotal[0]
    x=t_word.byte0
    A_SerString[2]=" "
    for ic=0 to 7
      A_SerString[3+ic]=A_ValBit[(x*8)+ic]
    next ic
    for ic=11 to 15
      A_SerString[ic]="-"
    next ic
    gosub send_serstring
  endif
return

print_ds1307:
  for ic=0 to 6 
    i2caddr = ic                            'read seconds(0), minutes(1), etc
    i2cdata = 0    
    gosub read_i2c_2
    x=i2cdata
    gosub Calc_time
    A_SerString[ic]=y
  next ic 
return

instr_st:
  cid=A_SerString[2]
  for ic=0 to 6
    i2caddr = ic                            'write seconds (0), Minutes (1), Hours (2), ... 
    t_word=A_SerString[ic+3]
    gosub DS1307_write
  next ic                           
  gosub read_minutes
  gosub read_hours
  gosub read_day
  gosub read_date
  gosub print_ds1307
  gosub empty_e
  A_e[0]="s"
  A_e[1]="t"
  A_e[2]=cid
  A_e[3]=A_SerString[0]
  A_e[4]=A_SerString[1]
  A_e[5]=A_SerString[2]
  A_e[6]=A_SerString[3]
  A_e[7]=A_SerString[4]
  A_e[8]=A_SerString[5]
  A_e[9]=A_SerString[6]
  gosub send_api    
return

instr_cm:
  If A_SerString[3]=77 then                   'Number of characters for communication
    BootLoaderMode=1
    MaxChar=77 
  else 
    MaxChar=18
  endif
  if A_SerString[4]=0 then                    'BootLoaderMode
    'BootLoaderMode=0                        'Normal operation
    u=0
    gosub Set_errorbit
  else
    RS485Busy=NO
    u=1
    gosub Set_errorbit    
  endif  
  gosub empty_e
  A_e[0]="c"
  A_e[1]="m"
  A_e[2]=cid
  A_e[3]=MaxChar
  A_e[4]=BootLoaderMode
  gosub send_API
return


Set_errorbit:
  for s=1 to controller_out
    if (29+s)<MAX_ERRORS then A_ErrorBit[29+s]=u
  next s
  for s=1 to controller_in
    if (s-1)<MAX_ERRORS then A_ErrorBit[s-1]=u
  next s  
return

instr_F:
  RS485Message="F"
  if A_SerString[1]="D" then                  '"FD" Data Upload firmware
    gosub send_FD_Data
  else                                      'All other "F instructions
    gosub send_Fx_Data
  endif  
  gosub prepare_rs485_receive   
return

send_F_String:
  high RS485_DIR                            'Send mode
  hserout ["ST",A_SerString[3],A_SerString[4],A_SerString[5],A_SerString[6],A_SerString[0],A_SerString[1]]
return

send_FD_Data:
  gosub send_F_String
  for t=7 to 75
    hserout [A_SerString[t]]
  next t
  hserout [13,10,13,10]
  gosub low_rs485_dir                       'Receive mode
return

send_Fx_Data:
  if A_SerString[1]="R" then                  '"FR
    BootLoaderMode=1                        'Slave BootloaderMode, stop normal communication with input and output modules,silent mode
  endif
  if A_SerString[1]="G" then                  '"FG
    BootLoaderMode=0                        'Normal mode again so modules will be scant again
  endif  
  gosub send_F_String
  for t=7 to 15
    hserout [A_SerString[t]]
  next t
  hserout [13,10,13,10]
  gosub low_rs485_dir                       'Receive mode
return

send_API:
  hserout2 [A_e[0],A_e[1],A_e[2],A_e[3],A_e[4],A_e[5],A_e[6],A_e[7],A_e[8],A_e[9],A_e[10],A_e[11],A_e[12],A_e[13],A_e[14],A_e[15],13,10,13,10]
return

send_rs485_short:
  high RS485_DIR                            'Send mode
  hserout ["ST",A_e[0],A_e[1],A_e[2],A_e[3],A_e[4],A_e[5],A_e[6],A_e[7],A_e[8],13,10,13,10]
  'pauseus 100
  gosub low_rs485_dir                       'Receive mode
return

send_rs485_long:
  high RS485_DIR                            'Send mode
  hserout ["ST",A_e[0],A_e[1],A_e[2],A_e[3],A_e[4],A_e[5],A_e[6],A_e[7],A_e[8],A_e[9],A_e[10],A_e[11],A_e[12],A_e[13],A_e[14],A_e[15],A_e[16],A_e[17],13,10,13,10]
  'pauseus 100
  gosub low_rs485_dir                       'Receive mode   
return

low_rs485_dir:
    do until (TXSTA1.bit1=1)                'Wait until transmit buffer is empty
    loop
    low RS485_DIR                           'Receive mode  
return

instr_xL2:
  if (A_SerString[0] = "P") then              'Pulse Counter List 
    gosub send_PL                           '"PL             
  elseif (A_SerString[0] = "O") then          'Sent Output List 
    gosub send_OL                           '"OL      
  elseif (A_SerString[0] = "T") then          'Read Thermostat sensor Temperature list "TL"
    a=5                                     'read Temperature
    CIDused=1                               'CID is used
    gosub start_serstring
'  elseif (A_SerString[0] = "S") then          'Read Thermostat Setpoint Temperature list '"SL
'    a=6                                     'read setpoint
'    CIDused=1
'    gosub start_serstring  
  elseif (A_SerString[0] = "E") then          'Read Eeprom List (256 bytes)
    cid=A_SerString[2]                        '"EL
    gosub instr_EL 
  elseif (A_SerString[0] = "V") then          'Read Virtual Sensor List (32 bytes)
    cid=A_SerString[2]                        '"VL
    gosub instr_VL 
'  elseif (A_SerString[0] = "p") then          'Read Permanent Thermostat List (32 bytes)
'    cid=A_SerString[2]                        '"pL
'    gosub instr_pL       
  endif
return

instr_xl:
  'if (A_SerString[0] = "t") then              'Read Thermostat list
  '  gosub instr_tl                          '"tl"                                                    
  if (A_SerString[0] = "h") then          'Read humidity list
    gosub instr_hl                          '"hl"      
  elseif (A_SerString[0] = "c") then          'Read Temperature list
    gosub instr_cl                          '"cl"      
  elseif (A_SerString[0] = "b") then          'Read brightness list
    gosub instr_bl                          '"bl"                                           
  elseif (A_SerString[0] = "e") then          'Read error list
    gosub instr_el2                         '"el" 
'  elseif (A_SerString[0] = "m") then          'Read Multi-Tenant configuration byte
'    gosub instr_ml                          '"ml"         
  endif  
return

'instr_tl:
'  CID=A_SerString[2]
'  CRC=0
'  CRC=ThermostatMode+A_Temperature[outside_sensor]
'  Hserout2 ["tl",cid,ThermostatMode,A_Temperature[outside_sensor]]
'  for a=0 to (MAX_THERMOSTATS-1)
'    b=A_ThermostatSensor[a]
'    hserout2 [A_Temperature[b]]
'    CRC=CRC+A_Temperature[b]
'  next a 
'  for a=0 to (MAX_THERMOSTATS-1)
'    hserout2 [A_Setpt[a]]
'    CRC=CRC+A_Setpt[a]
'  next a
'  gosub send_crc
'  gosub display_LF_CR
'  gosub display_LF_CR 
'return

'instr_ml:
'  CID=A_SerString[2]
'  CRC=0
'  Hserout2 ["ml",cid]
'  for a=0 to (MAX_THERMOSTATS-1)
'    eep_addr.byte1=199                                'page 199
'    eep_addr.byte0=a+32                               'byte
'    gosub read_eeprom
'    CRC=CRC+i2cdata
'    gosub print_i2cdata
'  next a
'  gosub send_crc
'  gosub display_LF_CR
'  gosub display_LF_CR   
'return

instr_el2:
  CID=A_SerString[2]
  CRC=0
  CRC=Controller_in + Controller_out
  Hserout2 ["el",cid,Controller_in+controller_out]
  if controller_in>0 then
    for a=0 to (controller_in-1)
      b=a
      gosub print_el
    next a
  endif   
  if controller_out>0 then
    for a=0 to (controller_out-1)
      b=a+30
      gosub print_el
    next a
  endif
  gosub send_crc
  gosub display_LF_CR    
return

print_el:
  t_word=A_ErrorCount[b]
  hserout2 [A_ModID0[b],a,t_word.byte1,t_word.byte0]
  CRC=CRC+A_ModID0[b]+a+t_word.byte1+t_word.byte0
return

instr_hl:
  CID=A_SerString[2]
  CRC=0
  Hserout2 ["hl",cid]
  for a=0 to 31
    hserout2 [A_humidity[a]]
    CRC=CRC+A_humidity[a]
  next a 
  gosub send_crc
  gosub display_LF_CR 
return

instr_cl:
  CID=A_SerString[2]
  CRC=0
  Hserout2 ["cl",cid]
  for a=0 to 31
    hserout2 [A_Temperature[a]]
    CRC=CRC+A_Temperature[a]
  next a 
  gosub send_crc
  gosub display_LF_CR 
return

instr_bl:
  CID=A_SerString[2]
  CRC=0
  Hserout2 ["bl",cid]
  for a=0 to 31
    hserout2 [A_ldr[a]]
    CRC=CRC+A_ldr[a]
  next a 
  gosub send_crc
  gosub display_LF_CR 
return

'instr_TM:
'  CID=A_SerString[2]
'  gosub empty_e
'  A_e[0]="T"
'  A_e[1]="M"
'  A_e[2]=cid
'  A_e[3]=ThermostatMode
'  A_e[4]=ThermostatEnabled
'  gosub send_api   
'return

instr_BA:
    CID=A_SerString[2]
    'A_QueueType[queue_end]=A_SerString[3]
    'A_QueueAction[queue_end]=A_SerString[4]
    BA_type_queue=A_SerString[3]
    BA_action_queue=A_SerString[4]
    if A_SerString[5]=="P" then             'A parameter is found that must be used as an addition on the BA
        BA_type=A_SerString[3]
        BA_action=A_SerString[4]
        BA_parameter_used=YES
        BA_parameter=(A_SerString[6]*256)+A_SerString[7]
        TimerRSenabled=1
        gosub check_queue_sub
    else
        gosub Increase_queue_pointer
        BA_parameter_used=NO    
    endif
    x="B"
    y="A" 
    gosub return_api_ok  
return

instr_IN:
  CID=A_SerString[2]
  a=A_SerString[3]
  b=A_SerString[4]
  gosub normal_Powerstate                   'Put leds of all modules in normal powerstate
  if a<3 then
    IndicateInput=a.bit0
    IndicateTemperature=a.BIT1
    Indicate=b
    if a=0 then
      write_yes=1
      if (indicate/8)<MAX_OUTPUT_MODULES then A_WriteYesMod[indicate/8]=1     
    endif  
    x="I"
    y="N" 
    gosub return_api_ok
  endif    
return

instr_rn:
  CID=A_SerString[2]
  gosub empty_e
  A_e[0]="r"
  A_e[1]="n"
  A_e[2]=cid
  A_e[3]=controller_in
  A_e[4]=controller_out
  A_e[5]=controller_out_rs
  gosub send_api    
return

instr_IF:
  error_code=255
  for j=3 to 17  
    A_RecChar[j]=A_SerString[j]
  next j
  charpointer=3
  reccounter=17
  if A_SerString[2]="D" then                  'Output ON with Dimmer value
    gosub convert_dec
    t_word=A_DigitTotal[0]
    a=t_word.byte0
    t_word=A_DigitTotal[1]
    b=t_word.byte0
    digitcount=2
    gosub output_on  
  endif
  if A_SerString[2]="Q" then                  'Add instruction to the queue
    gosub convert_dec
    t_word=A_DigitTotal[0]
    a=t_word.byte0
    t_word=A_DigitTotal[1]
    b=t_word.byte0       
    'A_QueueType[queue_end]=a
    'A_QueueAction[queue_end]=b
    BA_type_queue=a
    BA_action_queue=b    
    gosub Increase_queue_pointer        
  endif  
return

instr_DI:
  if A_SerString[2]="+" then  
    digitcount=2
    A_DigitTotal[0]=LastDimmer
    A_DigitTotal[1]=3                         'step 3
    gosub dim_plus
  endif
  if A_SerString[2]="-" then
    digitcount=2
    A_DigitTotal[0]=LastDimmer
    A_DigitTotal[1]=3                         'step 3
    gosub dim_min    
  endif
  if A_SerString[2]="*" then                  'max dimmer
    if LastDimmer<MAX_OUTPUTS then
      A_DimmerValue[LastDimmer]=63
      dimmer_value_eeprom_write=YES
      write_yes=1
      A_OutUpdate[LastDimmer]=1                           'write outputs 
      for ic=1 to controller_out
        if ic<MAX_OUTPUT_MODULES+1 then A_WriteYesMod[ic-1]=1
      next ic
    endif     
  endif
return

start_serstring:
  z=A_SerString[2+CIDused]
  x=12*z
  y=11+(z*12)
  if a<4 and z=2 then
    x=24
    y=29
    gosub fill_serstring
    gosub send_serstring       
  endif
  if a<4 and z<2 then
    gosub fill_serstring
    gosub send_serstring      
  endif
  if (a=5 or a=6) and (z<2) then            'Read Thermostat, Temperature or setpoint
    gosub fill_serstring
    gosub send_serstring        
  endif
  if (a=5 or a=6) and (z=2) then
    x=24
    y=31  
    gosub fill_serstring
    gosub send_serstring  
  endif             
return
                          
fill_serstring:
  for ic=0 to 12
    if (ic+3+CIDused)<BUFFER_RS232 then A_SerString[ic+3+CIDused]=255             'sensor not connected
  next ic
  for ic=x to y
    gosub fill_value
  next ic
return

fill_value:
  if (ic-(z*12)+4)<BUFFER_RS232 then
    if a=0 then                               'read Temperature
      A_SerString[ic-(z*12)+3]=A_Temperature[ic]
    elseif a=1 then                           'read brightness
      A_SerString[ic-(z*12)+3]=A_ldr[ic]
    elseif a=2 then                           'read humidity
      A_SerString[ic-(z*12)+3]=A_humidity[ic]
'    elseif a=5 then                           'read Thermostat sensor Temperature
'      b=A_ThermostatSensor[ic]
'      A_SerString[ic-(z*12)+4]=A_Temperature[b]
'    elseif a=6 then                           'read Thermostat setpoint Temperature
'      A_SerString[ic-(z*12)+4]=A_Setpt[ic]      
    endif
  endif         
return

send_serstring:
  hserout2 [A_SerString[0],A_SerString[1],A_SerString[2],A_SerString[3],A_SerString[4],A_SerString[5],A_SerString[6],A_SerString[7],A_SerString[8],A_SerString[9],A_SerString[10],A_SerString[11],A_SerString[12],A_SerString[13],A_SerString[14],A_SerString[15],13,10]
return

activate_device:                     
  A_e[0]="A"
  A_e[1]="D"
  A_e[2]=A_SerString[3]
  A_e[3]=A_SerString[4]
  A_e[4]=A_SerString[5]
  A_e[5]=A_SerString[6]
  A_e[6]=0
  A_e[7]=0
  A_e[8]=0
  CRC2=A_e[0]+A_e[1]+A_e[2]+A_e[3]+A_e[4]+A_e[5]
  A_e[15]="C"
  A_e[16]=CRC2.byte1
  A_e[17]=CRC2.byte0
  gosub send_rs485_long 
return

' ---- List CLI instructions ------------------------------------------------
' For more details see http://wiki.openmotics.com/index.php/CLI_Reference_Guide

interprete_cmd: 
    low led_red 
    instruction=255                         'no instruction match found yet
    error_code=255                          'No error
    for j=0 to (nr_of_cmd-1)                'max of 160 instructions defined (if more needed, change constant "nr_of_cmd")
      A_TestChar[j]=1
    next j
    for j=0 to BUFFER_RS232
      lookup j,["exit%"],test
      cmd=0
      gosub test_command   
      lookup j,["output off %"],test
      cmd=1
      gosub test_command
      lookup j,["output on %"],test
      cmd=2
      gosub test_command
      lookup j,["basic action activate %"],test
      cmd=3
      gosub test_command
      lookup j,["module discover start%"],test
      cmd=4
      gosub test_command
      lookup j,["module discover stop%"],test
      cmd=5
      gosub test_command      
      lookup j,["input action read %"],test
      cmd=6
      gosub test_command
      lookup j,["input action write %"],test
      cmd=7
      gosub test_command
      lookup j,["output status read %"],test
      cmd=8
      gosub test_command       
      lookup j,["output timer read %"],test
      cmd=9
      gosub test_command
      lookup j,["output timer write %"],test
      cmd=10
      gosub test_command 
      lookup j,["eeprom read %"],test
      cmd=11
      gosub test_command 
      lookup j,["eeprom write %"],test
      cmd=12
      gosub test_command 
      lookup j,["eeprom activate%"],test
      cmd=13
      gosub test_command 
      lookup j,["debug on%"],test
      cmd=14
      gosub test_command
      lookup j,["debug off%"],test
      cmd=15
      gosub test_command           
      lookup j,["action read %"],test
      cmd=16
      gosub test_command             
      lookup j,["group read %"],test
      cmd=22
      gosub test_command
      lookup j,["group write %"],test
      cmd=23
      gosub test_command
      lookup j,["group activate %"],test
      cmd=24
      gosub test_command 
      lookup j,["input link read %"],test
      cmd=25
      gosub test_command
      lookup j,["input link write %"],test
      cmd=26
      gosub test_command
      lookup j,["discover can control %"],test
      cmd=27
      gosub test_command
      lookup j,["output all off%"],test
      cmd=29
      gosub test_command 
      lookup j,["fixl%"],test
      cmd=30
      gosub test_command 
      lookup j,["varl%"],test
      cmd=31
      gosub test_command
      lookup j,["output status on%"],test
      cmd=32
      gosub test_command
      lookup j,["input link list%"],test
      cmd=33
      gosub test_command
      lookup j,["validation bit read %"],test
      cmd=34
      gosub test_command
      lookup j,["validation bit write %"],test
      cmd=35
      gosub test_command 
      lookup j,["input number modules read%"],test
      cmd=44
      gosub test_command
      lookup j,["input number modules write %"],test
      cmd=45
      gosub test_command 
      lookup j,["output number modules read%"],test
      cmd=46
      gosub test_command
      lookup j,["output number modules write %"],test
      cmd=47
      gosub test_command
      lookup j,["time read%"],test
      cmd=48
      gosub test_command
      lookup j,["time write %"],test
      cmd=49
      gosub test_command
      lookup j,["schedule read %"],test
      cmd=50
      gosub test_command
      lookup j,["schedule write %"],test
      cmd=51
      gosub test_command       
      lookup j,["schedule activate %"],test
      cmd=52
      gosub test_command
      lookup j,["schedule queue list%"],test
      cmd=53
      gosub test_command
      lookup j,["schedule queue delete %"],test
      cmd=54
      gosub test_command
      lookup j,["startup read %"],test
      cmd=55
      gosub test_command
      lookup j,["startup write %"],test
      cmd=56
      gosub test_command 
      lookup j,["startup list%"],test
      cmd=57
      gosub test_command
      lookup j,["startup activate%"],test
      cmd=58
      gosub test_command 
      lookup j,["brightness list%"],test
      cmd=60
      gosub test_command
      lookup j,["temperature list%"],test
      cmd=62
      gosub test_command
      lookup j,["error list%"],test
      cmd=63
      gosub test_command
      lookup j,["error clear%"],test
      cmd=64
      gosub test_command
      lookup j,["input debug on%"],test
      cmd=65
      gosub test_command
      lookup j,["input debug off%"],test
      cmd=66
      gosub test_command
      lookup j,["humidity list%"],test
      cmd=68
      gosub test_command
      lookup j,["firmware version%"],test
      cmd=69
      gosub test_command 
 '     lookup j,["thermostat mode read%"],test
 '     cmd=70
 '     gosub test_command
 '     lookup j,["thermostat details read%"],test
 '     cmd=71
 '     gosub test_command
      lookup j,["input list%"],test
      cmd=72
      gosub test_command
      lookup j,["output list%"],test
      cmd=73
      gosub test_command 
      lookup j,["input name write%"],test
      cmd=74
      gosub test_command
      lookup j,["output name write%"],test
      cmd=75
      gosub test_command
      lookup j,["echo on%"],test
      cmd=76
      gosub test_command
      lookup j,["echo off%"],test
      cmd=77
      gosub test_command 
      lookup j,["sensor name write%"],test
      cmd=82
      gosub test_command    
      lookup j,["add virtual module%"],test
      cmd=88
      gosub test_command
      lookup j,["STRCM0%"],test
      cmd=94      
      gosub test_command
      lookup j,["STRCM1%"],test
      cmd=95      
      gosub test_command
      'delete
      lookup j,["timer queue list%"],test
      cmd=97      
      gosub test_command       
      lookup j,["pulse counter list%"],test
      cmd=98      
      gosub test_command      
      lookup j,["pulse counter link read%"],test
      cmd=99      
      gosub test_command        
      lookup j,["pulse counter link write%"],test
      cmd=100      
      gosub test_command
      lookup j,["pulse counter name write%"],test
      cmd=101      
      gosub test_command
      lookup j,["reset%"],test
      cmd=102      
      gosub test_command
      lookup j,["input enable list%"],test
      cmd=103      
      gosub test_command
      lookup j,["input invert read%"],test
      cmd=104      
      gosub test_command
      lookup j,["input invert write%"],test
      cmd=105      
      gosub test_command 
      lookup j,["sync page%"],test
      cmd=106      
      gosub test_command 
      lookup j,["sync stop%"],test
      cmd=107      
      gosub test_command 
      lookup j,["sync debug on%"],test
      cmd=108      
      gosub test_command 
      lookup j,["sync debug off%"],test
      cmd=109      
      gosub test_command                                 
'      lookup j,["current setpoint read%"],test
'      cmd=113      
'      gosub test_command
'      lookup j,["current setpoint write%"],test
'      cmd=114      
'      gosub test_command
'      lookup j,["programmed setpoint read%"],test
'      cmd=115      
'      gosub test_command
'      lookup j,["programmed setpoint write%"],test
'      cmd=116      
'      gosub test_command 
'      lookup j,["pid config list%"],test
'      cmd=117      
'      gosub test_command
'      lookup j,["pid config write%"],test
'      cmd=118      
'      gosub test_command 
'      lookup j,["thermostat link read%"],test
'      cmd=119      
'      gosub test_command 
'      lookup j,["thermostat link write%"],test
'      cmd=120      
'      gosub test_command 
'      lookup j,["pid debug on%"],test
'      cmd=121      
'      gosub test_command 
'      lookup j,["pid debug off%"],test
'      cmd=122      
'      gosub test_command 
'      lookup j,["thermostat list%"],test
'      cmd=123      
'      gosub test_command  
      lookup j,["rst%"],test
      cmd=124      
      gosub test_command  
'      lookup j,["pump group read%"],test
'      cmd=125      
'      gosub test_command
'      lookup j,["pump group write%"],test
'      cmd=126      
'      gosub test_command 
'      lookup j,["pump output read%"],test
'      cmd=127      
'      gosub test_command 
'      lookup j,["pump output write%"],test
'      cmd=128      
'      gosub test_command  
      lookup j,["group name write%"],test
      cmd=131      
      gosub test_command 
      lookup j,["group list%"],test
      cmd=132      
      gosub test_command 
      lookup j,["can control erase%"],test
      cmd=134      
      gosub test_command 
      lookup j,["schedule name write%"],test
      cmd=135      
      gosub test_command 
       lookup j,["schedule list%"],test
      cmd=136      
      gosub test_command 
'      lookup j,["thermostat name write%"],test
'      cmd=137      
'      gosub test_command 
'      lookup j,["thermostat sensor read%"],test
'      cmd=138      
'      gosub test_command 
'      lookup j,["thermostat sensor write%"],test
'      cmd=139      
'      gosub test_command                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
'      lookup j,["thermostat threshold read%"],test
'      cmd=140      
'      gosub test_command 
'      lookup j,["thermostat threshold write%"],test
'      cmd=141      
'      gosub test_command
'      lookup j,["thermostat outside link read%"],test
'      cmd=142      
'      gosub test_command 
'      lookup j,["thermostat outside link write%"],test
'      cmd=143      
'      gosub test_command 
      lookup j,["temperature module enable%"],test
      cmd=144      
      gosub test_command 
      lookup j,["temperature module disable%"],test
      cmd=145      
      gosub test_command 
      lookup j,["floor level read%"],test
      cmd=146      
      gosub test_command 
      lookup j,["floor level write%"],test
      cmd=147      
      gosub test_command 
      lookup j,["output type read%"],test
      cmd=148      
      gosub test_command 
      lookup j,["output type write%"],test
      cmd=149      
      gosub test_command 
'      lookup j,["thermostat program data%"],test
'      cmd=152      
'      gosub test_command  
      lookup j,["output indicate%"],test
      cmd=153      
      gosub test_command 
      lookup j,["input indicate%"],test
      cmd=154      
      gosub test_command
      lookup j,["sensor indicate%"],test
      cmd=155      
      gosub test_command 
'      lookup j,["pump delay read%"],test
'      cmd=156      
'      gosub test_command 
'      lookup j,["pump delay write%"],test
'      cmd=157      
'      gosub test_command
      lookup j,["erase cc inputs%"],test
      cmd=158      
      gosub test_command 
      lookup j,["erase cc sensors%"],test
      cmd=159      
      gosub test_command 
      lookup j,["date write%"],test
      cmd=160      
      gosub test_command                                                                                                                       
    next j
    gosub Run_instruction
return

Run_instruction:
  if instruction<255  then                  'instruction match
    gosub convert_dec                       'check received values and convert them to decimal
    mode_com=0
    if error_code=255 then                  'No error received 
      if instruction=0 then                 'exit
        gosub exit1             
      elseif instruction=1 then             'output off
        gosub output_off        
      elseif instruction=2 then             'output on
        gosub output_on                  
      elseif instruction=3 then             'Action type activate
        gosub basic_action_activate                         
      elseif instruction=4 then             'Module discover start
        gosub module_discover_start
      elseif instruction=5 then             'Module discover stop
        gosub module_discover_stop  
      elseif instruction=6 then             'input Action read
        gosub input_action_read   
      elseif instruction=7 then             'input Action write
        gosub input_action_write          
      elseif instruction=8 then             'output status read
        gosub output_status_read     
      elseif instruction=9 then             'output timer read
        gosub output_timer_read
      elseif instruction=10 then            'output timer write
        gosub output_timer_write              
      elseif instruction=11 then            'Eeprom read
        gosub eeprom_read           
      elseif instruction=12 then            'Eeprom write
        gosub eeprom_write
      elseif instruction=13 and digitcount=0 then       'eeprom activate
        gosub eeprom_activate
        gosub send_mes_ok    
      elseif instruction=14 and digitcount=0 then       'debug on
        debugmode=1
        for q=0 to (MAX_CAN_CONTROLS-1)
            A_cc_inputs[0]=255
            A_cc_sensors[0]=255
            A_cc_outputs[0]=255
        next q            
        gosub send_mes_ok   
      elseif instruction=15 and digitcount=0 then       'debug off
        debugmode=0
        gosub send_mes_ok           
      elseif instruction=16 then            'Action read
        gosub action_read
      'elseif instruction=17 then            'Action write
      '  gosub action_write
      'elseif instruction=18 then            'Action activate
      '  gosub action_activate
      'elseif instruction=19 then            'decision read
      '  gosub decision_read
      'elseif instruction=20 then            'decision write
      '  gosub decision_write
      'elseif instruction=21 then            'decision activate
      '  gosub decision_activate              
      elseif instruction=22 then            'group read
        gosub group_read
      elseif instruction=23 then            'group write
        gosub group_write
      elseif instruction=24 then            'group activate
        gosub group_activate         
      elseif instruction=25 then            'input link read
        gosub input_link_read   
      elseif instruction=26 then            'input link write
        gosub input_link_write   
      elseif instruction=27 then            'dim+
        gosub discover_can_control
      'elseif instruction=28 then            'dim-
      '  gosub dim_min   
      elseif instruction=29 and digitcount=0 then       'all off
        gosub all_outputs_off
        gosub send_mes_ok    
      elseif instruction=30 or instruction=31 then      'fixed length or variable length
        A_RecChar[0]=0
        reccounter=0 
      elseif instruction=32 then            'output status on
        gosub output_status_on  
      elseif instruction=33 then            'input link all read
        gosub input_link_all_read  
      elseif instruction=34 then            'validation bit read
        gosub validation_bit_read  
      elseif instruction=35 then            'validation bit write
        gosub validation_bit_write  
      'elseif instruction=38 then            'input address read
      '  gosub input_address_read  
      'elseif instruction=39 then            'input address write
      '  gosub input_address_write          
      'elseif instruction=40 then            'output address read
      '  gosub output_address_read 
      'elseif instruction=41 then            'output address write
      '  gosub output_address_write  
      'elseif instruction=42 then            'input address list
      '  gosub input_address_list  
      'elseif instruction=43 then            'output address list
      '  gosub output_address_list  
      elseif instruction=44 then            'input number modules read
        gosub input_number_modules_read  
      elseif instruction=45 then            'input number modules write
        gosub input_number_modules_write 
      elseif instruction=46 then            'output number modules read
        gosub output_number_modules_read  
      elseif instruction=47 then            'output number modules write
        gosub output_number_modules_write
      elseif instruction=48 then            'Time read
        gosub time_read
      elseif instruction=49 then            'Time write
        gosub time_write
      elseif instruction=50 then            'schedule read
        gosub schedule_read
      elseif instruction=51 then            'schedule write
        gosub schedule_write
      elseif instruction=52 then            'schedule activate
        gosub schedule_activate        
      elseif instruction=53 then            'schedule queue list
        gosub schedule_queue_list
      elseif instruction=54 then            'schedule queue delete
        gosub schedule_queue_delete 
      elseif instruction=55 then            'startup read
        gosub startup_read
      elseif instruction=56 then            'startup write
        gosub startup_write
      elseif instruction=57 then            'startup list
        gosub startup_list
      elseif instruction=58 then            'startup activate
        gosub startup_activate
      'elseif instruction=59 then            'brightness read
      '  gosub brightness_read
      elseif instruction=60 then            'brightness list
        gosub brightness_list 
      'elseif instruction=61 then            'Temperature read
      '  gosub temperature_read
      elseif instruction=62 then            'Temperature list
        gosub temperature_list
      elseif instruction=63 then            'error list
        gosub error_list
      elseif instruction=64 then            'error clear
        gosub error_clear
      elseif instruction=65 then            'input debug on
        InputDebug=1
        gosub send_mes_ok
      elseif instruction=66 then            'input debug off
        InputDebug=0
        gosub send_mes_ok
      'elseif instruction=67 then            'humidity read
      '  gosub humidity_read
      elseif instruction=68 then            'humidity list
        gosub humidity_list
      elseif instruction=69 then            'Firmware Version
        gosub firmware_version
      'elseif instruction=70 then            'Thermostat mode read
      '  gosub thermostat_mode_read
      'elseif instruction=71 then            'Thermostat details read
      '  gosub thermostat_details_read 
      elseif instruction=72 then            'input list
        gosub input_list
      elseif instruction=73 then            'output list
        gosub output_list
      elseif instruction=74 then            'input name write
        gosub input_name_write
      elseif instruction=75 then            'output name write
        gosub output_name_write
      elseif instruction=76 then            'put echo on
        gosub echo_on
      elseif instruction=77 then            'put echo off
        gosub echo_off
      'elseif instruction=78 then            'dimmer step
      '  gosub dimmer_step_write
      'elseif instruction=79 then            'dimmer minimum
      '  gosub dimmer_minimum_write 
      'elseif instruction=80 then            'dimmer cycle
      '  gosub dimmer_cycle_write
      'elseif instruction=81 then            'dimmer memory
      '  gosub dimmer_memory_write 
      elseif instruction=82 then            'sensor name write
        gosub sensor_name_write 
      'elseif instruction=84 then            'dimmer step
      '  gosub dimmer_step_read
      'elseif instruction=85 then            'dimmer minimum
      '  gosub dimmer_minimum_read 
      'elseif instruction=86 then            'dimmer cycle
      '  gosub dimmer_cycle_read 
      'elseif instruction=87 then            'dimmer memory
      '  gosub dimmer_memory_read 
      elseif instruction=88 then            'Add virtual module
        gosub add_virtual_module        
 '     elseif instruction=88 then            'test start
 '       gosub test_start 
 '     elseif instruction=89 then            'test stop
 '       gosub test_stop       
      'elseif instruction=90 then            'cli mode read
      '  gosub cli_mode_read           
      'elseif instruction=91 then            'cli mode write
      '  gosub cli_mode_write 
      'elseif instruction=92 then            'automatic response read
      '  gosub automatic_response_read           
      'elseif instruction=93 then            'automatic response write
      '  gosub automatic_response_write
      elseif instruction=94 then            'STRCM0
        gosub strcm0           
      elseif instruction=95 then            'STRCM1
        gosub exit1
      'delete  
      elseif instruction=97 then            
        gosub timer_queue_list        
      elseif instruction=98 then            
        gosub pulse_counter_list
      elseif instruction=99 then            
        gosub pulse_counter_link_read
      elseif instruction=100 then           
        gosub pulse_counter_link_write
      Elseif instruction=101 then           
        gosub pulse_counter_name_write
      elseif instruction=102 then           'reset         
        gosub send_mes_ok
        asm
          reset
        endasm
      elseif instruction=103 then           'input enable list
        gosub input_enable_list
      elseif instruction=104 then           
        gosub input_invert_read
      elseif instruction=105 then           
        gosub input_invert_write
      elseif instruction=106 then           
        gosub sync_page  
      elseif instruction=107 then           
        gosub sync_stop
      elseif instruction=108 then           
        gosub sync_debug_on
      elseif instruction=109 then           
        gosub sync_debug_off                              
'      elseif instruction=113 then           
'        gosub setpoint_read
'      elseif instruction=114 then           
'        gosub setpoint_write
'      elseif instruction=115 then           
'        gosub programmed_setpoint_read
'      elseif instruction=116 then           
'        gosub programmed_setpoint_write
'      elseif instruction=117 then           
'        gosub pid_config_list
'      elseif instruction=118 then           
'        gosub pid_config_write 
'      elseif instruction=119 then           
'        gosub thermostat_link_read 
'      elseif instruction=120 then           
'        gosub thermostat_link_write 
'      elseif instruction=121 then           
'        gosub pid_debug_on
'      elseif instruction=122 then           
'        gosub pid_debug_off 
'      elseif instruction=123 then           
'        gosub thermostat_list
      elseif instruction=124 then           
        ResetI2c=1
        gosub send_mes_ok         
'      elseif instruction=125 then           
'        gosub pump_group_read
'      elseif instruction=126 then           
'        gosub pump_group_write 
'      elseif instruction=127 then           
'        gosub pump_output_read
'      elseif instruction=128 then           
'        gosub pump_output_write  
      'elseif instruction=129 then           
      '  gosub action_name_write
      'elseif instruction=130 then           
      '  gosub action_list 
      elseif instruction=131 then           
        gosub group_name_write
      elseif instruction=132 then           
        gosub group_list
      'elseif instruction=133 then           
      '  gosub decision_name_write
      elseif instruction=134 then           
        gosub can_control_erase
      elseif instruction=135 then           
        gosub schedule_name_write
      elseif instruction=136 then           
        gosub schedule_list 
'      Elseif instruction=137 then           
'        gosub thermostat_name_write
'      elseif instruction=138 then           
'        gosub thermostat_sensor_read
'      elseif instruction=139 then           
'        gosub thermostat_sensor_write
'      elseif instruction=140 then           
'        gosub thermostat_threshold_read                            
'      elseif instruction=141 then           
'        gosub thermostat_threshold_write                           
'      elseif instruction=142 then           
'        gosub thermostat_outside_link_read                          
'      elseif instruction=143 then           
'        gosub thermostat_outside_link_write  
      elseif instruction=144 then           
        gosub temperature_module_enable
      elseif instruction=145 then           
        gosub temperature_module_disable
      elseif instruction=146 then           
        gosub floor_level_read
      elseif instruction=147 then           
        gosub floor_level_write
      elseif instruction=148 then           
        gosub output_type_read
      elseif instruction=149 then           
        gosub output_type_write     
'      elseif instruction=152 then           
'        gosub Thermostat_program_data   
      elseif instruction=153 then           
        gosub Output_Indicate 
      elseif instruction=154 then           
        gosub Input_Indicate 
      elseif instruction=155 then           
        gosub Temperature_Indicate
'      elseif instruction=156 then           
'        gosub pump_delay_read
'      elseif instruction=157 then           
'        gosub pump_delay_write 
      elseif instruction=158 then   'erase CC inputs
        erase_type=ERASE_INPUTS          
        gosub erase_can_control
      elseif instruction=159 then   'erase CC sensors
        erase_type=ERASE_SENSORS         
        gosub erase_can_control 
      elseif instruction=160 then   'date write       
        gosub date_write                                                                                                                         
      endif                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
    endif
  else
    error_code=17
    gosub send_error  
  endif
return

check_button:
  if button2=0 then                         'button is pressed
    if PowerSafe=1 then                     'PowerSafe on modules is activated
      'A_QueueType[queue_end]=64          'Switch on leds on all modules for 2 minutes
      'A_QueueAction[queue_end]=1
      BA_type_queue=64
      BA_action_queue=1      
      gosub Increase_queue_pointer
      PowerSafe=0       
    endif   
  endif
return

'pid_debug_on:
'  PidMode=1
'  gosub send_mes_ok
'return

'pid_debug_off:
'  PidMode=0
'  gosub send_mes_ok
'return


strcm0:
  gosub send_mes_ok
return  

print_i2cdata_ok:
  hserout2 [dec i2cdata,13,10]       
  gosub send_mes_ok
return

'thermostat_threshold_read:
'  x=Temp_threshold
'  gosub temperature_display_sub
'  gosub display_LF_CR
'  gosub send_mes_ok
'return

'thermostat_threshold_write:
'  if digitcount=2 and A_DigitTotal[0]<95 then
'    t_word=A_DigitTotal[0]
'    x=t_word.byte0*2
'    if A_DigitTotal[1]<10 then
'      y=(A_DigitTotal[1]/5)
'    else
'      y=0
'    endif
'    i2cdata=x+y+64 
'    Temp_threshold=i2cdata
'    eep_addr.byte1=0                        'Page
'    eep_addr.byte0=17                       'address
'    gosub write_eeprom    
'    gosub send_mes_ok
'  else
'    error_code=23
'    gosub send_error 
'  endif
'return

temperature_module_enable:
  eep_addr.byte1=0                          'page
  eep_addr.byte0=15
  Temp_Mod_Installed=1
  i2cdata=0
  gosub write_eeprom       
  gosub send_mes_ok
return

temperature_module_disable:
  eep_addr.byte1=0                          'page
  eep_addr.byte0=15
  Temp_Mod_Installed=0
  i2cdata=255
  gosub write_eeprom       
  gosub send_mes_ok
return

'thermostat_outside_link_read:
'  hserout2 [dec Outside_Sensor,13,10]       
'  gosub send_mes_ok
'return

'pump_delay_read:
'  hserout2 [dec pump_delay,13,10]       
'  gosub send_mes_ok
'return

'thermostat_outside_link_write:
'  if digitcount=1 and A_DigitTotal[0]<MAX_SENSORS then
'    eep_addr.byte1=0                        'page
'    eep_addr.byte0=16
'    t_word=A_DigitTotal[0]
'    i2cdata=t_word.byte0
'    Outside_Sensor=i2cdata
'    gosub write_eeprom       
'    gosub send_mes_ok
'  else
'    error_code=23
'    gosub send_error 
'  endif
'return

input_invert_read:
  if digitcount=1 and A_DigitTotal[0]<240 then
    x=(A_DigitTotal[0]/8)+1
    y=A_DigitTotal[0]//8
    gosub calculate_invert 
    i2cdata=z
    gosub print_i2cdata_ok      
  else
    error_code=23
    gosub send_error 
  endif
return

Calculate_invert:
  z=A_InputInvert[x-1]>>y
  z=z.bit0
return

Calculate_input:
  InputResult=A_Input[x-1]>>y
  InputResult=InputResult.bit0
return

input_invert_write:
  if digitcount=2 and A_DigitTotal[0]<240 and A_DigitTotal[1]<2 then
    t_word=A_DigitTotal[0]
    t_word2=A_DigitTotal[1]
    x=(t_word.byte0)/8
    y=(t_word.byte0)//8
    z=t_word2.byte0
    if z=0 then                             'requested bit needs to be 0
      a=%00000001<<y
      a=~a
      if x<MAX_INPUT_MODULES then A_InputInvert[x]=A_InputInvert[x]&a
      i2cdata=0
    else                                    'requested bit needs to be 1
      a=%00000001<<y
      if x<MAX_INPUT_MODULES then A_InputInvert[x]=A_InputInvert[x]|a
      i2cdata=255
    endif
    eep_addr.byte1=32                       'Page
    eep_addr.byte0=t_word.byte0             'write invert status  
    gosub write_eeprom      
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error 
  endif
return

'pump_delay_write:
'  if digitcount=1 and A_DigitTotal[0]<249 then
'    eep_addr.byte1=0                        'page
'    eep_addr.byte0=19
'    t_word=A_DigitTotal[0]
'    i2cdata=t_word.byte0
'    pump_delay=i2cdata
'    gosub write_eeprom       
'    gosub send_mes_ok
'  else
'    error_code=23
'    gosub send_error 
'  endif
'return

schedule_queue_list:
  if sched_queue_counter>0 then
    for x=0 to (Sched_queue_max-1)
      if A_SchedType[x]<255 then
        hserout2 [dec3 x," ",dec A_SchedHour[x]," ",dec A_SchedMinute[x]," ",dec A_SchedDay[x]," ",dec A_SchedType[x]," ",dec A_SchedAction[x],13,10]  
      endif
    next x
  else  
    gosub empty_list
  endif  
  gosub send_mes_ok  
return

schedule_queue_delete:
  if digitcount=1 and A_DigitTotal[0]<102 then
    t_word=A_DigitTotal[0]
    y=t_word.byte0
    if y<Sched_queue_max then
      A_SchedHour[y]=255
      A_SchedMinute[y]=255
      A_SchedType[y]=255
      A_SchedAction[y]=255
      Sched_queue_counter=Sched_queue_counter-1 
    endif
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif
return

time_write:
  if digitcount=4 and A_DigitTotal[0]<24 and A_DigitTotal[1]<60 and A_DigitTotal[2]<60 and A_DigitTotal[3]<8 then
    i2caddr = 0                             'write seconds
    t_word=A_DigitTotal[2]
    gosub DS1307_write
    i2caddr = 1                             'write minutes
    t_word=A_DigitTotal[1]
    gosub DS1307_write  
    i2caddr = 2                             'write hours
    t_word=A_DigitTotal[0]
    gosub DS1307_write
    i2caddr = 3                             'write days
    t_word=A_DigitTotal[3]
    gosub DS1307_write
    gosub read_seconds
    gosub read_minutes
    gosub read_hours
    gosub read_day
    'gosub thermostat_timing
    gosub send_mes_ok  
  else
    error_code=23
    gosub send_error
  endif
return

date_write:
  if digitcount=3 and A_DigitTotal[0]<=31 and A_DigitTotal[0]>=1 and A_DigitTotal[1]<=12 and A_DigitTotal[1]>=1 and A_DigitTotal[2]<=99 and A_DigitTotal[3]<8 then
    i2caddr = 4                             'write Date
    t_word=A_DigitTotal[0]
    gosub DS1307_write  
    i2caddr = 5                             'write Month
    t_word=A_DigitTotal[1]
    gosub DS1307_write
    i2caddr = 6                             'write Year
    t_word=A_DigitTotal[2]
    gosub DS1307_write
    gosub read_date
    gosub send_mes_ok  
  else
    error_code=23
    gosub send_error
  endif
return

DS1307_write:
  x=t_word.byte0
  a=x//10
  b=x/10
  c=b<<4
  i2cdata = a|c    
  gosub write_i2c_2
return

time_read:
  hserout2 [dec hours,":",dec2 minutes,":",dec2 seconds," ",dec days," (",dec2 date,"-",dec2 month,"-",dec2 year,")",13,10]
  gosub send_mes_ok
return

firmware_version:
  hserout2 ["F",dec version,".",dec firmware,".",dec built," H",dec hardware,13,10]
  gosub send_mes_ok
return

'thermostat_mode_read:
'  gosub read_CH
'  hserout2 [c,": Thermostat ON=",dec ThermostatOn," (",dec ThermostatEnabled,")",13,10,"Automatic Mode=",dec ThermostatMode.bit3,13,10,BIN8 ThermostatMode,13,10]
'  if thermostatmode.bit6=1 then   'Multi-tenancy is enabled
'    Gosub MT1
'    for y=0 to (MAX_THERMOSTATS-1)
'      Gosub MT2
'    next y
'  endif
'  gosub send_mes_ok
'return

'MT1:
'  hserout2 ["Multi Tenancy enabled",13,10]
'return

'MT2:
'  eep_addr.byte1=199   'page
'  eep_addr.byte0=32+y
'  gosub read_eeprom 
'  hserout2 [dec2 y," ",bin8 i2cdata,13,10]
'return

input_link_all_read:                        'instruction "input link list"
  for x=1 to controller_in
    for y=0 to 7
      t_word=(x-1)*8+y
      hserout2 [dec3 t_word," "]
      gosub input_link_read_sub
    next y
  next x
  gosub send_mes_ok
return
          
basic_action_activate:
  if digitcount=2 and A_DigitTotal[0]<256 and A_DigitTotal[1]<256 then 
    t_word=A_DigitTotal[0]
    t_word2=A_DigitTotal[1]
    'A_QueueType[queue_end]=t_word.byte0
    'A_QueueAction[queue_end]=t_word2.byte0
    BA_type_queue=t_word.byte0
    BA_action_queue=t_word2.byte0
    BA_parameter_used=NO    
    gosub Increase_queue_pointer
    if mode_com=0 then
      gosub send_mes_ok
    endif
  elseif digitcount=3 and A_DigitTotal[0]<256 and A_DigitTotal[1]<256 then
    BA_type=A_DigitTotal[0]
    BA_action=A_DigitTotal[1]
    e_word=A_DigitTotal[2]
    BA_parameter_used=YES
    BA_parameter=e_word.byte0
    TimerRSenabled=1
    gosub check_queue_sub
    if mode_com=0 then
      gosub send_mes_ok
    endif      
  else
    error_code=23
    gosub send_error
  endif   
return          

group_activate:
  if digitcount=1 and A_DigitTotal[0]<160 then 
    'A_QueueType[queue_end]=2             'group Action
    t_word=A_DigitTotal[0]
    'A_QueueAction[queue_end]=t_word.byte0
    BA_type_queue=2
    BA_action_queue=t_word.byte0    
    gosub Increase_queue_pointer
    if mode_com=0 then
      gosub send_mes_ok
    endif
  else
    error_code=23
    gosub send_error
  endif
return


schedule_activate:
  if digitcount=1 and A_DigitTotal[0]<102 then
    t_word=A_DigitTotal[0]
    'A_QueueType[queue_end]=3             'scheduled Action
    'A_QueueAction[queue_end]=t_word.byte0
    BA_type_queue=3
    BA_action_queue=t_word.byte0     
    gosub Increase_queue_pointer
    if mode_com=0 then
      gosub send_mes_ok
    endif
  else
    error_code=23
    gosub send_error
  endif
return

action_read:                                'digittal[0]->Action nr, [1]->bank nr
  if digitcount=2 and A_DigitTotal[0]<204 and A_DigitTotal[1]<4 then
    t_word=A_DigitTotal[0]
    a=t_word.byte0/51
    b=t_word.byte0//51
    t_word2=A_DigitTotal[1]
    eep_addr.byte1=93+a+(4*t_word2.byte0)   'page
    eep_addr.byte0=(5*b)
    gosub read_eeprom
    x=i2cdata
    eep_addr.byte0=(5*b)+1
    gosub read_eeprom
    y=i2cdata    
    eep_addr.byte0=(5*b)+2
    gosub read_eeprom
    t_word2.byte0=i2cdata
    eep_addr.byte0=(5*b)+3
    gosub read_eeprom
    t_word2.byte1=i2cdata    
    eep_addr.byte0=(5*b)+4
    gosub read_eeprom
    z=i2cdata   
    hserout2 [dec x," ",dec y," ",dec t_word2," ",dec Z,13,10]       
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error 
  endif  
return

schedule_read:
  if digitcount=1 and A_DigitTotal[0]<102 then
    t_word=A_DigitTotal[0]
    a=t_word.byte0/51
    b=t_word.byte0//51
    eep_addr.byte1=113+a                    'page
    eep_addr.byte0=(5*b)
    gosub read_eeprom
    x=i2cdata
    eep_addr.byte0=(5*b)+1
    gosub read_eeprom
    y=i2cdata    
    eep_addr.byte0=(5*b)+2
    gosub read_eeprom
    q=i2cdata
    eep_addr.byte0=(5*b)+3
    gosub read_eeprom
    v=i2cdata    
    eep_addr.byte0=(5*b)+4
    gosub read_eeprom
    z=i2cdata  
    hserout2 [dec x," ",dec y," ",dec q," ",dec v," ",dec Z,13,10]       
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error 
  endif
return

display_LF_CR:
  hserout2 [13,10]
return

input_number_modules_read:
  if digitcount=0 then
    eep_addr.byte1=0                        'page
    eep_addr.byte0=1
    gosub read_eeprom
    gosub print_i2cdata_ok
  else
    error_code=23
    gosub send_error 
  endif  
return

output_number_modules_read:
  if digitcount=0 then
    eep_addr.byte1=0                        'page
    eep_addr.byte0=2
    gosub read_eeprom
    gosub print_i2cdata_ok
  else
    error_code=23
    gosub send_error 
  endif  
return

input_number_modules_write:
  if digitcount=1 and A_DigitTotal[0]<31 then
    eep_addr.byte1=0                        'page
    eep_addr.byte0=1
    t_word=A_DigitTotal[0]
    i2cdata=t_word.byte0
    gosub write_eeprom
    gosub eeprom_activate       
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error 
  endif
return

echo_on:
  eep_addr.byte1=0                          'page
  eep_addr.byte0=12
  i2cdata=255
  gosub write_eeprom
  EchoOnBit=1    
  gosub send_mes_ok
return

echo_off:
  eep_addr.byte1=0                          'page
  eep_addr.byte0=12
  i2cdata=0
  gosub write_eeprom
  EchoOnBit=0    
  gosub send_mes_ok
return

output_number_modules_write:
  if digitcount=1 and A_DigitTotal[0]<31 then
    eep_addr.byte1=0                        'page
    eep_addr.byte0=2
    t_word=A_DigitTotal[0]
    i2cdata=t_word.byte0
    gosub write_eeprom
    gosub eeprom_activate       
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error 
  endif
return

address_read:
  for j=0 to 3
    eep_addr.byte0=j
    gosub read_eeprom
    hserout2 [dec i2cdata]
    if j<>3 then
      hserout2 ["."]     
    endif
  next j
  Gosub display_LF_CR 
return

can_control_erase:
  if digitcount=5 and A_DigitTotal[0]<3 and A_DigitTotal[1]="C" then
    gosub send_fx_can
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error 
  endif
return

Send_fx_can:          'Sent FX on RS485 bus
  gosub Empty_RecInstr
  A_SerString[0]="F"
  A_SerString[1]="X"
  A_SerString[3]=A_DigitTotal[1]
  A_SerString[4]=A_DigitTotal[2]
  A_SerString[5]=A_DigitTotal[3]
  A_SerString[6]=A_DigitTotal[4]
  A_SerString[7]=A_DigitTotal[0]
  CRC2=A_SerString[0]+A_SerString[1]+A_SerString[3]+A_SerString[4]+A_SerString[5]+A_SerString[6]+A_SerString[7]
  A_SerString[8]="C"
  A_SerString[9]=CRC2.byte1
  A_SerString[10]=CRC2.byte0
  gosub send_Fx_data
return

address_write:
  for j=0 to 3
    eep_addr.byte0=j
    t_word2=A_DigitTotal[j+1]
    i2cdata=t_word2.byte0
    gosub write_eeprom      
  next j
return

startup_read:
  if A_DigitTotal[0]<100 and digitcount=1 then'startup read
    eep_addr.byte1=1                        'page
    t_word=A_DigitTotal[0]
    eep_addr.byte0=T_word.byte0*2
    gosub read_eeprom
    x=i2cdata
    eep_addr.byte0=T_word.byte0*2+1
    gosub read_eeprom
    y=i2cdata  
    hserout2 [dec3 x," ",dec3 y,13,10]   
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif
return

startup_write:
  if A_DigitTotal[0]<100 and digitcount=3 then'startup write
    eep_addr.byte1=1                        'page
    t_word=A_DigitTotal[0]
    eep_addr.byte0=T_word.byte0*2
    t_word2=A_DigitTotal[1]
    i2cdata=t_word2.byte0
    gosub write_eeprom
    eep_addr.byte0=T_word.byte0*2+1
    t_word2=A_DigitTotal[2]
    i2cdata=t_word2.byte0  
    gosub write_eeprom    
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif
return

startup_list:
  eep_addr.byte1=1                          'page
  for j=0 to 99
    eep_addr.byte0=j*2
    gosub read_eeprom
    x=i2cdata
    eep_addr.byte0=j*2+1
    gosub read_eeprom
    y=i2cdata
    if x<>255 then    
      hserout2 [dec2 j," ",dec3 x," ",dec3 y,13,10]
    else
      if j=0 then
        gosub empty_list
      endif
      j=99  
    endif      
  next j
  gosub send_mes_ok
return

startup_activate:
  eep_addr.byte1=1                          'page
  for j=0 to 99
    eep_addr.byte0=j*2
    gosub read_eeprom
    x=i2cdata
    eep_addr.byte0=j*2+1
    gosub read_eeprom
    y=i2cdata
    if x<>255 then                          'add to queue   
      'A_QueueType[queue_end]=x
      'A_QueueAction[queue_end]=y
      BA_type_queue=x
      BA_action_queue=y       
      gosub Increase_queue_pointer
    else
      j=99  
    endif      
  next j
  gosub send_mes_ok
return

'pump_group_read:
'  if A_DigitTotal[0]<8 and digitcount=1 then  'pump group read
'    t_word=A_DigitTotal[0]
'    x=t_word.byte0
'    for j=0 to 31
'      eep_addr.byte1=143+(59*thermostatCooling)                    'page 143 or 201
'      eep_addr.byte0=(x*32)+j
'      gosub read_eeprom
'      a=i2cdata
'      if a<>255 then    
'        length=16                           'Max number of characters      
'        hserout2 [dec2 j," ",dec3 a," "]    
'        gosub eeprom_output_address         'Calculate eeprom output address
'        Spaces=0 
'        gosub display_name
'        gosub display_LF_CR             
'      else
'        if j=0 then
'          gosub empty_list
'        endif  
'        j=31                                'exit
'      endif
'    next j
'    gosub send_mes_ok
'  else
'    error_code=23
'    gosub send_error
'  endif
'return 

'pump_group_write:
'  if A_DigitTotal[0]<8 and A_DigitTotal[1]<32 and digitcount=3 then            'pump group write
'    t_word=A_DigitTotal[0]
'    a=t_word.byte0
'    t_word=A_DigitTotal[1]
'    b=t_word.byte0  
'    eep_addr.byte1=143+(59*thermostatCooling)                      'page 143 or 201
'    eep_addr.byte0=(a*32)+b
'    t_word2=A_DigitTotal[2]
'    i2cdata=t_word2.byte0  
'    gosub write_eeprom
'    gosub send_mes_ok
'  else
'    error_code=23
'    gosub send_error
'  endif
'return

'pump_output_write:
'  if A_DigitTotal[0]<8 and digitcount=2 then  'pump output write
'    t_word=A_DigitTotal[0]
'    a=t_word.byte0
'    t_word=A_DigitTotal[1]
'    b=t_word.byte0  
'    eep_addr.byte1=144+(59*thermostatCooling)                      'page 144 or 203
'    eep_addr.byte0=a
'    i2cdata=b  
'    gosub write_eeprom
'    gosub send_mes_ok
'  else
'    error_code=23
'    gosub send_error
'  endif
'return

'pump_output_read:
'  if A_DigitTotal[0]<8 then                   'pump output read
'    t_word=A_DigitTotal[0]
'    a=t_word.byte0 
'    eep_addr.byte1=144+(59*thermostatCooling)                      'page 144 or 203
'    eep_addr.byte0=a  
'    gosub read_eeprom
'    a=i2cdata                               'output number
'    length=16                               'Max number of characters       
'    hserout2 [dec3 a," "]    
'    gosub eeprom_output_address             'Calculate eeprom output address
'    Spaces=0
'    gosub display_name
'    gosub display_LF_CR     
'    gosub send_mes_ok
'  else
'    error_code=23
'    gosub send_error
'  endif
'return

group_read:
  if A_DigitTotal[0]<160 and digitcount=1 then                                    'group read
    t_word=A_DigitTotal[0]
    a=t_word.byte0/8
    b=t_word.byte0//8
    eep_addr.byte1=67+a                     'page
    for j=0 to 15
      eep_addr.byte0=((T_word.byte0-(8*a))*32)+(j*2)
      gosub read_eeprom
      x=i2cdata
      eep_addr.byte0=((T_word.byte0-(8*a))*32)+(j*2)+1
      gosub read_eeprom
      y=i2cdata    
      hserout2 [dec2 j," ",dec3 x," ",dec3 y,13,10]      
    next j
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif
return

group_write:                                '[0]->group nr, [1]->position, [2]->Action byte, [3]->Action number
  if A_DigitTotal[0]<160 and A_DigitTotal[1]<16 and digitcount=4 then          'group write
    t_word=A_DigitTotal[0]
    a=t_word.byte0/8
    b=t_word.byte0//8
    eep_addr.byte1=67+a                     'page
    t_word2=A_DigitTotal[1]
    eep_addr.byte0=((T_word.byte0-(8*a))*32)+(t_word2.byte0*2)
    t_word2=A_DigitTotal[2]
    i2cdata=t_word2.byte0  
    gosub write_eeprom
    t_word2=A_DigitTotal[1]
    eep_addr.byte0=((T_word.byte0-(8*a))*32)+(t_word2.byte0*2)+1
    t_word2=A_DigitTotal[3]
    i2cdata=t_word2.byte0
    gosub write_eeprom
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif
return

schedule_write:
  if digitcount=6 and A_DigitTotal[0]<102 and A_DigitTotal[1]<25 and A_DigitTotal[2]<60 then
    t_word=A_DigitTotal[0]
    a=t_word.byte0/51
    b=t_word.byte0//51
    eep_addr.byte1=113+a                    'page
    for j=0 to 4
      t_word2=A_DigitTotal[1+j]
      eep_addr.byte0=(5*b)+j
      i2cdata=t_word2.byte0
      gosub write_eeprom    
    next j 
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error 
  endif
return

dim_min:
  if digitcount=2 and A_DigitTotal[0]<MAX_OUTPUTS and A_DigitTotal[1]<63 then               'dim-
    t_word=A_DigitTotal[0]
    t_word2=A_DigitTotal[1]
    if (A_DimmerValue[t_word.byte0]-dim_minimum)>t_word2.byte0 then
      A_DimmerValue[t_word.byte0]=A_DimmerValue[t_word.byte0]-t_word2.byte0
    else
      A_DimmerValue[t_word.byte0]=dim_minimum
    endif
    dimmer_value_eeprom_write=YES
    write_yes=1
    if ((t_word.byte0)/8)<MAX_OUTPUT_MODULES then A_WriteYesMod[(t_word.byte0)/8]=1
    A_OutUpdate[t_word.byte0]=1
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error     
  endif
return

dim_plus:
  if digitcount=2 and A_DigitTotal[0]<MAX_OUTPUTS and A_DigitTotal[1]<63 then               'dim+
    t_word=A_DigitTotal[0]
    t_word2=A_DigitTotal[1]
    A_DimmerValue[t_word.byte0]=A_DimmerValue[t_word.byte0]+t_word2.byte0
    if A_DimmerValue[t_word.byte0]>63 then
      A_DimmerValue[t_word.byte0]=63
    endif
    write_yes=1
    dimmer_value_eeprom_write=YES
    if ((t_word.byte0)/8)<MAX_OUTPUT_MODULES then A_WriteYesMod[(t_word.byte0)/8]=1
    A_OutUpdate[t_word.byte0]=1
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error   
  endif
return

module_discover_stop:
  if digitcount=0 then                      'input read stop
    gosub bus_live
    gosub send_mes_ok
    EepPage0=1
    OledEeprom.byte0 = 0
    OledEeprom.byte1 = 0
  else
    error_code=23
    gosub send_error  
  endif          
return

module_discover_start:
  if digitcount=0 then
    'pause 50
    gosub bus_init
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error  
  endif  
return

discover_can_control:
  if digitcount=1 and A_DigitTotal[0]<5 and A_DigitTotal[0]>0 then
    'pause 50
    gosub bus_init
    'pause 100
    broad1="I"
    broad2="D"
    broaddata=A_DigitTotal[0]
    BroadID="C"    'for CAN modules only
    gosub Add_Broad_queue
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error   
  endif     
return

exit1:                                      'go back to API mode
  gosub bus_live
  Mode_com=1                                'API mode
  debugmode=0                               'switch off debug mode
  InputDebug=0                              'Input debug off
  SyncDebug=0                               'Sync debug off
return

eeprom_write:
  if A_DigitTotal[0]<256 and A_DigitTotal[1]<256 and A_DigitTotal[2]<256 and digitcount=3 then
    t_word=A_DigitTotal[1]
    eep_addr.byte0=t_word.byte0             'address
    t_word=A_DigitTotal[0]
    eep_addr.byte1=t_word.byte0             'page
    t_word=A_DigitTotal[2]
    i2cdata=t_word.byte0
    gosub write_eeprom  
    gosub send_mes_ok
  else
    error_code=20
    gosub send_error
  endif
return

eeprom_read:
  if A_DigitTotal[0]<256 and A_DigitTotal[1]<256 and digitcount=2 then
    t_word=A_DigitTotal[1]
    eep_addr.byte0=t_word.byte0             'address
    t_word=A_DigitTotal[0]
    eep_addr.byte1=t_word.byte0             'page
    gosub read_eeprom  
    gosub print_i2cdata_ok
  else
    error_code=18
    gosub send_error
  endif
return

output_timer_write:
  if A_DigitTotal[0]<MAX_OUTPUTS and digitcount=2 then
    t_word=A_DigitTotal[0]
    a=t_word.byte0/8
    b=t_word.byte0//8
    eep_addr.byte1=33+a                     'page
    eep_addr.byte0=4+(b*2)
    t_word2=A_DigitTotal[1]
    i2cdata=t_word2.byte0
    gosub write_eeprom
    i2cdata=t_word2.byte1
    eep_addr.byte0=5+(b*2)
    gosub write_eeprom
    A_TimerCd[t_word.byte0]=t_word2
    gosub send_mes_ok
  else
    error_code=22
    gosub send_error
  endif
return

output_timer_read:
  if A_DigitTotal[0]<240 and digitcount=1 then
    timer=A_DigitTotal[0]
    gosub Timer_value_read
    hserout2 [dec timer,13,10]
    gosub send_mes_ok
  else
    error_code=21
    gosub send_error
  endif 
return

Timer_value_read:
  a=timer.byte0/8
  b=timer.byte0//8
  eep_addr.byte1=33+a                       'page
  eep_addr.byte0=4+(b*2)
  gosub read_eeprom
  timer.byte0=i2cdata
  eep_addr.byte0=5+(b*2)
  gosub read_eeprom
  timer.byte1=i2cdata
  if timer=65535 then timer=0
return

validation_bit_read:
  if A_DigitTotal[0]<256 and digitcount=1 then
    t_word=A_DigitTotal[0]
    a=t_word.byte0
    hserout2 [dec A_ValBit[a],13,10]
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif 
return

validation_bit_write:
  if A_DigitTotal[0]<256 and A_DigitTotal[1]<2 and digitcount=2 then
    t_word=A_DigitTotal[0]
    a=t_word.byte0
    t_word=A_DigitTotal[1]
    b=t_word.byte0
    A_ValBit[a]=b
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif
return

output_status_read:
  if A_DigitTotal[0]<240 and digitcount=1 then
    t_word=A_DigitTotal[0]
    gosub display_output_status
    gosub display_LF_CR  
    gosub send_mes_ok   
  else
    error_code=23
    gosub send_error
  endif
return

display_output_status:
  x=(t_word.byte0)//8
  y=(t_word.byte0)/8
  z=A_Output[y]>>x
  if z.bit0=1 then
    hserout2 ["1 "]
  else
    hserout2 ["0 "]
  endif
  hserout2 [dec A_DimmerValue[t_word.byte0]," "]
  a=t_word
  length=16
  Spaces=0 
  gosub eeprom_output_address
  gosub display_name
return

Dimmer_Group_follow:
  if q<MAX_OUTPUTS then                           'Check follow output only when it's a valid output
    r=q
    eep_addr.byte1=65                     'page
    eep_addr.byte0=q  
    gosub read_eeprom
    if i2cdata<240 then                   'a "follow" output is defined
      gosub check_output                  'check if output is on, q must contain output nr 
      v=z                                 'result of check_output in v
      q=i2cdata
      gosub check_output                  'check if output is on, q must contain output nr                
      if v.bit0=1 and z.bit0=0 then       'Output is on
        'A_QueueType[queue_end]=161     'Output On
        'A_QueueAction[queue_end]=i2cdata
        BA_type_queue=161
        BA_action_queue=i2cdata        
        gosub Increase_queue_pointer
        A_DimmerValue[i2cdata]=A_DimmerValue[r]
        dimmer_value_eeprom_write=YES
      elseif v.bit0=0 and z.bit0=1 then
        'A_QueueType[queue_end]=160     'Output Off
        'A_QueueAction[queue_end]=i2cdata
        BA_type_queue=160
        BA_action_queue=i2cdata 
        gosub Increase_queue_pointer        
      endif
    endif
    q=r
    eep_addr.byte1=66                     'group follow page
    eep_addr.byte0=q  
    gosub read_eeprom 
    if i2cdata<160 then                   'a "follow" group is defined 
      'A_QueueType[queue_end]=2         'Group
      'A_QueueAction[queue_end]=i2cdata
      BA_type_queue=2
      BA_action_queue=i2cdata  
      gosub Increase_queue_pointer   
    endif       
  endif
return


output_on_overrule:
  A_DigitTotal[0]=BA_action
  t_word=A_DigitTotal[0]
  if t_word<MAX_OUTPUTS then
    gosub output_on_sub
    timer=A_DigitTotal[0]
    gosub timer_value_read
    A_TimerCd[t_word.byte0]=timer
  endif
return

        
erase_can_control:
    if mode=="I" and digitcount==4 then     'This instruction can only be executed when in Init mode and 4 ID's (of the CC to be erased) have been entered
        RS485Message="B"
        if erase_type==ERASE_SENSORS then   'Erase sensors
            A_e[5]="S"         
        else                                'Erase inputs
            A_e[5]="I"
        endif
        A_e[0]=A_DigitTotal[0]
        A_e[1]=A_DigitTotal[1]
        A_e[2]=A_DigitTotal[2]
        A_e[3]=A_DigitTotal[3]
        A_e[4]="E"
        A_e[6]=171
        A_e[7]=0
        A_e[8]=0
        CRC2=A_e[0]+A_e[1]+A_e[2]+A_e[3]+A_e[4]+A_e[5]
        A_e[15]="C"
        A_e[16]=CRC2.byte1
        A_e[17]=CRC2.byte0                
        gosub send_rs485_long 
        gosub send_mes_ok 
    else                                    'Return error
        error_code=29
        gosub send_error    
    endif
return        


output_on:
  t_word=A_DigitTotal[0]
  eep_addr.byte1=231                    'page
  eep_addr.byte0=t_word.byte0           'Read Output block function of this output
  gosub read_eeprom
  if i2cdata=255 or A_ValBit[i2cdata]=0 then  'a "Block" output is NOT defined or Validation Bit=0 (so not blocked)
    y=(A_DigitTotal[0])/8
    if A_DigitTotal[0]<MAX_OUTPUTS and A_DigitTotal[1]<240 then
      A_OutUpdate[t_word.byte0]=1
      if digitcount=3 then
        A_TimerCd[t_word.byte0]=A_DigitTotal[2]
        t_word2=A_DigitTotal[1]
        if A_ModID0[30+y]="D" or A_ModID0[30+y]="d" then             'only when dimmer
          A_DimmerValue[t_word.byte0]=t_word2.byte0
          dimmer_value_eeprom_write=YES
        else
          A_DimmerValue[t_word.byte0]=63
        endif
        gosub output_on_sub     
      endif          
      if digitcount=2 then
        t_word2=A_DigitTotal[1]
        if A_ModID0[30+y]="D" or A_ModID0[30+y]="d" then             'only when dimmer
          A_DimmerValue[t_word.byte0]=t_word2.byte0
          dimmer_value_eeprom_write=YES
        else
          A_DimmerValue[t_word.byte0]=63
        endif
        gosub output_on_sub
      endif
      if digitcount=1 then
        gosub output_on_sub
      endif
      if mode_com=0 and queue_end=0 then
        gosub send_mes_ok
      endif
      OdCode=12                               'Output debug code
      OdOutputNr=t_word.byte0
      gosub Output_debug                      'Display on console when outbug debug is on   
    else
      error_code=16
      gosub send_error
    endif
  else
    if mode_com=0 and queue_end=0 then
      gosub send_mes_ok
    endif    
  endif     
return

output_on_sub:
  x=(t_word.byte0)//8
  y=(t_word.byte0)/8
  z=%00000001
  z=z<<x
  if y<MAX_OUTPUT_MODULES then A_Output[y]=A_Output[y]|z
  write_yes=1
  if y<MAX_OUTPUT_MODULES then A_WriteYesMod[y]=A_WriteYesMod[y]+1
  tp=q
  q=t_word.byte0
  gosub Dimmer_Group_follow
  q=tp 
return

output_off:
  if A_DigitTotal[0]<MAX_OUTPUTS and digitcount=1 then
    x=A_DigitTotal[0]
    timer=A_DigitTotal[0]
    gosub timer_value_read
    A_TimerCd[x]=timer  
    t_word=A_DigitTotal[0]
    x=(t_word.byte0)//8
    y=(t_word.byte0)/8
    z=%00000001
    z=z<<x
    z=~z
    if y<MAX_OUTPUT_MODULES then A_Output[y]=A_Output[y]&z
    A_OutUpdate[t_word.byte0]=1
    write_yes=1
    if y<MAX_OUTPUT_MODULES then A_WriteYesMod[y]=A_WriteYesMod[y]+1
    if mode_com=0 and queue_end=0 then
      gosub send_mes_ok
    endif
    OdCode=13                               'Output debug code
    OdOutputNr=t_word.byte0
    gosub Output_debug                      'Display on console when outbug debug is on
    tp=q
    q=t_word.byte0
    gosub Dimmer_Group_follow
    q=tp     
  else
    error_code=15
    gosub send_error
  endif  
return

input_link_write:
  if A_DigitTotal[0]<240 and A_DigitTotal[1]<256 and digitcount=2 then
    t_word=A_DigitTotal[0]
    a=t_word.byte0/8
    b=t_word.byte0//8
    eep_addr.byte1=2+a                      'page 2 to 31
    eep_addr.byte0=4+b                      'byte 4 to 11
    t_word2=A_DigitTotal[1]
    i2cdata=t_word2.byte0
    gosub write_eeprom
    gosub eeprom_activate
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif
return

input_action_read:                          'A_DigitTotal[0]-> input number
  if A_DigitTotal[0]<240 and digitcount=1 then            'input Action read
    ok=0
    gosub input_link_read
    ok=1
    t_word=A_DigitTotal[0]
    a=t_word.byte0/8
    b=t_word.byte0//8
    eep_addr.byte1=2+a                      'page
    for j=0 to 14
      eep_addr.byte0=12+(30*b)+(j*2)
      gosub read_eeprom
      x=i2cdata
      eep_addr.byte0=13+(30*b)+(j*2)
      gosub read_eeprom
      y=i2cdata
      hserout2 [dec2 j," ",dec3 x," ",dec3 y,13,10]      
    next j
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif  
return

output_status_on:
  if digitcount=0 and controller_out>0 then
    AllOff=1
    for j=0 to (controller_out-1)
      if A_Output[j]>0 then
        y=A_Output[j]
        for x=0 to 7
          z=y>>x
          if z.bit0=1 then
            AllOff=0                        'not all lights are off
            if mode_com=0 then              'CLI mode
              hserout2 [dec3 (j*8)+x," ",dec3 A_DimmerValue[(j*8)+x]," ",dec5 A_TimerCd[(j*8)+x]," "]
              a=(j*8)+x
              length=16
              Spaces=0 
              gosub eeprom_output_address
              gosub display_name
              gosub display_LF_CR
            endif
          endif
        next x
      endif
    next j
    if mode_com=0 then                      'CLI mdoe
      gosub send_mes_ok
    else                                    'advanced mode
      if AllOff=1 then
        Hserout2 ["ON",0,0,0,0,0,0,0,0,0,0,0,0,0,13,10]
      endif    
    endif 
  else
    error_code=23
    gosub send_error
  endif  
return

'read_CH:
'  if ThermostatCooling=0 then           'Heating
'    c="H"
'  else                                    'Cooling
'    c="C"
'  endif
'return

'thermostat_list:
'  gosub read_CH
'  for j=0 to (MAX_THERMOSTATS-1)
'    hserout2 [c,": ",dec2 j," "]
'    a=j
'    length=16
'    Spaces=0
'    gosub eeprom_thermostat_address
'    gosub display_name      
'    hserout2 [" "]
'    x=A_Setpt[j]
'    gosub temperature_display_sub
'    y=A_ThermostatSensor[j]
'    x=A_Temperature[y]
'    gosub temperature_display_sub
'    hserout2 ["(",dec A_ThermostatSensor[j],") - "]
'    t_word=A_Thermostat[j]
'    gosub display_output_status
'    hserout2 ["(",dec A_Thermostat[j],") - "]
'    t_word=A_Thermostat2[j]
'    gosub display_output_status
'    hserout2 ["(",dec A_Thermostat2[j],") "]      
'    gosub display_LF_CR
'  next j
'  gosub send_mes_ok 
'return

input_action_write:                         'A_DigitTotal[0]->input number, [1]->input Action number, [2]->Action type, [3]->Action number
  if A_DigitTotal[0]<240 and digitcount=4 and A_DigitTotal[1]<15 then            'input Action write
    t_word=A_DigitTotal[0]
    a=t_word.byte0/8
    b=t_word.byte0//8
    eep_addr.byte1=2+a                      'page
    t_word2=A_DigitTotal[1]
    eep_addr.byte0=12+(30*b)+(t_word2.byte0*2)
    t_word=A_DigitTotal[2]
    i2cdata=t_word.byte0
    gosub write_eeprom
    eep_addr.byte0=13+(30*b)+(t_word2.byte0*2)
    t_word=A_DigitTotal[3]
    i2cdata=t_word.byte0
    gosub write_eeprom
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif  
return

simple_action_read:                         'A_DigitTotal[0]-> input number, A_DigitTotal[1]-> bank nr
  t_word=A_DigitTotal[0]
  a=t_word.byte0/8
  b=t_word.byte0//8
  eep_addr.byte1=2+a                        'page
  for j=0 to 14
    eep_addr.byte0=12+(30*b)+(j*2)
    gosub read_eeprom
    x=i2cdata
    eep_addr.byte0=13+(30*b)+(j*2)
    gosub read_eeprom
    y=i2cdata
    hserout2 [dec2 j," ",dec3 x," ",dec3 y,13,10]      
  next j  
return

input_link_read:
  if A_DigitTotal[0]<240 and digitcount=1 then
    t_word=A_DigitTotal[0]
    gosub input_link_read_sub
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif  
return

pulse_counter_link_read:
  if A_DigitTotal[0]<PULSECOUNTERS and digitcount=1 then
    t_word=A_DigitTotal[0]
    a=t_word.byte0
    i2cdata=A_PulseInput[a] 
    gosub print_i2cdata_ok
  else
    error_code=23
    gosub send_error
  endif 
return

pulse_counter_link_write:
  if A_DigitTotal[0]<PULSECOUNTERS and digitcount=2 then
    t_word=A_DigitTotal[0]
    a=t_word.byte0
    eep_addr.byte1=0                        'page 0
    eep_addr.byte0=160+a
    t_word=A_DigitTotal[1] 
    i2cdata=t_word.byte0   
    gosub write_eeprom  
    A_PulseInput[a]=t_word.byte0
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif 
return

floor_level_read:
  if A_DigitTotal[0]<240 and digitcount=1 then
    t_word=A_DigitTotal[0]
    a=t_word.byte0/8
    b=t_word.byte0//8
    eep_addr.byte1=33+a                     'page 33 and higher
    eep_addr.byte0=157+b    
    gosub read_eeprom  
    gosub print_i2cdata_ok
  else
    error_code=23
    gosub send_error
  endif  
return

floor_level_write:
  if A_DigitTotal[0]<240 and digitcount=2 then
    t_word=A_DigitTotal[0]
    a=t_word.byte0/8
    b=t_word.byte0//8
    eep_addr.byte1=33+a                     'page 33 and higher
    eep_addr.byte0=157+b
    t_word=A_DigitTotal[1] 
    i2cdata=t_word.byte0   
    gosub write_eeprom  
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif 
return

Output_Indicate:
  if A_DigitTotal[0]<240 and digitcount=1 then
    gosub normal_Powerstate                 'Put leds of all modules in normal powerstate
    t_word=A_DigitTotal[0]
    indicate=t_word.byte0
    IndicateInput=0
    IndicateTemperature=0
    write_yes=1
    if (indicate/8)<MAX_OUTPUT_MODULES then A_WriteYesMod[indicate/8]=1  
    gosub send_mes_ok
    OdCode=14                               'Output debug code
    OdOutputNr=indicate
    gosub Output_debug                      'Display on console when outbug debug is on 
  else
    error_code=23
    gosub send_error
  endif 
return

Queue_output_indicate:
  ok=0
  Digitcount=1
  A_DigitTotal[0]=BA_action
  gosub output_indicate
return

Temperature_Indicate:
  if A_DigitTotal[0]<32 and digitcount=1 then
    gosub normal_Powerstate                 'Put leds of all modules in normal powerstate
    t_word=A_DigitTotal[0]
    indicate=t_word.byte0
    IndicateInput=0
    IndicateTemperature=1  
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif 
return

Queue_sensor_indicate:
  ok=0
  Digitcount=1
  A_DigitTotal[0]=BA_action
  gosub temperature_indicate
return

Input_Indicate:
  if A_DigitTotal[0]<240 and digitcount=1 then
    gosub normal_Powerstate                 'Put leds of all modules in normal powerstate
    t_word=A_DigitTotal[0]
    indicate=t_word.byte0
    IndicateInput=1
    IndicateTemperature=0  
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif 
return

Queue_input_indicate:
  ok=0
  Digitcount=1
  A_DigitTotal[0]=BA_action
  gosub input_indicate
return

Virtual_input_press:
  x=BA_action
  y=x/8
  z=x//8
  if A_ModID0[y]="i" then   'Only for virtual inputs
    A_RS485string[4]=~(A_Input[y]|(%00000001<<z))
    i=y+1  
    if (i-1)<MAX_INPUT_MODULES then gosub analyse_input
  endif  
return

Virtual_input_release:
  x=BA_action
  y=x/8
  z=x//8
  if A_ModID0[y]="i" then   'Only for virtual inputs
    vi=~(%00000001<<z)
    A_RS485string[4]=~(A_Input[y]&vi)
    i=y+1  
    if (i-1)<MAX_INPUT_MODULES then gosub analyse_input
  endif 
  
return

output_type_read:
  if A_DigitTotal[0]<240 and digitcount=1 then
    t_word=A_DigitTotal[0]
    a=t_word.byte0/8
    b=t_word.byte0//8
    eep_addr.byte1=33+a                     'page 33 and higher
    eep_addr.byte0=149+b  
    gosub read_eeprom
    gosub print_i2cdata_ok
  else
    error_code=23
    gosub send_error
  endif  
return

output_type_write:
  if A_DigitTotal[0]<240 and digitcount=2 then
    t_word=A_DigitTotal[0]
    a=t_word.byte0/8
    b=t_word.byte0//8
    eep_addr.byte1=33+a                     'page 33 and higher
    eep_addr.byte0=149+b
    t_word=A_DigitTotal[1] 
    i2cdata=t_word.byte0   
    gosub write_eeprom  
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif 
return

input_link_read_sub:
  a=t_word.byte0/8
  b=t_word.byte0//8
  eep_addr.byte1=2+a                        'page 2 to 31
  eep_addr.byte0=4+b                        'byte 4 to 11
  gosub read_eeprom
  u=i2cdata
  a=t_word
  length=8
  c=i2cdata
  Spaces=0
  gosub eeprom_input_address
  gosub display_name
  hserout2 [" -> ",dec3 u," "]
  a=c
  Spaces=0
  length=16
  gosub eeprom_output_address
  gosub display_name
  gosub display_LF_CR
return

brightness_list:
  for j=0 to 31
    if A_ldr[j]<>255 then    
      hserout2 [dec2 j," ",dec3 A_ldr[j]]
    else
      gosub sensor_not_connected  
    endif
    gosub display_sensor_name      
  next j 
gosub send_mes_ok
return

empty_list:
  hserout2 ["Empty list",13,10] 
return

'pid_config_list:
'  gosub read_CH
'  eep_addr.byte1=141+(59*thermostatCooling)                        'Page 141 or 200
'  for pid=0 to (MAX_THERMOSTATS-1)
'    for x=0 to 3
'      eep_addr.byte0=(pid*4)+x
'      gosub read_eeprom
'      A_SerString[x]=i2cdata
'    next x
'    Hserout2 [c,": PID parameters ",dec2 pid,": Kp=",dec3 A_SerString[0]," Ki=",dec3 A_SerString[1]," Kd=",dec3 A_SerString[2]," It=",Dec3 A_SerString[3],13,10]
'  next pid
'  gosub send_mes_ok
'return

'pid_config_write:
'  if digitcount=5 and A_DigitTotal[0]<MAX_THERMOSTATS then
'    t_word=A_DigitTotal[0]
'    pid=t_word.byte0
'    eep_addr.byte1=141+(59*thermostatCooling)                      'Page 141 or 200
'    for x=0 to 3
'      t_word=A_DigitTotal[x+1]
'      i2cdata=t_word.byte0
'      eep_addr.byte0=(pid*4)+x              'address
'      gosub write_eeprom  
'    next x
'    gosub send_mes_ok         
'  else
'    error_code=23
'    gosub send_error 
'  endif
'return

'setpoint_read:
'  if digitcount=1 and A_DigitTotal[0]<MAX_THERMOSTATS then
'    t_word=A_DigitTotal[0]
'    j=t_word.byte0
'    x=A_Setpt[j]
'    gosub temperature_display 
'    gosub display_LF_CR 
'    gosub send_mes_ok
'  else
'    error_code=23
'    gosub send_error 
'  endif
'return

'thermostat_details_read:
'  if digitcount=1 and A_DigitTotal[0]<MAX_THERMOSTATS then
'    t_word=A_DigitTotal[0]
'    j=t_word.byte0
'    pid=j
'    gosub read_CH
'    hserout2 [c,": Current Setpoint: "] 
'    x=A_Setpt[j]
'    gosub temperature_display 
'    gosub display_LF_CR 
'    for a=0 to 5                            'display setpoints
'      hserout2 ["Programmed Setpoint ",dec a,": "]
'      gosub programmed_setpoint_read_sub
'    next a                                  'display timings
'    for y=1 to 7                            'display Monday till Sunday
'      hserout2 [dec y," "]
'      for z=0 to 3                          'Display 2x start-stop time
'        a=18+((y-1)*4)+z
'        gosub programmed_timings
'        gosub read_eeprom
'        if i2cdata<145 then
'          hserout2 [dec2 (i2cdata/6),":",dec2 (i2cdata//6)*10," "]
'        else
'          hserout2 ["--:-- "]     
'        endif  
'      next z
'      gosub display_LF_CR  
'    next y
'    if thermostatmode.bit6=1 then   'Multi-tenancy is enabled
'      Gosub MT1
'      y=j
'      Gosub MT2
'    endif  
'    gosub send_mes_ok
'  else
'    error_code=23
'    gosub send_error 
'  endif
'return

'thermostat_link_read:
'  if digitcount=1 and A_DigitTotal[0]<MAX_THERMOSTATS then
'    t_word=A_DigitTotal[0]
'    a=t_word.byte0
'    hserout2 [dec A_Thermostat[a]," ",dec A_Thermostat2[a],13,10] 
'    gosub send_mes_ok
'  else
'    error_code=23
'    gosub send_error 
'  endif
'return

'thermostat_sensor_read:
'  if digitcount=1 and A_DigitTotal[0]<MAX_THERMOSTATS then
'    t_word=A_DigitTotal[0]
'    a=t_word.byte0
'    hserout2 [dec A_ThermostatSensor[a],13,10] 
'    gosub send_mes_ok
'  else
'    error_code=23
'    gosub send_error 
'  endif
'return

'programmed_setpoint_read:
'  if digitcount=2 and A_DigitTotal[1]<6 and A_DigitTotal[0]<MAX_THERMOSTATS then
'    t_word=A_DigitTotal[0]
'    j=t_word.byte0
'    t_word=A_DigitTotal[1]
'    a=t_word.byte0
'    gosub programmed_setpoint_read_sub
'    gosub send_mes_ok
'  else
'    error_code=23
'    gosub send_error 
'  endif
'return

'programmed_setpoint_read_sub:
'  eep_addr.byte1=142+(59*thermostatCooling)                        'page 142 or 201
'  eep_addr.byte0=(a*32)+j+32
'  gosub read_eeprom  
'  x=i2cdata
'  gosub temperature_display
'  gosub display_LF_CR
'return

'programmed_setpoint_write:
'  if digitcount=4 and A_DigitTotal[1]<6 and A_DigitTotal[0]<MAX_THERMOSTATS then
'    y=0
'    t_word=A_DigitTotal[0]
'    b=t_word.byte0
'    t_word=A_DigitTotal[1]
'    a=t_word.byte0
'    t_word=A_DigitTotal[2]
'    x=t_word.byte0*2
'    if A_DigitTotal[3]<10 then
'      y=(A_DigitTotal[3]/5)
'    else
'      y=0  
'    endif
'    i2cdata=x+y+64 
'    eep_addr.byte1=142+(59*thermostatCooling)                      'Page 142 or 201
'    eep_addr.byte0=(a*32)+b+32              'address
'    gosub write_eeprom    
'    gosub send_mes_ok
'  else
'    error_code=23
'    gosub send_error 
'  endif
'return

'setpoint_write:
'  if digitcount=3 and A_DigitTotal[0]<MAX_THERMOSTATS then
'    y=0
'    t_word=A_DigitTotal[0]
'    j=t_word.byte0
'    t_word=A_DigitTotal[1]
'    x=t_word.byte0*2
'    if A_DigitTotal[2]<10 then
'      y=(A_DigitTotal[2]/5)
'    else
'      y=0  
'    endif
'    A_Setpt[j]=x+y+64
'    'hier_thermo
'    ThermostatNr=j
'    EepromSetptWrite=1                       'write eeprom    
'    gosub check_setpoint
'    'delete
'    'hserout2 ["0:Temp(",dec j,")=",dec A_Setpt[j],13,10]    
'    'hier_thermo
'    'i2caddr = 40+j
'    'if i2caddr<64 and j<24 then
'    '  i2cdata = A_Setpt[j]
'    '  gosub write_i2c_2
'    'endif     
'    gosub send_mes_ok
'  else
'    error_code=23
'    gosub send_error 
'  endif
'return

sync_page:
  if digitcount=1 and A_DigitTotal[0]<256 then
    t_word=A_DigitTotal[0]
    OledEeprom.byte1=(t_word.byte0)-1 'page
    OledEeprom.byte0=254              'byte  
    oledDataOk=1
    SyncEnable=1
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error 
  endif
return

sync_stop:
    SyncEnable=0
    gosub send_mes_ok
return

sync_debug_on:
    SyncDebug=1
    gosub send_mes_ok
return

sync_debug_off:
    SyncDebug=0
    gosub send_mes_ok
return    

'thermostat_link_write:
'  if A_DigitTotal[0]<MAX_THERMOSTATS and digitcount<4 then
'    t_word=A_DigitTotal[0]
'    j=t_word.byte0
'    t_word=A_DigitTotal[1]
'    x=t_word.byte0
'    if j<MAX_THERMOSTATS then A_Thermostat[j]=x
'    i2cdata=x 
'    eep_addr.byte1=142+(59*thermostatCooling)                      'Page 142 or 201
'    eep_addr.byte0=j                        'address
'    gosub write_eeprom 
'    if digitcount=3 then
'      t_word=A_DigitTotal[2]
'      x=t_word.byte0
'      if j<MAX_THERMOSTATS then A_Thermostat2[j]=x
'      i2cdata=x 
'      eep_addr.byte1=142+(59*thermostatCooling)                    'Page 142 or 201
'      eep_addr.byte0=j+224                  'address
'      gosub write_eeprom   
'    endif  
'    gosub send_mes_ok
'  else
'    error_code=23
'    gosub send_error 
'  endif
'return

'thermostat_sensor_write:
'  if digitcount=2 and A_DigitTotal[0]<MAX_THERMOSTATS then
'    t_word=A_DigitTotal[0]
'    j=t_word.byte0
'    t_word=A_DigitTotal[1]
'    x=t_word.byte0
'    if j<MAX_THERMOSTATS then A_ThermostatSensor[j]=x
'    i2cdata=x 
'    eep_addr.byte1=144+(59*thermostatCooling)                      'Page 144 or 203
'    eep_addr.byte0=j+8                      'address
'    gosub write_eeprom   
'    gosub send_mes_ok
'  else
'    error_code=23
'    gosub send_error 
'  endif
'return

display_sensor_name:
  a=j                                       'sensor number number
  length=16                                 'Max number of characters 
  Spaces=0      
  hserout2 [" "]    
  gosub eeprom_sensor_address  '            Calculate eeprom sensor address
  gosub display_name
  gosub display_LF_CR 
return

temperature_list:
  for j=0 to MAX_SENSORS-1
    x=A_Temperature[j]
    gosub temperature_display
    gosub display_sensor_name      
  next j 
  gosub send_mes_ok
return

humidity_list:
  for j=0 to MAX_SENSORS-1
    x=A_humidity[j]
    gosub humidity_display
    gosub display_sensor_name      
  next j 
  gosub send_mes_ok
return

temperature_display:
  if x<>255 then
    hserout2 [dec2 j," "]
    gosub temperature_display_sub
  else
    gosub sensor_not_connected  
  endif 
return

temperature_display_sub:
  if x>63 then                              'Temperature positive
    z=(x/2)-32
    y="+"
  else                                      'Temperature negative
    x=64-x
    z=x/2
    y="-"   
  endif    
  if x=255 then                             'sensor not connected
    hserout2 [" --.- "]  
  else
    hserout2 [y,dec2 z,".",dec (x//2)*5," "]
  endif
return

humidity_display:
  if x<>255 then   
    hserout2 [dec2 j," ",dec x/2,".",dec (x//2)*5,"%RH"]
  else
    gosub sensor_not_connected  
  endif 
return

sensor_not_connected:
   hserout2 [dec2 j," Sensor not connected"]
return

error_list:
  hserout2 ["i2c errors: ",dec i2cError,"/",dec i2cError2," ",dec PORTD.5,":",dec PORTD.6," PC",dec pollcheck," CC",dec ErrorCount_Can,13,10] 
  if controller_in =0 then
    hserout2 ["Empty input list",13,10]
  else
    a=1
    for j=0 to (controller_in-1)
      x=j
      gosub Error_display 
    next j
  endif
  if controller_out=0 then
    hserout2 ["Empty output list",13,10]
  else
    a=0
    for j=0 to (controller_out-1)
      x=j+30
      Gosub Error_display 
    next j
  endif
  if controller_out_RS>0 and controller_out_RS<31 then
    hserout2 ["Large Installation enabled",13,10]
    for i=1 to controller_out_RS
      gosub get_ID
      hserout2 [dec2 i-1," ",A_Digit[0]," ",dec3 A_Digit[0],".",dec3 A_Digit[1],".",dec3 A_Digit[2],".",dec3 A_Digit[3]," Roller/Shutter",13,10]
    next i
  endif  
  gosub send_mes_ok
return

Error_display:
  hserout2 [dec2 j," ",A_ModID0[x]," ",dec3 A_ModID0[x],".",dec3 A_ModID1[x],".",dec3 A_ModID2[x],".",dec3 A_ModID3[x]," ",dec A_ErrorBit[x]," "] 
  if x<30 then
    eep_addr.byte1=2+x                     'page
  else
    eep_addr.byte1=3+x
  endif  
  eep_addr.byte0=252
  gosub read_eeprom 
  if i2cdata=255 then
    hserout2 ["  "]
  else
    hserout2 [i2cdata," "]
  endif 
  hserout2 ["# of Errors: ",dec A_ErrorCount[x],13,10]     
return

Error_clear:
  for j=0 to MAX_ERRORS-3
    A_ErrorBit[j]=0
    A_ErrorCount[j]=0
  next j
  A_ErrorBit[MAX_ERRORS-1]=0
  i2cError=0
  i2cError2=0
  i2cTimeScan=0
  Err=0
  gosub send_mes_ok
return

display_io_list:
  hserout2 [dec3 a," "]
return

input_list:
  for x=1 to controller_in
    for y=0 to 7
      a=(x-1)*8+y                           'input number
      length=8                              'Max number of characters
      Spaces=0
      gosub calculate_invert
      gosub Calculate_input
      hserout2 [dec3 a," ",dec InputResult," (",dec z,") "]    
      gosub eeprom_input_address            'calculate eeprom input address
      gosub display_name                    'display input or output name
      hserout2 [" -> ",dec3 A_SelOutput[a]]
      gosub display_LF_CR
    next y
  next x
  gosub send_mes_ok
return

input_enable_list:
  b=0
  for x=1 to controller_in
    for y=0 to 7
      a=(x-1)*8+y                           'input number
      b=b+1
      hserout2 [dec3 a," ",dec A_InputEnable[a],"   "]    
      if b>7 then 
        gosub display_LF_CR
        b=0
      endif  
    next y
  next x
  gosub send_mes_ok
return

pulse_counter_list:
  for x=0 to (PULSECOUNTERS-1)
    hserout2 [dec x," ",dec5 A_PulseCounter[x]," "]
    a=x                                     'Pulse Counter
    length=16                               'Max number of characters 
    Spaces=0         
    gosub eeprom_pulse_address              'Calculate eeprom pulse address
    gosub display_name
    gosub display_LF_CR 
  next x  
  gosub send_mes_ok
return

output_list:
  for x=1 to controller_out
    for y=0 to 7
      timer=(x-1)*8+y                       'output number
      gosub timer_value_read      
      a=(x-1)*8+y                           'output number
      hserout2 [dec3 a," ",dec5 timer," "]
      length=16                             'Max number of characters 
      Spaces=0     
      gosub eeprom_output_address           'Calculate eeprom output address
      gosub display_name
      gosub display_LF_CR
    next y
  next x
  gosub send_mes_ok
return

display_list:
  if i2cdata<255 then                  
    length=16                               'Max number of characters 
    Spaces=0      
    hserout2 [dec3 a," "]                   'output number is a     
    gosub display_name
    gosub display_LF_CR   
  endif
return    

'action_list:
'  for a=0 to 203
'    x=a/51
'    y=a//51
'    eep_addr.byte1=93+x                     'page
'    eep_addr.byte0=(5*y)
'    gosub read_eeprom
'    gosub eeprom_action_address             'Calculate eeprom output address
'    gosub display_list
'  next a
'  gosub send_mes_ok
'return

group_list:
  for a=0 to 159
    x=a/8
    eep_addr.byte1=67+x                     'page
    eep_addr.byte0=(a-(8*x))*32
    gosub read_eeprom
    gosub eeprom_group_address              'Calculate eeprom output address
    gosub display_list      
  next a
  gosub send_mes_ok
return

'decision_list:
'  for a=0 to 191
'    x=a/32
'    eep_addr.byte1=87+x                     'page
'    eep_addr.byte0=(a-(32*x))*8
'    gosub read_eeprom
'    gosub eeprom_decision_address           'Calculate eeprom output address
'    gosub display_list     
'  next a
'  gosub send_mes_ok
'return

schedule_list:
  for a=0 to 101
    x=a/51
    y=a//51
    eep_addr.byte1=113+x                    'page
    eep_addr.byte0=(5*y)
    gosub read_eeprom 
    gosub eeprom_schedule_address           'Calculate eeprom output address
    gosub display_list    
  next a
  gosub send_mes_ok
return

eeprom_input_address:
  eep_addr.byte1=115+(a/32)                 'page
  eep_addr.byte0=8*(a//32)                  'address
return

eeprom_output_address:
  eep_addr.byte1=33+(a/8)
  eep_addr.byte0=20+((a//8)*16)             'address
return

eeprom_pulse_address:
  eep_addr.byte1=98+(a/16)
  eep_addr.byte0=(a//16)*16                 'address
return

'Niet meer in gebruik?
eeprom_action_address:
  eep_addr.byte1=145+(a/16)
  eep_addr.byte0=(a//16)*16                 'address
return

eeprom_group_address:
  eep_addr.byte1=158+(a/16)
  eep_addr.byte0=(a//16)*16                 'address
return

'Niet in gebruik?
eeprom_decision_address:
  eep_addr.byte1=168+(a/16)
  eep_addr.byte0=(a//16)*16                 'address
return

eeprom_schedule_address:
  eep_addr.byte1=180+(a/16)
  eep_addr.byte0=(a//16)*16                 'address
return

'eeprom_thermostat_address:
'  eep_addr.byte1=187+(a/16)+(17*thermostatCooling)      'Start page 187 or 204
'  eep_addr.byte0=(a//16)*16                 'address
'return

'Niet in gebruik?
eeprom_message_address:
  eep_addr.byte1=125+(a/2)
  eep_addr.byte0=(a//2)*128                 'address 
return

'Niet in Gebruik?
eeprom_number_address:
  eep_addr.byte1=123
  eep_addr.byte0=16+(c*16)                  'address
return

display_name:
  if a<240 then
    for z1=1 to length
      gosub read_eeprom
      if i2cdata=255 and z1=1 then
        if length>15 then
          hserout2 ["Empty          "]
          CRC=CRC+847                       'sum of "Empty" + spaces is 847
        else
          hserout2 ["Empty  "] 
          CRC=CRC+591                       'sum of "Empty" + spaces is 591
        endif
        z1=length                           'exit
      endif
      if i2cdata>127 then                   'no ascii character
        if Spaces=1 then
          hserout2 [32]                     'space
          CRC=CRC+32
        else
          z1=length                         'exit
        endif  
      else
        gosub print_i2cdata
        CRC=CRC+i2cdata
        eep_addr.byte0=eep_addr.byte0+1     'address next byte 
      endif    
    next z1
  else
    if a=240 then
      hserout2 ["Special function"]
    endif
    if a=241 then
      hserout2 ["All Outputs OFF"]
    endif
    if a>241 and a<249 then
      hserout2 ["All/Floor Lights OFF"]
    endif  
    if a=255 then
      hserout2 ["No Function"]
    endif
  endif 
return

input_name_write:
  if digitcount=1 and A_DigitTotal[0]<240 and text=1 and textlength>0 then
    t_word=A_DigitTotal[0]
    a=t_word.byte0                          'input number
    b=8                                     'max number of characters
    gosub eeprom_input_address
    gosub write_name
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error   
  endif
return

add_virtual_m:
  if e="o" or e="d" then  'Virtual output
    a=controller_out
    b=33         'Output pages
    c=0          'start byte on output pages
    d=1          'Controller_type -> output
  endif
  if e="r" then  'Virtual shutter
    a=controller_out_rs
    b=33         'Output pages
    c=173        'start byte on output pages
    d=0          'Controller_type -> output
  endif  
  if e="i" then  'Virtual input
    a=controller_in
    b=2          'Output pages
    c=0          'start byte on output pages
    d=2          'Controller_type -> input
  endif     
  A_RS485string[0]=e
  A_RS485string[1]=0
  A_RS485string[2]=controller_out
  A_RS485string[3]=controller_in
return

add_virtual_module:
  'if digitcount=1 and A_DigitTotal[0]<240 and text=1 and textlength>0 then
  e=A_RecChar[textstart]
  if digitcount=0 and text=1 and textlength=1 and (e="o" or e="i" or e="d" or e="r") then
    'hserout2 ["textlength=",dec textlength," ",A_RecChar[textstart],13,10]
    gosub add_virtual_m
    gosub add_m
    gosub send_mes_ok  
  else
    error_code=23
    gosub send_error   
  endif  
return

output_name_write:
  if digitcount=1 and A_DigitTotal[0]<240 and text=1 and textlength>0 then
    t_word=A_DigitTotal[0]
    a=t_word.byte0                          'output number
    b=16                                    'max number of characters
    gosub eeprom_output_address
    gosub write_name
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error   
  endif
return

pulse_counter_name_write:
  if digitcount=1 and A_DigitTotal[0]<8 and text=1 and textlength>0 then
    t_word=A_DigitTotal[0]
    a=t_word.byte0                          'Pulse Counter number
    b=16                                    'max number of characters
    gosub eeprom_pulse_address
    gosub write_name
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error   
  endif
return

sensor_name_write:
  if digitcount=1 and A_DigitTotal[0]<MAX_SENSORS and text=1 and textlength>0 then
    t_word=A_DigitTotal[0]
    a=t_word.byte0                          'output number
    b=16                                    'max number of characters
    gosub eeprom_sensor_address
    gosub write_name
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error   
  endif
return

eeprom_sensor_address:
  eep_addr.byte1=193+(a/16)
  eep_addr.byte0=(a//16)*16                 'address
return

group_name_write:
  if digitcount=1 and A_DigitTotal[0]<160 and text=1 and textlength>0 then
    t_word=A_DigitTotal[0]
    a=t_word.byte0                          'output number
    b=16                                    'max number of characters
    gosub eeprom_group_address
    gosub write_name
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error   
  endif
return

schedule_name_write:
  if digitcount=1 and A_DigitTotal[0]<102 and text=1 and textlength>0 then
    t_word=A_DigitTotal[0]
    a=t_word.byte0                          'output number
    b=16                                    'max number of characters
    gosub eeprom_schedule_address
    gosub write_name
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error   
  endif
return

'thermostat_name_write:
'  if digitcount=1 and A_DigitTotal[0]<MAX_THERMOSTATS and text=1 and textlength>0 then
'    t_word=A_DigitTotal[0]
'    a=t_word.byte0                          'output number
'    b=16                                    'max number of characters
'    gosub eeprom_thermostat_address
'    gosub write_name
'    gosub send_mes_ok
'  else
'    error_code=23
'    gosub send_error   
'  endif
'return


write_name:                                 'write name in eeprom
  for z1=1 to b                             'b=max number of characters to write
    if z1>textlength then
      i2cdata=255
      gosub write_eeprom
    else
      i2cdata=A_RecChar[textstart+z1-1]
      if i2cdata>31 and i2cdata<127 then gosub write_eeprom
    endif
    eep_addr.byte0=eep_addr.byte0+1
  next z1
return

convert_dec:
  error_code=255
  for s=0 to MAX_DIGIT-1
    A_DigitTotal[s]=0
  next s
  text=0
  textlength=0
  DigitCount=0                              'convert ascii to decimal
  for s=charpointer to (BUFFER_RS232-1)      'search for space or enter
    if A_RecChar[s]>47 and A_RecChar[s]<58 then
      gosub convert_1value
      if text=0 then DigitCount=DigitCount+1
    endif
    if A_RecChar[s]=13 or error_code<>255 then'enter received or error
      s=(BUFFER_RS232-1)                     'exit routine
    else
      if A_RecChar[s]=" " or A_RecChar[s]="." or A_RecChar[s]=":" then         'space received or . or : received
        CharPointer=CharPointer+1
      else
        if text=0 then
          text=1                            'it is text, not a value
          textstart=charpointer
          gosub convert_text
          s=(BUFFER_RS232-1)                 'exit routine        
        endif   
      endif   
    endif  
  next s
return

convert_1value:
  for j=0 to 4
    A_Digit[j]=0
  next j
  j=0
  for k=charpointer to (BUFFER_RS232-1)
    if A_RecChar[k]>47 and A_RecChar[k]<58 then 'ascii character between 0 and 9                  
      A_Digit[4]=A_Digit[3]                     'start shifting A_Digit
      A_Digit[3]=A_Digit[2]
      A_Digit[2]=A_Digit[1]
      A_Digit[1]=A_Digit[0]
      A_Digit[0]=A_RecChar[k]-48
      j=j+1
      if j>5 then                           'Maximum 5 digits
        k=(BUFFER_RS232-1)                   'exit loop
        error_code=19
        gosub send_error
      endif
    else
      if A_RecChar[k]=13 or A_RecChar[k]=" " or A_RecChar[k]="." or A_RecChar[k]=":" then    
        charpointer=k                       'change pointer
        s=k
        k=(BUFFER_RS232-1)                   'exit loop
        if digitcount<MAX_DIGIT then A_DigitTotal[digitcount]=A_Digit[0]+(A_Digit[1]*10)+(A_Digit[2]*100)+(A_Digit[3]*1000)+(A_Digit[4]*10000)
      else                                  'it's not a value but a text message
        text=1                              'it is text, not a value
        textstart=charpointer
        gosub convert_text
        k=(BUFFER_RS232-1)                   'exit loop convert_1value
        s=(BUFFER_RS232-1)                   'exit loop convert_dec
      endif
    endif
  next k
return

convert_text:
' check number of text messages
' check length of text message and startcharacter
' remove "enter" and "carriage return"
  textlength=0
  for p=textstart to (BUFFER_RS232-1)
    if A_RecChar[p]=13 then                   'carriage return
      p=(BUFFER_RS232-1)                     'exit loop
    else
      textlength=textlength+1
    endif
  next p
return


Bus_init:                                     
  mode="I"                                  'Bus in initialization mode
  broad1="I"
  broad2="I"
  BroadID=0
  broadData=0
  low led_red
  'BroadFromQueue=0
  pause 100
  gosub send_broad_immediatly             'send message      
  'InterpreteSer1=0
  RS485busy=NO
  RCSTA1.4=1                                'enable receiving serial 1 
return

Bus_live:                                  
  mode="L"                                  'Bus in Live mode
  broad1="L"
  broad2="L"
  BroadID=0
  broadData=0
  high led_red
  'BroadFromQueue=0
  pause 100
  gosub send_broad_immediatly             'send message
  write_yes=1                               'write outputs
  for u=1 to controller_out
    if u<MAX_OUTPUT_MODULES+1 then A_WriteYesMod[u-1]=1
  next u
  RS485busy=NO
  BootloaderMode=0
  pollTimeOutput=0
  pollTimeInput=0       
return

Normal_PowerState:
  Broad1="N"                                'Put modules in normal state
  Broad2="N"
  BroadID=0
  gosub Add_Broad_queue
  PowerSafe=0
return

Normal_PowerState_2:
  Gosub Normal_PowerState
  'A_QueueType[queue_end]=235             'delay next instructions with 120 seconds
  'A_QueueAction[queue_end]=120
  BA_type_queue=235
  BA_action_queue=120  
  gosub Increase_queue_pointer
  'A_QueueType[queue_end]=64              'Switch off leds on all modules
  'A_QueueAction[queue_end]=0
  BA_type_queue=64
  BA_action_queue=0    
  gosub Increase_queue_pointer
  'A_QueueType[queue_end]=235             'Stop delaying next actions
  'A_QueueAction[queue_end]=255
  BA_type_queue=235
  BA_action_queue=255   
  gosub Increase_queue_pointer      
return

Low_PowerState:
  Broad1="S"                                'Put modules in power Safe state
  Broad2="S"
  BroadID=0
  gosub Add_Broad_queue
  PowerSafe=1
return

test_command:
  if test="%" then                          'end of command
    if A_TestChar[cmd]=1 then                 'valid command found
      instruction=cmd
      CharPointer=j                         'pointer where digits must start
      j=BUFFER_RS232-1                       'end of test
    endif
  endif
  if test=A_RecChar[j] then                   'character found on the correct place
    if cmd<nr_of_cmd then A_TestChar[cmd]=A_TestChar[cmd]&1
  else                                      'character not found on the correct place
    if cmd<nr_of_cmd then A_TestChar[cmd]=0  
  endif
return


send_mes_ok:
  if ok=1 then    
   hserout2 ["OK",13,10]
  endif
  instruction=255
  A_RecChar[0]=0
return


Add_Broad_queue:
    if broad_end_pointer>=MAX_BROAD_QUEUE then broad_end_pointer=0    'Make sure tx_end_pointer is in a valid range before starting
    if broad_queue_size<MAX_BROAD_QUEUE then
        A_broad1[broad_end_pointer]=broad1
        A_broad2[broad_end_pointer]=broad2
        A_broadId[broad_end_pointer]=broadId
        A_broadData[broad_end_pointer]=broadData
        'hserout2 ["Add Broadcast Queue ",dec broad_end_pointer," data: ",broad1," ",broad2," ",dec BroadData,13,10]
        broad_end_pointer=broad_end_pointer+1
        if broad_end_pointer>=MAX_BROAD_QUEUE then broad_end_pointer=0
        broad_queue_size=broad_queue_size+1 
    endif           
return

Rem_Broad_queue:
    if broad_queue_size<=MAX_BROAD_QUEUE and broad_queue_size>0 then    
        broad_start_pointer=broad_start_pointer+1
        if broad_start_pointer>=MAX_BROAD_QUEUE then broad_start_pointer=0
        broad_queue_size=broad_queue_size-1
    else
        broad_queue_size=0
        broad_start_pointer=broad_end_pointer
    endif
return

Check_broad_queue:
  if broad_state_machine==START then        'START
    if broad_queue_size>0 then              'Something in the queue
      if Rs485busy==NO then                 'RS485 Bus is free
        Rs485busy=YES
        broad_state_machine=broad_state_machine+1
      endif
    endif
  elseif broad_state_machine==STEP1 then    'STEP1: Sending the message
    broad1=A_broad1[broad_start_pointer]
    broad2=A_broad2[broad_start_pointer]
    broadId=A_broadId[broad_start_pointer]
    broadData=A_broadData[broad_start_pointer]
    gosub send_broad_immediatly             'send message
    'hserout2 ["Broadcast Queue ",dec broad_start_pointer," data: ",broad1," ",broad2," ",dec BroadData,13,10]
    gosub Rem_Broad_queue                   'Remove message from queue
    broad_wait_time=49                      '0,41ms x 49 = 20ms    
    broad_state_machine=broad_state_machine+1
  elseif broad_state_machine==STEP2 then    'STEP2: Non-Blocking wait so slaves can interprete the message
    if broad_wait_time=0 then    
      broad_state_machine=broad_state_machine+1
    endif
  elseif broad_state_machine==STEP3 then    'STEP3: Release the Bus and ends the state machine
    Rs485busy=NO
    broad_state_machine=START 
  else                                      'DEFAULT
    Rs485busy=NO
    broad_state_machine=START
  endif
return

send_broad_immediatly:
    gosub empty_e
    RS485message="B"
    A_e[0]=broadID
    A_e[1]=0
    A_e[2]=0
    A_e[3]=0
    A_e[4]=broad1
    A_e[5]=broad2
    A_e[6]=broadData
    gosub send_rs485_long                   'send message
return

'Check_broad_queue:
'  if Rs485busy=NO then   'RS485 bus is free
'    if broadcounter<MAX_BROAD then
'      if A_broad1[broadcounter]>0 then  'something in this queue position
'        broad1=A_broad1[broadcounter]
'        broad2=A_broad2[broadcounter]
'        broadId=A_broadId[broadcounter]
'        broadData=A_broadData[broadcounter]
'        BroadFromQueue=1
'        gosub send_broad_sub
'        'delete
'        'hserout2 ["Broadcast Queue ",dec broadcounter," data: ",dec Broad1," ",dec Broad2," ",dec BroadData,13,10]
'        A_broad1[broadcounter]=0
'        broadcounter=broadcounter+1
'      else
'        broadcounter=broadcounter+1
'      endif
'    else
'      broadcounter=0
'    endif
'  endif
'return


'send_broad:
'  if Rs485busy=NO then
'    'BroadFromQueue=0
'    gosub send_broad_sub                      'sent broadcast message
'  else                                        'Bus busy so put it in the queue
'    'delete
'    'hserout2 ["RS485 Bus busy ",dec Broad1," ",dec Broad2," ",dec BroadData,13,10]
'    if broad1<>"l" and broad2<>"O" and BroadID<>"C" then   'Don't buffer message for all leds off since this message can not come later then the indicate instruction
'      if broadpointer<MAX_broad then
'        A_broad1[broadpointer]=broad1
'        A_broad2[broadpointer]=broad2
'        A_broadId[broadpointer]=broadId
'        A_broadData[broadpointer]=broadData
'      else
'        broadpointer=0
'        A_broad1[broadpointer]=broad1
'        A_broad2[broadpointer]=broad2
'        A_broadId[broadpointer]=broadId
'       A_broadData[broadpointer]=broadData        
'      endif
'    endif  
'    broadpointer=broadpointer+1
'    if broadpointer>(MAX_BROAD-1) then broadpointer=0  
'  endif  
'return

'send_broad_sub:
'  if BroadFromQueue=0 then
'    pause 12
'  else
'    pause 22
'  endif    
'  high RS485_DIR                           'Send mode  
'  pause pause_value
'  pause 2
'  gosub empty_e
'  RS485message="B"
'  A_e[0]=broadID
'  A_e[1]=0
'  A_e[2]=0
'  A_e[3]=0
'  A_e[4]=broad1
'  A_e[5]=broad2
'  A_e[6]=broadData
'  gosub send_rs485_long
'  if BroadFromQueue=0 then
'    pause 5
'  else
'    pause 15
'  endif    
'  low RS485_DIR  
'return

'Check_Thermostat_values:
'  for i=0 to 223                            'Check all night temperatures, if values are not yet defined, put them on 16 degree
'    eep_addr.byte0=i                        'address
'    eep_addr.byte1=198+(14*thermostatCooling)        'page 198 or 212
'    gosub read_eeprom                       'read # of input modules
'    if i2cdata=255 then                     'Temperature is not yet defined
'      eep_addr.byte0=i                      'address
'      eep_addr.byte1=198+(14*thermostatCooling)        'page 198 or 212
'      i2cdata=96                            'write 16 degree
'      gosub write_eeprom
'    endif  
'  next i    
'return

'------------------------------------------------------------------------------
' Activate data from eeprom, for more details see http://wiki.openmotics.com/index.php/Memory_Model
'------------------------------------------------------------------------------

'Copy data from eeprom into RAM

Read_Controller_InOut:
  'Read # of input devices
  eep_addr.byte0=1                          'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom                         'read # of input modules
  if i2cdata<(MAX_INPUT_MODULES+1) then                        'Max of 30 input devices can be used
    controller_in=i2cdata
  else
    if i2cdata=255 then                     'value of an empty eeprom
      i2cdata=0
      gosub write_eeprom
    else
      error_code=11                         'send Error code
      gosub send_error
    endif
    controller_in=0
    A_ErrorID[0]=0
    A_ErrorID[1]=0
    A_ErrorID[2]=0
    A_ErrorID[3]=0
  endif     
  
  'Read # of output devices
  eep_addr.byte0=2                          'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom                         'read # of output modules
  if i2cdata<(MAX_OUTPUT_MODULES+1) then                        'Max of 30 output devices can be used
    controller_out=i2cdata
  else
    if i2cdata=255 then                     'value of an empty eeprom
      i2cdata=0
      gosub write_eeprom
    else
      error_code=12                         'send Error code
      gosub send_error
    endif  
    controller_out=0
    A_ErrorID[0]=0
    A_ErrorID[1]=0
    A_ErrorID[2]=0
    A_ErrorID[3]=0
  endif
 
 'Read # of Roller/Shutter devices when Large Installation is enabled
  eep_addr.byte0=3                          'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom                         'read # of output modules
  if i2cdata<31 then                        'Max of 30 output devices can be used
    controller_out_RS=i2cdata
  else
    i2cdata=0
    gosub write_eeprom 
    controller_out_RS=0
  endif
  
  'Read ID's, toggling outputs, timer values etc
  for t=1 to controller_in                  'check eeprom for input devices
    eep_addr.byte1=t+1
    eep_addr.byte0=0                        'Read ID0
    gosub read_eeprom
    A_ModID0[t-1]=i2cdata
    'if i2cdata="L" then OledInstalled=1     'Check if an oled display is installed
    eep_addr.byte0=1                        'Read ID1
    gosub read_eeprom    
    A_ModID1[t-1]=i2cdata
    eep_addr.byte0=2                        'Read ID2
    gosub read_eeprom    
    A_ModID2[t-1]=i2cdata
    eep_addr.byte0=3                        'Read ID3
    gosub read_eeprom   
    A_ModID3[t-1]=i2cdata
    FOR q=0 to 7            
      eep_addr.byte0=q+4                    'address
      eep_addr.byte1=t+1                    'page
      gosub read_eeprom                     'read all toggling outputs
      A_SelOutput[((t-1)*8)+q]=i2cdata     
    next q   
  next t
  
  for t=0 to 239
    eep_addr.byte1=32
    eep_addr.byte0=t                        'Read invert status 
    gosub read_eeprom
    a=t/8
    b=t//8
    if i2cdata=255 then                     '1   NO
      x=%00000001<<b
      if a<MAX_INPUT_MODULES then A_InputInvert[a]=A_InputInvert[a]|x      
    else                                    '0   NC
      x=%00000001<<b
      x=~x
      if a<MAX_INPUT_MODULES then A_InputInvert[a]=A_InputInvert[a]&x      
    endif   
  next t
  
  'check eeprom for output devices
  for t=1 to controller_out
    eep_addr.byte1=t+32
    eep_addr.byte0=0                        'Read ID0
    gosub read_eeprom
    A_ModID0[t+29]=i2cdata
    eep_addr.byte0=1                        'Read ID1
    gosub read_eeprom    
    A_ModID1[t+29]=i2cdata
    eep_addr.byte0=2                        'Read ID2
    gosub read_eeprom    
    A_ModID2[t+29]=i2cdata
    eep_addr.byte0=3                        'Read ID3
    gosub read_eeprom   
    A_ModID3[t+29]=i2cdata 
  next t  
  
return

Check_LIM:   'Check if Large installation can be enabled automatically
    eep_addr.byte0=27                         'address
    eep_addr.byte1=0                          'page
    gosub read_eeprom   
    if i2cdata=255 then                       'Large Installation mode is not yet enabled
        if controller_in=0 and controller_out=0 then  'Enable Large Installation Mode
            LargeInstallation=1
            eep_addr.byte0=27                         'address
            eep_addr.byte1=0                          'page
            i2cdata=0
            gosub write_eeprom      
        else
            LargeInstallation=0
        endif
    else
        LargeInstallation=1
    endif
return

'Read_ThermostatMode:
'  'Read Thermostat Mode
'  eep_addr.byte0=14                         'address
'  eep_addr.byte1=0                          'page
'  gosub read_eeprom  
'  if i2cdata=255 then 
'    Thermostatmode=131                      'Away temp in manual mode
'  else
'    Thermostatmode=i2cdata
'    ThermostatMode=ThermostatMode & %11011111  'Non used bits are put on 0
'    'hier_thermo
'    thermostatCooling=thermostatmode.bit4
'    thermostatOn=thermostatmode.bit7        
'  endif
'  thermostatCooling=thermostatmode.bit4
'  eep_addr.byte0=40                         'address
'  eep_addr.byte1=0                          'page
'  gosub read_eeprom 
'  if i2cdata=255 then
'    ThermostatEnabled=1                     'Thermostat function of the master is enabled
'  else
'    ThermostatEnabled=0                     'Thermostat function of the master is disabled
'  endif   
'  'gosub write_thermostatmode
'  gosub Set_CoolingHeating
'return

eeprom_activate:
  'delete
  'hserout2 ["1: Activate Eeprom, In/Out=",dec controller_in,"/",dec controller_out,13,10]
  OledInstalled=0
  broad1="A"     'Activate Eeprom in CAN Control modules
  broad2="E"
  broaddata=0    
  BroadID="C"    'for CAN modules only
  gosub Add_Broad_queue
  gosub Add_Broad_queue  
  gosub reset_error

  gosub read_Controller_InOut
  
'  if startup==YES then gosub Read_ThermostatMode
  
  'delete
  'hserout2 ["2: Activate Eeprom, In/Out=",dec controller_in,"/",dec controller_out,13,10]

'  eep_addr.byte0=40                         'address
'  eep_addr.byte1=0                          'page
'  gosub read_eeprom 
'  if i2cdata=255 then
'    ThermostatEnabled=1                     'Thermostat function of the master is enabled
'  else
'    ThermostatEnabled=0                     'Thermostat function of the master is disabled
'  endif

  'RS485 timeout value
  eep_addr.byte0=4                          'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata>0 and i2cdata<255 then 
    rs485_timeout_max=i2cdata               'Timeout=rs485_timeout_max*6,5ms
  else
    rs485_timeout_max=4                     'Timeout=4*6,5ms
  endif 
  
  'Read minimum dimmer value
  eep_addr.byte0=5                          'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata<63 then 
    dim_minimum=i2cdata
  else
    dim_minimum=5
  endif  
  
  'Read Dim Step
  eep_addr.byte0=6                          'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata<4 and i2cdata>0 then 
    dim_step=i2cdata
  else
    dim_step=1
  endif 
  
  'Read Dim Cycle
  eep_addr.byte0=7                          'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom 
  if i2cdata<64 and i2cdata>1 then 
    dim_cycle=i2cdata
  else
    dim_cycle=15
  endif 
  
  'Read Dimmer_memory function (keep dimmed value in memory or full intensity when switched on)
  eep_addr.byte0=9                          'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata<255 then 
    dimmer_mem=i2cdata
  else
    dimmer_mem=1                            'dimmer_mem=1:keep dimmer value in memory, dimmer_mem=0: don't keep it in memory
  endif 
  
  'Read Debug bit, if byte10=1-> debug mode, if byte10=255-> normal mode
  eep_addr.byte0=10                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata=1 then                         'Debug mode on
    DebugMode=1
  else
    DebugMode=0
  endif 
        
  'Read automatic response bit, if byte11=255-> AutResponse=0, if byte11<>255->AutResponse=0
  eep_addr.byte0=11                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata<>255 then                      'Debug mode on
    autresponse=1                           '-> "RO" response in advanced mode
  else
    autresponse=0                           '-> No automatic response
  endif
  
  'Read Echo On byte
  eep_addr.byte0=12                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom  
  if i2cdata=0 then 
    EchoOnBit=0
  else
    EchoOnBit=1
  endif     
  
  'Read API/CLI byte during start up
  if startup=1 then                         'only do this during startup
    eep_addr.byte0=13                       'address
    eep_addr.byte1=0                        'page
    gosub read_eeprom  
    if i2cdata<255 then 
      Mode_com=1
      debugmode=0
    else
      Mode_com=0
    endif
  endif
   
    
  'Read Temperature Module installed Byte
  eep_addr.byte0=15                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom  
  if i2cdata=255 then 
    Temp_Mod_Installed=0                    'Temperature module not installed
  else
    Temp_Mod_Installed=1                    'Temperature module installed
  endif 
  
  'Read Outside Sensor Byte
  eep_addr.byte0=16                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom 
  outside_sensor=i2cdata 
  if i2cdata>31 then 
    Outside_Sensor=0                        'Take Sensor number 0
  endif 
  
  'Read Temperature threshold Byte for Thermostat function
'  eep_addr.byte0=17                         'address
'  eep_addr.byte1=0                          'page
'  gosub read_eeprom 
'  temp_threshold=i2cdata 
 
  'Read the automatic Response byte for automatic message "OL"
  eep_addr.byte0=18                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata<>255 then                      'Debug mode on
    autresponseOL=1                         '-> OL response in advanced mode
  else
    autresponseOL=0                         '-> No automatic response
  endif       

  'Pump delay parameter
'  eep_addr.byte0=19                         'address
'  eep_addr.byte1=0                          'page
'  gosub read_eeprom
'  if i2cdata<249 then 
'    pump_delay=i2cdata
'  else
'    pump_delay=0
'  endif  
    
  eep_addr.byte0=20                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata<>255 then                      'Debug mode on
    autresponseIL=1                         '-> LI response in advanced mode
  else
    autresponseIL=0                         '-> No automatic response
  endif   
  
  'Read if Individual temperatures for every Thermostat for every day are used
  eep_addr.byte0=21                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata=255 then                       'Individual Temperatures for every Thermostat are active
    IndividualTempOn=1                      '-> Individual temperatures are used
  else
    IndividualTempOn=0                      '-> General day1/2 temperatures are used per Thermostat
  endif

  'Read Wait time (value*20us) between scan every input module
  eep_addr.byte0=22                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata=255 then   
    WaitTimeInput=3
  else
    WaitTimeInput=i2cdata
  endif

  clearWDT

  'Read Wait time (value*20us) between scan every output module
  eep_addr.byte0=23                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata=255 then   
    WaitTimeOutput=3
  else
    WaitTimeOutput=i2cdata
  endif

  'if thermostatupdate=1 then every 10 minutes, Thermostat setpoints are updated (in automatic mode only)
  'if thermostatupdate=0 then Thermostat setpoints are only updated at start and stop time (in automatic mode only)
'  eep_addr.byte0=24                         'address
'  eep_addr.byte1=0                          'page
'  gosub read_eeprom   
'  if i2cdata=255 then   
'    ThermostatUpdate=1
'  else
'    ThermostatUpdate=0
'  endif
  
  'Specifies the number of bytes to receive before interpretion of the received message can be done
  eep_addr.byte0=25                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata=255 then   
    RecBytesSer1=14
  else
    RecBytesSer1=i2cdata
  endif  
  
  'Specifies the catch all functionality
  eep_addr.byte0=26                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata=255 then   
    CatchAll=0
  else
    CatchAll=1
    if i2cdata>80 then
      CatchAllByte=6
    else
      CatchAllByte=i2cdata
    endif
  endif 

  'Enable/Disable LargeInstallation functionality
  eep_addr.byte0=27                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata=255 then   
    LargeInstallation=0
  else
    LargeInstallation=1
  endif
  
  'Read automatic response bit, if byte28=255-> AutResponseSO=0, if byte28<>255->AutResponse=0
  eep_addr.byte0=28                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata<>255 then                      
    autresponseSO=1                          '-> "SO" response in advanced mode and Large Installation mode
  else
    autresponseSO=0                          '-> No automatic response
  endif 
  
  'Read Maximum number of errors before a module is taken offline
  eep_addr.byte0=29                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata>0 then                      
    ErrorMax=i2cdata*100                    'Max number of errors before a module is taken offline
  else
    ErrorMax=65534                          'Never take it offline
  endif
 
  'Is Temperature correction received from the sensors needed?
  eep_addr.byte0=30                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata>0 then                      
    TempCor=1                   
  else
    TempCor=0
  endif 
  
  'Nr of repeats that the master sends the output messages to the output slaves
  eep_addr.byte0=33                       'address
  eep_addr.byte1=0                        'page
  gosub read_eeprom                       'read Nr of repeats
  if i2cdata=255 or i2cdata=0 then
    OutputNrWrites=1
  else
    OutputNrWrites=i2cdata
  endif    
  FOR q=0 to MAX_OUTPUT_MODULES-1                             'Set output writes to all output modules
    A_WriteYesMod[q]=OutputNrWrites  
  next q
  
  clearWDT
  
    'Configures the upper limit Temperature for a configured Thermostat that the Temperature will be accepted as valid
'  eep_addr.byte0=34                         'address
'  eep_addr.byte1=0                          'page
'  gosub read_eeprom   
'  if i2cdata=255 then                      
'    ThermostatUpLimitTemp=154   'standard Temperature is 45 degree c, above this Temperature the sensor configured for a Thermostat will go offline                   
'  else
'    ThermostatUpLimitTemp=i2cdata
'  endif 
 
   'Configures the down limit Temperature for a configured Thermostat that the Temperature will be accepted as valid
'  eep_addr.byte0=35                         'address
'  eep_addr.byte1=0                          'page
'  gosub read_eeprom   
'  if i2cdata=255 then                      
'    ThermostatDownLimitTemp=74    'standard Temperature is 5 degree c, below this Temperature the sensor configured for a Thermostat will go offline                   
'  else
'    ThermostatDownLimitTemp=i2cdata
'  endif

  'Configures if the roller/shutters are in lock mode or not
  eep_addr.byte0=39                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata=0 then                      
    all_stores_locked=YES                   'stores are locked                    
  else
    all_stores_locked=NO                    'stores are not locked
  endif  

  'Check if inputs always must be enabled even when inputs are configured being disabled
  eep_addr.byte0=42                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata==255 then                      
    AllInputsAlwaysEnabled=NO               'Inputs can be disabled                    
  else
    AllInputsAlwaysEnabled=YES              'Inputs are always enabled, even when individual inputs are being configured to be disabled
  endif
  
  'IMaximum number of thermostats used in the system, minimum 24 maximum 32
  'eep_addr.byte0=59                         'address
  'eep_addr.byte1=0                          'page
  'gosub read_eeprom   
  'if i2cdata>32 or i2cdata<24 then                      
  '  Controllers=24
  '  i2cdata=24
  '  gosub write_eeprom                   
  'else
  '  Controllers=i2cdata
  'endif     
  
  'Offset Temperature byte 60-91
  FOR q=0 to MAX_SENSORS-1                  'Read Offset Temperature
    eep_addr.byte0=q+60                     'address
    eep_addr.byte1=0                        'page
    gosub read_eeprom                       'read all toggling outputs
    A_TempOffset[q]=i2cdata    
  next q  
  
  'Input Filter Value
  eep_addr.byte0=92                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata=255 then   
    InputFilter=10
  else
    InputFilter=i2cdata
  endif  
  
  'Force CRC for input modules
  eep_addr.byte0=93                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata=255 then   
    ForceCRC=0                              'CRC will not be forced and is optional depending on the firmware of the slave input modules
  else
    ForceCRC=1                              'CRC will be forced and messages from input modules without CRC will be dropped
  endif  
 
 
 'Read switch type values
  for t=0 to MAX_INPUTS-1
    eep_addr.byte1=97                       'page
    eep_addr.byte0=t                        'Read switch type 
    gosub read_eeprom
    if i2cdata=255 then                     'Normal switch (like use in all home automation systems)
      A_SwitchType[t]=1     
    else                                    'Toggle switch (like used in a traditional electrical installation without any automation)
      A_SwitchType[t]=0
    endif   
  next t
  
  'Read PID values for PID controller
'  gosub read_thermostat_par   

  'Read linked Pulse counter Input Information
  FOR q=0 to (PULSECOUNTERS-1)            
    eep_addr.byte0=q+160                    'address
    eep_addr.byte1=0                        'page
    gosub read_eeprom                       'read all toggling outputs
    A_PulseInput[q]=i2cdata     
  next q
  
  'Read Virtual Sensors byte 0-31
  FOR q=0 to MAX_SENSORS-1                  'Read Virtual Sensor
    eep_addr.byte0=q                        'address
    eep_addr.byte1=195                      'page
    gosub read_eeprom                       'read all Virtual sensor settings
    if i2cdata=255 then
      A_VirtualSensor[q]=0
    else
      A_VirtualSensor[q]=1
    endif    
  next q
   
  clearWDT 
    
  'Read which thermostats are in permanent manual mode
'  a=32                                      'a=32 when in heating mode, a=64 when in cooling mode
'  b=0
'  gosub read_PermanentManual 
'  a=64                                      'a=32 when in heating mode, a=64 when in cooling mode
'  b=24                                      
'  gosub read_PermanentManual         
'  PidCalcCheck=1                            'Do the PID calculation
  'gosub input_check_led
  if mode="L" then                          'when the button module receives the live broadcast, it will switch off the leds                                           'when the module receive a scanning, it will switch on the corresponding leds
    gosub bus_live
  endif
  'delete
  'hserout2 ["3: Activate Eeprom, In/Out=",dec controller_in,"/",dec controller_out,13,10]
  'gosub Read_ThermostatMode  
return


'read_PermanentManual:
'  'Read which thermostats are in permanent manual mode  
'  FOR q=0 to (MAX_THERMOSTATS-1)                 'Read Virtual Sensor
'    eep_addr.byte0=q+a                      'address
'    eep_addr.byte1=195                      'page
'    gosub read_eeprom                       'read all permanent Thermostat settings
'    if i2cdata=255 then
'      A_PermanentManual[q+b]=0
'    else
'      A_PermanentManual[q+b]=1
'    endif    
'  next q
'return

'read_thermostat_par:
'  for t=0 to (MAX_THERMOSTATS-1)
'    eep_addr.byte1=142+(59*thermostatCooling)
'    eep_addr.byte0=t        
'    gosub read_eeprom
'    A_Thermostat[t]=i2cdata
'    eep_addr.byte0=t+224        
'    gosub read_eeprom
'    A_Thermostat2[t]=i2cdata     
'    eep_addr.byte1=144+(59*thermostatCooling)             'Page 144 or 203
'    eep_addr.byte0=t+8        
'    gosub read_eeprom
'    A_ThermostatSensor[t]=i2cdata    
'  next t
'return

'Thermostat_output_off:
'  ok=0
'  for t=0 to (MAX_THERMOSTATS-1)
'    if A_Thermostat[t]<240 then                               'Switch Off A_Thermostat outputs  
'      A_DigitTotal[0]=A_Thermostat[t]
'      digitcount=1
'      gosub output_off    
'    endif
'    if A_Thermostat2[t]<240 then
'      A_DigitTotal[0]=A_Thermostat2[t]
'      digitcount=1
'      gosub output_off    
'    endif        
'  next t
'  for t=0 to 7                                              'Switch Off Pump outputs
'    eep_addr.byte1=144+(59*thermostatCooling)               'page 144 or 203
'    eep_addr.byte0=t  
'    gosub read_eeprom
'    if i2cdata<240 then                                     'Pump output
'      A_DigitTotal[0]=i2cdata
'      digitcount=1
'      gosub output_off
'      A_Action[4]=161
'      A_Action[5]=i2cdata
'      gosub remove_timer_queue                              'Remove any pump actions still in timer queue
'    endif            
'  next t
'  ok=1
'return

'------------------------------------------------------------------------------
' Clock
'------------------------------------------------------------------------------

find_clock:
  i2caddr = 0
  gosub read_i2c_2
  if (i2cdata.bit7=1) then                  'Clock is not running      
    error_code = 3                          'Clock is not running
    gosub send_error
    i2caddr = 0
    i2cdata = 0                             'Start clock DS1307
    gosub write_i2c_2
    for ic=0 to MAX_OUTPUT_MODULES-1                          'If no data in mem, put all outputs on 0
      A_Output(ic)=0
    next ic
    'gosub thermostat_timing                 'set all thermostats in the right mode conform to the programmed timings
    'gosub correct_setpt
    eep_addr.byte0=43                        'address
    eep_addr.byte1=0                         'page
    i2cdata=0                                'RTC NOT OK, probably battery empty
    gosub write_eeprom        
  else
    if controller_out>30 then controller_out=30      
    for ic=1 to controller_out              'read from ram mem ds1307 Output(x)
      i2caddr = 8+ic   
      i2cdata = 0    
      gosub read_i2c_2
      A_Output[ic-1]=i2cdata
    next ic  
   'hier_thermo      
   ' for ic=1 to 24                          'read from ram mem ds1307 Thermostat Setpoints
   '   i2caddr = 39+ic    
   '   i2cdata = 0    
   '   gosub read_i2c_2
   '   if i2cdata=0 then
   '     if (ic-1)<MAX_THERMOSTATS then A_Setpt[ic-1]=76
   '   else
   '     if (ic-1)<MAX_THERMOSTATS then A_Setpt[ic-1]=i2cdata
   '   endif    
   ' next ic        
   ' gosub thermostat_timing           
    gosub read_seconds
    gosub read_minutes
    gosub read_hours
    gosub read_day
    eep_addr.byte0=43                        'address
    eep_addr.byte1=0                         'page
    i2cdata=255                              'RTC is OK
    gosub write_eeprom    
  Endif
return

Calc_time:
  a=x&%00001111
  b=x&%01110000
  c=b>>4
  y=a+(c*10)
return

Calc_date:
  a=x&%00001111
  b=x&%11110000
  c=b>>4
  y=a+(c*10)
return

read_date:
  i2caddr = 4                               'read date
  i2cdata = 0    
  gosub read_i2c_2
  x=i2cdata
  gosub Calc_date
  date = y
  i2caddr = 5                               'read month
  i2cdata = 0    
  gosub read_i2c_2
  x=i2cdata
  gosub Calc_date
  month = y
  i2caddr = 6                               'read year
  i2cdata = 0    
  gosub read_i2c_2
  x=i2cdata
  gosub Calc_date
  year = y    
return

read_seconds:
  i2caddr = 0                               'read seconds
  i2cdata = 0    
  gosub read_i2c_2
  x=i2cdata
  gosub Calc_time
  seconds = y
return

read_minutes:
  i2caddr = 1                               'read minutes
  i2cdata = 0    
  gosub read_i2c_2
  x=i2cdata
  gosub Calc_time
  minutes = y
return

read_hours:
  i2caddr = 2                               'read hours
  i2cdata = 0    
  gosub read_i2c_2
  x=i2cdata
  gosub Calc_time
  if y>23 then 
    y=0
    hours=0
    i2caddr=2                               'hour address in DS1307
    t_word=hours
    gosub ds1307_write                      'Correct hour value in DS1307
  endif  
  hours = y
  if hours=0 and minutes=0 then
    UptimeDays=UptimeDays+1
    i2cdata=UptimeDays/256
    eep_addr.byte0=37                         'address
    eep_addr.byte1=0                          'page
    gosub write_eeprom                        'Write days counter
    i2cdata=UptimeDays//256
    eep_addr.byte0=38                         'address
    gosub write_eeprom                        'Write days counter      
  endif
return

read_day:
  i2caddr = 3                               'read days
  i2cdata = 0    
  gosub read_i2c_2
  days=i2cdata
return

read_clock:
  if ScanTime=1 then
    ScanTime=0
    gosub read_seconds   
    if seconds<>seconds_old then
      'if PidCalcCheck=1 then PidCalcNow=1
      TimerQueueEn=1
      seconds_old=seconds                   'do this routine only 1 time per second
      if seconds=20 or seconds=50 then
        gosub Temp_receive                  'request temperatures from Temperature modules 
        UpdateCanLeds=1                     'Update All CAN Leds      
      endif
      if seconds=10 or seconds=40 then
        if controller_in>0 then
          broad1="M"                          'send broadcast to start measurement sensors
          broad2="M"
          BroadId=0
          gosub Add_Broad_queue
          UpdateCanLeds=1   'Update All CAN Leds
          if dimmer_value_eeprom_write==YES then
            dimmer_value_eeprom_write=NO 
            dimmer_value_eeprom_write_now=YES
          endif 
        endif        
      endif      
      if seconds=0 then
        UpdateCanLeds=1   'Update All CAN Leds
        gosub read_minutes
        if minutes=0 then
          gosub read_day
          gosub read_hours
'          gosub thermostat_timing12
          if hours==0 then 
            Nr_rs485_power_resets=0
            gosub read_date
          endif  
          gosub Check_can_health
        elseif minutes=10 or minutes=20 or minutes=30 or minutes=40 or minutes=50 then
'          gosub Set_CoolingHeating
'          gosub thermostat_timing12
          gosub Check_can_health          
        endif
        gosub check_schedule_queue
      endif  
      if seconds=3 then
'        PidCalcCheck=1
'        PidCalcNow=1
'        gosub ThermostatMode_ON
        'PumpCheckNow=1    
      endif
      if seconds=30 then
'        PumpCheckNow=1
        UpdateCanLeds=1   'Update All CAN Leds
      endif   
      gosub timer_function                  'Decrease timer values for lights that are switched on
      CheckTimerQueue=1                     'gosub check_timer_queue       
    else
      gosub i2c_error
    endif
  endif  
return

i2c_error:
  if hours=0 then
    if seconds=0 and minutes=0 then
      if i2cTimeScan<255 then 
        i2cTimeScan=i2cTimeScan+1
      else
        i2cError=i2cError+1
        ResetI2c=1
        i2cTimeScan=0
      endif
    else
      i2cTimeScan=0
      ResetI2c=0
    endif
    if (err<>0) then 
      error_code = 2                      'Error Time reading
      ErrorTmp=61
      gosub send_error
    endif
  endif  
return

'ThermostatMode_ON:
'  if ThermostatCooling=0 then             'Heating is enabled
'    if (Temp_threshold>A_Temperature[outside_sensor]) or A_Temperature[outside_sensor]>240 then  ' outside Temperature is lower than Thermostat threshold Temperature 
'      if ThermostatOn=0 then         'Thermostat function is off
'        ThermostatOn=1               'Enable Thermostat function
'        ThermostatMode.bit7=1
'        gosub Write_ThermostatMode
'      endif
'    else
'      if ThermostatOn=1 then         'Thermostat function is ON
'        ThermostatOn=0               'Disable Thermostat function
'        ThermostatMode.bit7=0
'        gosub Write_ThermostatMode
'      endif      
'    endif
'  endif
'  'if SetAuto=1 then      'If wrong Temperature is read, re-read all temperatures in auto mode 
'  '  SetAuto=0
'  '  if ThermostatMode.bit3=1 then    'Thermostat is in automatic mode
'  '    A_QueueType[queue_end]=141
'  '    A_QueueAction[queue_end]=1
'  '    gosub Increase_queue_pointer
'  '  endif  
'  'endif
'return

'Set_TBS_Output:
'  if A_ThermostatSensor[q]=240 and A_Thermostat[q]<240 then  'Time based switching (TBS)
'    if A_Setpt[q]>104 then
'      gosub T_output_on
'    else
'      gosub T_output_off
'    endif  
'  endif 
'return

'Thermostat_timing12:
'  if ThermostatUpdate=1 then
'    gosub thermostat_timing
'  else
'    gosub thermostat_timing2
'  endif 
'return          

'Thermostat_timing:
'  Tt=(hours*6)+(minutes/10)    
'  for q=0 to (MAX_THERMOSTATS-1)
'    gosub Thermostat_timing_sub
'  next q   
'return

'Thermostat_timing_sub:
'  if A_ThermostatAuto[q]=1 then             'Thermostat is in automatic mode
'    if A_PermanentManual[q+(MAX_THERMOSTATS*thermostatCooling)]=0 then
'      if A_Thermostat[q]<240 and A_ThermostatSensor[q]<241 then     'Thermostat is linked to output and Temperature sensor
'        eep_addr.byte1=189+((days-1)/2)+(17*thermostatCooling)      'Start page 189 or 206
'        for r=0 to 3
'          eep_addr.byte0=(128*((days-1)//2))+(q*4)+r
'          gosub read_eeprom
'          A_Ttiming[r]=i2cdata 
'        next r    
'        if A_Ttiming[0]<145 or A_Ttiming[2]<145 then              'valid start timing
'          if A_Ttiming[0]<=Tt and A_Ttiming[1]>Tt then
'            'Action turn on Thermostat Day1
'            if startup=0 then gosub Turn_on_Day1           
'          elseif A_Ttiming[2]<=Tt and A_Ttiming[3]>Tt then
'            'Action turn on Thermostat Day2           
'            if startup=0 then gosub Turn_on_Day2 
'          else
'            'Action turn off Thermostat Night           
'            if A_ThermostatSensor[q]<241 then 'Temperature based switching 
'              if startup=0 then gosub Turn_on_night             
'            endif           
'          endif      
'        else
'          'Action turn off Thermostat Night           
'          if A_ThermostatSensor[q]<241  then  'Temperature based switching 
'            if startup=0 then gosub Turn_on_night                  
'          endif      
'        endif 
'      endif
'    endif
'  endif
'return

'Thermostat_timing2:                         'Will set the right setpoint only when the exact begin or end time is reached
'  Tt=(hours*6)+(minutes/10)    
'  for q=0 to (MAX_THERMOSTATS-1)
'    if A_ThermostatAuto[q]=1 then             'Thermostat is in automatic mode
'      if A_PermanentManual[q+(MAX_THERMOSTATS*thermostatCooling)]=0 then
'        if A_Thermostat[q]<240 and A_ThermostatSensor[q]<241 then  'Thermostat is linked to output and Temperature sensor
'          eep_addr.byte1=189+((days-1)/2)+(17*thermostatCooling)      'Start page 189 or 206
'          for r=0 to 3
'            eep_addr.byte0=(128*((days-1)//2))+(q*4)+r
'            gosub read_eeprom
'            A_Ttiming[r]=i2cdata 
'          next r     
'          if A_Ttiming[0]=Tt then
'            'Action turn on Thermostat Day1
'            gosub Turn_on_Day1           
'          elseif A_Ttiming[2]=Tt then
'            'Action turn on Thermostat Day2
'            gosub Turn_on_Day2 
'          elseif A_Ttiming[1]=Tt or A_Ttiming[3]=Tt then
'            'Action turn off Thermostat Night
'            gosub Turn_on_night
'          endif      
'        endif
'      endif
'    endif  
'  next q  
'return

'Turn_on_Day1:
'  'Action turn on Thermostat Day1
'  if A_ThermostatSensor[q]<241 then       'Temperature based switching
'    if IndividualTempOn=1 then          'Individual Temperatures are ON
'      'A_QueueType[queue_end]=145     'Day1
'      'A_QueueAction[queue_end]=q
'      BA_type_queue=145
'      BA_action_queue=q  
'      gosub Increase_queue_pointer             
'    else
'      'A_QueueType[queue_end]=128     'setpoint 0 (day1)
'      'A_QueueAction[queue_end]=q
'      BA_type_queue=128
'      BA_action_queue=q       
'      gosub Increase_queue_pointer               
'    endif
'  endif                 
'return

'Turn_on_day2:
'  'Action turn on Thermostat Day2
'  if A_ThermostatSensor[q]<241 then       'Temperature based switching
'    if IndividualTempOn=1 then          'Individual Temperatures are ON
'      'A_QueueType[queue_end]=146     'Day2
'      'A_QueueAction[queue_end]=q 
'      BA_type_queue=146
'      BA_action_queue=q       
'      gosub Increase_queue_pointer             
'    else
'      'A_QueueType[queue_end]=130     'setpoint 2 (day2)
'      'A_QueueAction[queue_end]=q
'      BA_type_queue=130
'      BA_action_queue=q       
'      gosub Increase_queue_pointer               
'    endif
'  endif                            
'Return

'Turn_on_night:
'  'Action turn on Thermostat Night
'  if A_ThermostatSensor[q]<241 then       'Temperature based switching
'    if IndividualTempOn=1 then          'Individual Temperatures are ON
'      'A_QueueType[queue_end]=147     'Night
'      'A_QueueAction[queue_end]=q
'      BA_type_queue=147
'      BA_action_queue=q      
'      gosub Increase_queue_pointer              
'    else
'      'A_QueueType[queue_end]=129     'setpoint 1 (Night)
'      'A_QueueAction[queue_end]=q
'      BA_type_queue=129
'      BA_action_queue=q     
'      gosub Increase_queue_pointer               
'    endif
'  endif                            
'Return

'T_output_on:
'  'A_QueueType[queue_end]=166         'Output on at Maximum
'  'A_QueueAction[queue_end]=A_Thermostat[q]
'  BA_type_queue=166
'  BA_action_queue=A_Thermostat[q]  
'  gosub Increase_queue_pointer   
'return

'T_output_off:
'  'A_QueueType[queue_end]=160         'Output off
'  'A_QueueAction[queue_end]=A_Thermostat[q]
'  BA_type_queue=160
'  BA_action_queue=A_Thermostat[q]  
'  gosub Increase_queue_pointer
'  z=A_Thermostat[q]
'  A_DimmerValue[z]=0 
'return

Empty_RecInstr:
  for j=0 to (BUFFER_RS232-1)
    A_SerString[j]=0
  next j
return

Cleanup_Serstring:
  a=0
  for j=0 to (BUFFER_RS232-1)
    if A_SerString[j]>31 and A_SerString<127 then a=1  'assci found
    if A_SerString[j]=0 and a=0 then A_SerString[j]=" "
    if A_SerString[j]=0 and a=1 then
      A_SerString[j]=13
      j=BUFFER_RS232-1
    endif
  next j
return


check_schedule_queue:                       'check if no scheduled actions must be activated
  if Sched_queue_counter>0 then             'something is in the scheduled Action queue
    for t=0 to (sched_queue_max-1)
      if A_SchedType[t]<255 then             'valid Action type
        if (A_SchedHour[t]=hours and A_SchedMinute[t]=minutes) or (A_SchedHour[t]=24 and A_SchedMinute[t]=0) then
          x=A_SchedDay[t]
          x=x>>days
          if x.bit0=1 then
            'A_QueueType[queue_end]=A_SchedType[t]
            'A_QueueAction[queue_end]=A_SchedAction[t]
            BA_type_queue=A_SchedType[t]
            BA_action_queue=A_SchedAction[t]            
            gosub Increase_queue_pointer
            x=A_SchedDay[t]
            if x.bit0=0 then                'remove from queue
              A_DigitTotal[0]=t
              digitcount=1
              ok=0
              gosub schedule_queue_delete
              ok=1
            endif
          endif  
        endif
      endif
    next t
  endif
return

Increase_queue_pointer:
    'hserout2 ["added in queue(",dec queue_end,"): type=",dec A_QueueType[queue_end]," action=",dec A_QueueAction[queue_end],13,10]
    A_QueueType[queue_end]=BA_type_queue
    A_QueueAction[queue_end]=BA_action_queue
    if queue_end<(queue_max-1) then queue_end=queue_end+1
    'hserout2 ["new queue end=",dec queue_end,13,10]
return

'------------------------------------------------------------------------------
' Timer Function
'------------------------------------------------------------------------------

check_timer_queue:                          'check timer queue for intelligent actions (pressed input for x seconds)  
  if CheckTimerQueue=1 then
    CheckTimerQueue=0  
    if timer_queue_pointer>0 and timer_queue_pointer<TIMER_queue then   
      for i=1 to timer_queue_pointer
        a=A_TimerInput[i-1]/8
        b=A_TimerInput[i-1]//8
        c=0
        d=A_TimerInput[i-1]
        if A_TimerInput[i-1]<240 and A_TimerSeconds[i-1]<250 then    'Timer queue related to an input
          c=A_Input[a]>>b                       'This cannot be put at the start of this routine because timer input can be 240
          if c.bit0=1 then                  'button is still pressed
            gosub check_timer_count         'decrease timer and execute Action when timer is at 0
          else                              'button is not pressed anymore
            if (i-1)<timer_queue then A_TimerSeconds[i-1]=0
          endif
        endif    
        if A_TimerInput[i-1]=240 then        'Delayed execution of an Action
          gosub check_timer_count           'decrease timer and execute Action when timer is at 0
        endif
        if A_TimerSeconds[i-1]=250 then
          c=A_Input[a]>>b                       'This cannot be put at the start of this routine because timer input can be 240
          if c.bit0=0 then
            if A_InputDelayAction[d]=0 then   'execute Action in the queue     
              gosub Add_timer_action
            else                            'delete Action from the queue
              if (i-1)<timer_queue then A_TimerSeconds[i-1]=0
            endif
          endif  
        endif
      next i    
      TimerQueueEn=0
    endif
    gosub clean_timer_queue
  endif    
return

check_timer_count:
    if A_TimerSeconds[i-1]>0 and A_TimerSeconds[i-1]<250 and TimerQueueEn=1 then
        d=A_TimerInput[i-1] 
        if (i-1)<timer_queue then A_TimerSeconds[i-1]=A_TimerSeconds[i-1]-1 
        A_InputDelayAction[d]=0                   'delayed Action is not executed so the other actions in the queue can be executed when input is off  
        if A_TimerSeconds[i-1]=0 then            'if A_TimerSeconds=0 then execute Action for both "input pressed" and "delayed Action"
            A_InputDelayAction[d]=1                 'delayed Action is executed so don't execute the other actions in the queue
            gosub add_timer_action                'only for delayed execution of an Action
        endif    
    endif  
return  

'hier RS
add_timer_action:
    if A_TimerType[i-1]=102 or A_TimerType[i-1]=106 then All_stores_overule_locked=YES    'If timer based group stop or individual stop, ignore stores_locked function
    'A_QueueType[queue_end]=A_TimerType[i-1]
    'A_QueueAction[queue_end]=A_TimerAction[i-1]
    BA_type_queue=A_TimerType[i-1]
    BA_action_queue=A_TimerAction[i-1]
    gosub Increase_queue_pointer
    if (i-1)<timer_queue then A_TimerSeconds[i-1]=0 
return

clean_timer_queue:                          'clean the queue of the non used actions anymore
  if timer_queue_pointer>0 and timer_queue_pointer<TIMER_queue then 
    timer_queue_last=1
    for i=timer_queue_pointer to 1 step -1
      a=A_TimerInput[i-1]/8
      b=A_TimerInput[i-1]//8
      c=A_Input[a]>>b
      if A_TimerSeconds[i-1]=0 or A_TimerType[i-1]=255 then
        if timer_queue_last=1 and timer_queue_pointer>0 then
          timer_queue_pointer=timer_queue_pointer-1  'Clean up
        endif
      else
        timer_queue_last=0                  'no further clean up for the moment
      endif
    next i   
  endif
return

Fill_timer_queue:
  if (t-1)<timer_queue then
    A_TimerAction[t-1]=A_Action[5]                                               
    A_TimerType[t-1]=A_Action[4]
    A_TimerInput[t-1]=A_Action[6]
    A_TimerSeconds[t-1]=A_Action[3]
  endif  
return  


timer_queue_list:
  for x=1 to timer_queue_pointer
    hserout2 [dec3 x-1," ",dec3 A_TimerType[x-1]," ",dec3 A_TimerAction[x-1]," ",dec3 A_TimerInput[x-1]," ",dec3 A_TimerSeconds[x-1],13,10]
  next x  
  gosub send_mes_ok
return

Add_timer_queue2:
  i_bit=0
  if timer_queue_pointer>0 and timer_queue_pointer<TIMER_queue then
    for t=1 to timer_queue_pointer
      if A_TimerType[t-1]=255 and A_TimerAction[t-1]=255 then             'Empty entry found
        gosub fill_timer_queue
        t=timer_queue_pointer
        i_bit=1                                                         'Info to queue added, only add once
      endif
    next t
  endif
  if i_bit=0 then                                                       'No empty spaces found, add this at the end
    t=timer_queue_pointer+1   
    gosub fill_timer_queue
    if timer_queue_pointer<(timer_queue-1) then timer_queue_pointer=timer_queue_pointer+1
  endif
return


add_timer_queue:
    'add Action to the timer queue     
    A_Action[5]=BA_action
    A_Action[4]=BA_type
    if DelayedTime>0 and DelayedTime<250 and ActionButtonRelease=0 then   'Action after x seconds
      A_Action[6]=240
      A_Action[3]=DelayedTime
    else                                                                  'Action at button release
      A_Action[6]=CurrentInput
      A_Action[3]=250
    endif
    if CleanTimerQueue=1 then                                             'Check for double BA's and remove them, see also BA 79
      gosub remove_timer_queue
    endif  
    Gosub add_timer_queue2   
return

timer_function:
  if controller_out<=MAX_OUTPUT_MODULES then
    for i=1 to controller_out
      for t=0 to 7
        x=A_Output[i-1]>>t
        y=((i-1)*8)+t
        if A_TimerCd[y]>0 and x.bit0=1 then
          if y<MAX_OUTPUTS then A_TimerCd[y]=A_TimerCd[y]-1
          if A_TimerCd[y]=0 then
            'A_QueueType[queue_end]=160      'Output OFF
            'A_QueueAction[queue_end]=y
            BA_type_queue=160
            BA_action_queue=y             
            gosub Increase_queue_pointer               
          endif
        endif
      next t  
    next i
  endif
return


Timer_value:                                'i
  for t=0 to 7                              'check all outputs of a selected device
    x=A_Output(i-1)>>t
    y=((i-1)*8)+t
    if x.bit0=1 then                        'selected output is ON, remember (var A_TimerSet) to put back the timer value
      if y<MAX_OUTPUTS then A_TimerSet[y]=0
    endif  
    if x.bit0=0 and A_TimerSet[y]=0 then      'selected output is off
      if y<MAX_OUTPUTS then A_TimerSet[y]=1
      timer=y
      Gosub Timer_value_read                'retreive timer value
      if y<MAX_OUTPUTS then A_TimerCd[y]=timer                     'Put timer value in TimerCd
    endif
  next t
return     

Temp_receive:                               'routine used to check Temperature in normal mode (mode="L")
  if Temp_Mod_installed=1 then              'Temperature module 16 Temperature sensors
    high RS485_DIR                          'Send mode
    hserout ["tmT000T",0,13,10]
    gosub low_rs485_dir                     'Receive mode
    RS485Message="t"
    gosub prepare_rs485_receive
  endif 
return

Temperature_Offset:
  b=A_TempOffset[a]
  if b<>255 then
    c=b&%00001111
    if A_Temperature[a]>1 and A_Temperature[a]<185 then
      if b.bit7=0 then '+
        IF a<MAX_SENSORS then A_Temperature[a]=A_Temperature[a]+c
      else             '-
        if a<MAX_SENSORS then A_Temperature[a]=A_Temperature[a]-c
      endif
    endif  
  endif
return

Read_sensor_values:
  if A_RS485string[4]="T" then                'Temperature  
    for ic=0 to 7
      a=(TemperatureCount*8)+ic
      gosub Set_Temperature
      gosub Temperature_Offset
    next ic     
  elseif A_RS485string[4]="H" then            'humidity       
    for ic=0 to 7
      if A_VirtualSensor[(TemperatureCount*8)+ic]=0 then              'Virtual sensor not active so Sensor data can be update by OM sensors
        a=(TemperatureCount*8)+ic
        if a<MAX_SENSORS then A_humidity[a] = A_RS485string[5+ic]
      endif  
    next ic
  elseif A_RS485string[4]="A" then            'ADC value      
    for ic=0 to 7
      if A_VirtualSensor[(TemperatureCount*8)+ic]=0 then              'Virtual sensor not active so Sensor data can be update by OM sensors
        a=(TemperatureCount*8)+ic
        if a<MAX_SENSORS then A_ldr[a] = A_RS485string[5+ic]
      endif  
    next ic                
  endif
return

Set_Temperature:  
  if A_VirtualSensor[a]=0 then            'Virtual sensor not active so Sensor data can be update by OM sensors
    if outside_sensor=a then              'No lower correction for the outside sensor
      if A_RS485string[5+ic]<189 then
        if a<MAX_SENSORS then A_Temperature[a] = A_RS485string[5+ic]
      else
        if a<MAX_SENSORS then A_Temperature[a]=255  
      endif        
    else                                  'Limit inside Temperature between 5 and 45 degree Celsius as standard value programmed in page 0 byte 34 & 35
'      if (A_RS485string[5+ic]>ThermostatDownLimitTemp and A_RS485string[5+ic]<ThermostatUpLimitTemp) or TempCor=0 then    
        if a<MAX_SENSORS then A_Temperature[a] = A_RS485string[5+ic]
'      else
'        if a<MAX_SENSORS then A_Temperature[a]=255      
'      endif
    endif
  endif  
return


Check_response_temp_module:
  if A_RS485string[0]=A_ModID0[i-1] and A_RS485string[1]=A_ModID1[i-1] and A_RS485string[2]=A_ModID2[i-1] and A_RS485string[3]=A_ModID3[i-1] then     
    if A_RS485string[0]="T" and TemperatureCount<4 then                           'Temperature Module (max 4)
      if A_RS485string[13]="C" or ForceCRC=1 then                                 'CRC check is active at input slave module
        CRC2=A_RS485string[4]+A_RS485string[5]+A_RS485string[6]+A_RS485string[7]+A_RS485string[8]
        CRC2=CRC2+A_RS485string[9]+A_RS485string[10]+A_RS485string[11]+A_RS485string[12]
        if CRC2.byte1=A_RS485string[14] and CRC2.byte0=A_RS485string[15] then       'CRC is correct
          gosub Read_sensor_values
        else                                                                    'CRC is wrong
          A_ErrorID[0]= A_ModID0[i-1]         'Input device is not responding
          A_ErrorID[1]= A_ModID1[i-1]
          A_ErrorID[2]= A_ModID2[i-1]
          A_ErrorID[3]= A_ModID3[i-1]
          ErrorTmp=i-1
          error_code = 27                   'Wrong CRC or CRC information is missing
          cid = 0
          Gosub Add_ErrorCount
          gosub send_error  
        endif  
      else
        gosub Read_sensor_values
      endif      
      if TemperatureCount<3 then TemperatureCount=TemperatureCount+1       
    endif        
  else                                      'wrong device responded      
    A_ErrorID[0]= A_ModID0[i-1]               'device is not responding
    A_ErrorID[1]= A_ModID1[i-1]
    A_ErrorID[2]= A_ModID2[i-1]
    A_ErrorID[3]= A_ModID3[i-1]
    ErrorTmp=i-1
    error_code = 10
    cid = 0
    Gosub Add_ErrorCount
    gosub send_error   
  endif 
return      

'------------------------------------------------------------------------------
' Eeprom
'------------------------------------------------------------------------------

write_eeprom:  
  i2ccont = %10100000
  i2cClock=0
  if EepPage0=0 then
    OledEeprom.byte1=eep_addr.byte1
    OledEeprom.Byte0=0
  endif  
  oledDataOk=0
  OledEepromBit=0
  if OledEeprom.byte1=0 then EepPage0=1
  gosub i2c_write
return

read_eeprom:
  i2ccont = %10100001
  i2cClock=0
  gosub i2c_read  
return

write_i2c_2:
  i2ccont=%11010000
  i2cClock=1
  if i2caddr<64 then                        'Clock has 56 bytes of SRAM
    eep_addr.byte1=i2caddr
    gosub i2c_write
  endif  
return

read_i2c_2:
  i2ccont=%11010001
  i2cClock=1
  eep_addr.byte1=i2caddr
  gosub i2c_read 
return

check_i2c_acknowledge:
  if SSP2CON2.6=0 then                      'Acknowledge received from slave
    i2cAck=1                                'Acknowledge received
    SSP2CON2.6=1
  else
    i2cAck=0
  endif 
return

i2c_read:
  if i2ccont.bit0=0 then                    'r/w bit is wrong, correct
    i2ccont.bit0=1
  endif
  i2creadbit=1
  i2cint=1
  i2cmode=1
  TMR3L=0
  TMR3H=0
  T3CON.0=1                                 'start timer3
  gosub i2c_routine_read
return

i2c_write:
  if i2ccont.bit0=1 then                    'r/w bit is wrong, correct
    i2ccont.bit0=0
  endif
  i2creadbit=0
  i2cint=1
  i2cmode=1
  TMR3L=0
  TMR3H=0  
  T3CON.0=1                                 'start timer3                    
  gosub i2c_routine_write  
return

i2c_routine_write:
  while (i2cMode>0) 
    if i2cInt=1 then                        'i2c chip is ready for next instruction
      i2cInt=0  
      gosub i2cPhase1    
      if i2cMode=5 then                     'check acknowledge and send data   
        gosub check_i2c_acknowledge
        if i2cAck=1 then
          SSP2BUF=i2cData
        endif  
      endif
      if i2cMode=6 then                     'check acknowledge and sent stop   
        gosub check_i2c_acknowledge
        if i2cAck=1 then
          SSP2CON2.2=1
        endif     
      endif
      if i2cMode=7 then                     'end transmission 
        i2cMode=0
        T3CON.0=0                           'stop timer3
        err=0
        if i2cClock=0 then pause 5 
      endif    
    endif
  wend      
return

i2c_routine_read:
  while (i2cMode>0) 
    if i2cInt=1 then                        'i2c chip is ready for next instruction
      i2cInt=0  
      gosub i2cPhase1
      if i2cMode=5 then                     'generate start condition
        gosub check_i2c_acknowledge
        if i2cAck=1 then      
          SSP2CON2.0=1                      'start
        endif  
      endif
      if i2cMode=6 then                     'shift Output i2c control byte
        SSP2BUF=i2ccont
      endif 
      if i2cMode=7 then
        SSP2CON2.3=1                        'enable receiving
      endif         
      if i2cMode=8 then                     'check acknowledge and receive data 
        i2cdata=SSP2BUF
        i2cMode=9 
      endif
      if i2cMode=9 then                     'sent stop   
        SSP2CON2.2=1     
      endif
      if i2cMode=10 then                    'end transmission 
        i2cMode=0
        T3CON.0=0                           'stop timer3
        err=0
      endif    
    endif
  wend      
return

i2cPhase1:
  if i2cMode=1 then                         'generate start condition
    SSP2CON2.0=1
  endif
  if i2cMode=2  then                        'shift Output i2c control byte
    SSP2BUF=i2ccont-i2creadbit              'when reading i2c, you first need to write
  endif
  if i2cMode=3 then                         'check acknowledge and shift Output i2c high address   
    gosub check_i2c_acknowledge
    if i2cAck=1 then
      SSP2BUF=eep_addr.byte1                'high address
    endif  
  endif
  if i2cMode=4 then                         'check acknowledge and shift Output i2c low address  
    if i2cClock=1 then                      'Clock IC has only 8bits address
      i2cmode=5
    else
      SSP2BUF=eep_addr.byte0                'low address
    endif  
  endif
return

end
